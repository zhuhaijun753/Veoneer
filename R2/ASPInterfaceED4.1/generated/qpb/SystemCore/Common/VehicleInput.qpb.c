/* Automatically generated qpb constant definitions */
/* Generated by Quick Protocol Buffers - 2 */

#include "SystemCore/Common/VehicleInput.qpb.h"
#include "Tools/QuickProtobuf/qpb_decode.h"
#include "Tools/QuickProtobuf/qpb_encode.h"
#include "Tools/CSupport/ConversionSupport.h"

#if QPB_PROTO_HEADER_VERSION != 2
#error Regenerate this file with the current version of qpb generator.
#endif

#define F_0_0001             0.0001f
#define F_0_01               0.01f

static inline void encode_SystemCore_Common_AcceleratorPedal_Raw_valid(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Common_AcceleratorPedal_Raw_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_AcceleratorPedal_Raw_pressedAmount(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_Common_AcceleratorPedal_Raw_pressedAmount(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_BrakeSystem_Raw_valid(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Common_BrakeSystem_Raw_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_BrakeSystem_Raw_brakePedalState(qpb_ostream_t *const stream, const SystemCore_Common_BrakePedalState *const data);
static bool decode_SystemCore_Common_BrakeSystem_Raw_brakePedalState(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_BrakeSystem_Raw_decelerationRequest(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_SystemCore_Common_BrakeSystem_Raw_decelerationRequest(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_BrakeSystem_valid(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Common_BrakeSystem_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_BrakeSystem_brakePedalState(qpb_ostream_t *const stream, const SystemCore_Common_BrakePedalState *const data);
static bool decode_SystemCore_Common_BrakeSystem_brakePedalState(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_BrakeSystem_decelerationRequest(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_Common_BrakeSystem_decelerationRequest(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_FrontWheel_Raw_valid(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Common_FrontWheel_Raw_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_FrontWheel_Raw_angle(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_SystemCore_Common_FrontWheel_Raw_angle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_FrontWheel_Raw_angleRate(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_SystemCore_Common_FrontWheel_Raw_angleRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_FrontWheel_valid(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Common_FrontWheel_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_FrontWheel_angle(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_Common_FrontWheel_angle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_FrontWheel_angleRate(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_Common_FrontWheel_angleRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_SafePositionsFrontSeats_Raw_left(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Common_SafePositionsFrontSeats_Raw_left(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_SafePositionsFrontSeats_Raw_right(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Common_SafePositionsFrontSeats_Raw_right(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_SteeringWheel_Raw_valid(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Common_SteeringWheel_Raw_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_SteeringWheel_Raw_limited(qpb_ostream_t *const stream, const SystemCore_Common_AngleControlLimitState *const data);
static bool decode_SystemCore_Common_SteeringWheel_Raw_limited(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_SteeringWheel_Raw_torque(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_SystemCore_Common_SteeringWheel_Raw_torque(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_SteeringWheel_Raw_functionAppliedTorque(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_SystemCore_Common_SteeringWheel_Raw_functionAppliedTorque(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_SteeringWheel_Raw_totalAppliedTorque(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_SystemCore_Common_SteeringWheel_Raw_totalAppliedTorque(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_SteeringWheel_valid(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Common_SteeringWheel_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_SteeringWheel_limited(qpb_ostream_t *const stream, const SystemCore_Common_AngleControlLimitState *const data);
static bool decode_SystemCore_Common_SteeringWheel_limited(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_SteeringWheel_torque(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_Common_SteeringWheel_torque(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_SteeringWheel_functionAppliedTorque(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_Common_SteeringWheel_functionAppliedTorque(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_SteeringWheel_totalAppliedTorque(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_Common_SteeringWheel_totalAppliedTorque(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_VehicleInput_Raw_acceleratorPedal(qpb_ostream_t *const stream, const SystemCore_Common_AcceleratorPedal_Raw *const data);
static bool decode_SystemCore_Common_VehicleInput_Raw_acceleratorPedal(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_VehicleInput_Raw_brakeSystem(qpb_ostream_t *const stream, const SystemCore_Common_BrakeSystem_Raw *const data);
static bool decode_SystemCore_Common_VehicleInput_Raw_brakeSystem(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_VehicleInput_Raw_steeringWheel(qpb_ostream_t *const stream, const SystemCore_Common_SteeringWheel_Raw *const data);
static bool decode_SystemCore_Common_VehicleInput_Raw_steeringWheel(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_VehicleInput_Raw_frontWheel(qpb_ostream_t *const stream, const SystemCore_Common_FrontWheel_Raw *const data);
static bool decode_SystemCore_Common_VehicleInput_Raw_frontWheel(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_VehicleInput_Raw_turnIndicator(qpb_ostream_t *const stream, const SystemCore_Common_TurnIndicatorState *const data);
static bool decode_SystemCore_Common_VehicleInput_Raw_turnIndicator(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_VehicleInput_Raw_driverDoorOpen(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Common_VehicleInput_Raw_driverDoorOpen(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_VehicleInput_Raw_safePositionsFrontSeats(qpb_ostream_t *const stream, const SystemCore_Common_SafePositionsFrontSeats_Raw *const data);
static bool decode_SystemCore_Common_VehicleInput_Raw_safePositionsFrontSeats(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_VehicleInput_acceleratorPedal(qpb_ostream_t *const stream, const SystemCore_Common_AcceleratorPedal *const data);
static bool decode_SystemCore_Common_VehicleInput_acceleratorPedal(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_VehicleInput_brakeSystem(qpb_ostream_t *const stream, const SystemCore_Common_BrakeSystem *const data);
static bool decode_SystemCore_Common_VehicleInput_brakeSystem(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_VehicleInput_steeringWheel(qpb_ostream_t *const stream, const SystemCore_Common_SteeringWheel *const data);
static bool decode_SystemCore_Common_VehicleInput_steeringWheel(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_VehicleInput_frontWheel(qpb_ostream_t *const stream, const SystemCore_Common_FrontWheel *const data);
static bool decode_SystemCore_Common_VehicleInput_frontWheel(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_VehicleInput_turnIndicator(qpb_ostream_t *const stream, const SystemCore_Common_TurnIndicatorState *const data);
static bool decode_SystemCore_Common_VehicleInput_turnIndicator(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_VehicleInput_driverDoorOpen(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Common_VehicleInput_driverDoorOpen(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Common_VehicleInput_safePositionsFrontSeats(qpb_ostream_t *const stream, const SystemCore_Common_SafePositionsFrontSeats *const data);
static bool decode_SystemCore_Common_VehicleInput_safePositionsFrontSeats(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);

#define SystemCore_Common_AcceleratorPedal_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_Common_AcceleratorPedal_Raw_decoders[SystemCore_Common_AcceleratorPedal_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Common_AcceleratorPedal_Raw_valid },
   { &decode_SystemCore_Common_AcceleratorPedal_Raw_pressedAmount }
};

#define SystemCore_Common_BrakeSystem_Raw_DECODERS_COUNT 4
const qpb_decoder_entry_t SystemCore_Common_BrakeSystem_Raw_decoders[SystemCore_Common_BrakeSystem_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Common_BrakeSystem_Raw_valid },
   { &decode_SystemCore_Common_BrakeSystem_Raw_brakePedalState },
   { &decode_SystemCore_Common_BrakeSystem_Raw_decelerationRequest }
};

#define SystemCore_Common_BrakeSystem_DECODERS_COUNT 4
const qpb_decoder_entry_t SystemCore_Common_BrakeSystem_decoders[SystemCore_Common_BrakeSystem_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Common_BrakeSystem_valid },
   { &decode_SystemCore_Common_BrakeSystem_brakePedalState },
   { &decode_SystemCore_Common_BrakeSystem_decelerationRequest }
};

#define SystemCore_Common_FrontWheel_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t SystemCore_Common_FrontWheel_Raw_decoders[SystemCore_Common_FrontWheel_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Common_FrontWheel_Raw_valid },
   { &decode_SystemCore_Common_FrontWheel_Raw_angle },
   { &qpb_skip_field },
   { &decode_SystemCore_Common_FrontWheel_Raw_angleRate }
};

#define SystemCore_Common_FrontWheel_DECODERS_COUNT 5
const qpb_decoder_entry_t SystemCore_Common_FrontWheel_decoders[SystemCore_Common_FrontWheel_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Common_FrontWheel_valid },
   { &decode_SystemCore_Common_FrontWheel_angle },
   { &qpb_skip_field },
   { &decode_SystemCore_Common_FrontWheel_angleRate }
};

#define SystemCore_Common_SafePositionsFrontSeats_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_Common_SafePositionsFrontSeats_Raw_decoders[SystemCore_Common_SafePositionsFrontSeats_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Common_SafePositionsFrontSeats_Raw_left },
   { &decode_SystemCore_Common_SafePositionsFrontSeats_Raw_right }
};

#define SystemCore_Common_SteeringWheel_Raw_DECODERS_COUNT 6
const qpb_decoder_entry_t SystemCore_Common_SteeringWheel_Raw_decoders[SystemCore_Common_SteeringWheel_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Common_SteeringWheel_Raw_valid },
   { &decode_SystemCore_Common_SteeringWheel_Raw_limited },
   { &decode_SystemCore_Common_SteeringWheel_Raw_torque },
   { &decode_SystemCore_Common_SteeringWheel_Raw_functionAppliedTorque },
   { &decode_SystemCore_Common_SteeringWheel_Raw_totalAppliedTorque }
};

#define SystemCore_Common_SteeringWheel_DECODERS_COUNT 6
const qpb_decoder_entry_t SystemCore_Common_SteeringWheel_decoders[SystemCore_Common_SteeringWheel_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Common_SteeringWheel_valid },
   { &decode_SystemCore_Common_SteeringWheel_limited },
   { &decode_SystemCore_Common_SteeringWheel_torque },
   { &decode_SystemCore_Common_SteeringWheel_functionAppliedTorque },
   { &decode_SystemCore_Common_SteeringWheel_totalAppliedTorque }
};

#define SystemCore_Common_VehicleInput_Raw_DECODERS_COUNT 8
const qpb_decoder_entry_t SystemCore_Common_VehicleInput_Raw_decoders[SystemCore_Common_VehicleInput_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Common_VehicleInput_Raw_acceleratorPedal },
   { &decode_SystemCore_Common_VehicleInput_Raw_brakeSystem },
   { &decode_SystemCore_Common_VehicleInput_Raw_steeringWheel },
   { &decode_SystemCore_Common_VehicleInput_Raw_frontWheel },
   { &decode_SystemCore_Common_VehicleInput_Raw_turnIndicator },
   { &decode_SystemCore_Common_VehicleInput_Raw_driverDoorOpen },
   { &decode_SystemCore_Common_VehicleInput_Raw_safePositionsFrontSeats }
};

#define SystemCore_Common_VehicleInput_DECODERS_COUNT 8
const qpb_decoder_entry_t SystemCore_Common_VehicleInput_decoders[SystemCore_Common_VehicleInput_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Common_VehicleInput_acceleratorPedal },
   { &decode_SystemCore_Common_VehicleInput_brakeSystem },
   { &decode_SystemCore_Common_VehicleInput_steeringWheel },
   { &decode_SystemCore_Common_VehicleInput_frontWheel },
   { &decode_SystemCore_Common_VehicleInput_turnIndicator },
   { &decode_SystemCore_Common_VehicleInput_driverDoorOpen },
   { &decode_SystemCore_Common_VehicleInput_safePositionsFrontSeats }
};

static inline void encode_SystemCore_Common_AcceleratorPedal_Raw_valid(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Common_AcceleratorPedal_Raw_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Common_AcceleratorPedal_Raw*)data)->valid, sizeof(bool));
}

static inline void encode_SystemCore_Common_AcceleratorPedal_Raw_pressedAmount(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_Common_AcceleratorPedal_Raw_pressedAmount(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_Common_AcceleratorPedal_Raw*)data)->pressedAmount, sizeof(uint8_t));
}

static inline void encode_SystemCore_Common_BrakeSystem_Raw_valid(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Common_BrakeSystem_Raw_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Common_BrakeSystem_Raw*)data)->valid, sizeof(bool));
}

static inline void encode_SystemCore_Common_BrakeSystem_Raw_brakePedalState(qpb_ostream_t *const stream, const SystemCore_Common_BrakePedalState *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Common_BrakeSystem_Raw_brakePedalState(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Common_BrakeSystem_Raw*)data)->brakePedalState, qpb_membersize(SystemCore_Common_BrakeSystem_Raw, brakePedalState));
}

static inline void encode_SystemCore_Common_BrakeSystem_Raw_decelerationRequest(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_Common_BrakeSystem_Raw_decelerationRequest(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_Common_BrakeSystem_Raw*)data)->decelerationRequest, sizeof(uint16_t));
}

static inline void encode_SystemCore_Common_BrakeSystem_valid(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Common_BrakeSystem_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Common_BrakeSystem*)data)->valid, sizeof(bool));
}

static inline void encode_SystemCore_Common_BrakeSystem_brakePedalState(qpb_ostream_t *const stream, const SystemCore_Common_BrakePedalState *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Common_BrakeSystem_brakePedalState(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Common_BrakeSystem*)data)->brakePedalState, qpb_membersize(SystemCore_Common_BrakeSystem, brakePedalState));
}

static inline void encode_SystemCore_Common_BrakeSystem_decelerationRequest(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_SystemCore_Common_BrakeSystem_Raw_decelerationRequest(stream, &value);
}

static bool decode_SystemCore_Common_BrakeSystem_decelerationRequest(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((SystemCore_Common_BrakeSystem*)data)->decelerationRequest = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_Common_FrontWheel_Raw_valid(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Common_FrontWheel_Raw_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Common_FrontWheel_Raw*)data)->valid, sizeof(bool));
}

static inline void encode_SystemCore_Common_FrontWheel_Raw_angle(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_Common_FrontWheel_Raw_angle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_Common_FrontWheel_Raw*)data)->angle, sizeof(int32_t));
}

static inline void encode_SystemCore_Common_FrontWheel_Raw_angleRate(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_Common_FrontWheel_Raw_angleRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_Common_FrontWheel_Raw*)data)->angleRate, sizeof(int32_t));
}

static inline void encode_SystemCore_Common_FrontWheel_valid(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Common_FrontWheel_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Common_FrontWheel*)data)->valid, sizeof(bool));
}

static inline void encode_SystemCore_Common_FrontWheel_angle(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_0001, INT32_MIN, INT32_MAX);
   encode_SystemCore_Common_FrontWheel_Raw_angle(stream, &value);
}

static bool decode_SystemCore_Common_FrontWheel_angle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((SystemCore_Common_FrontWheel*)data)->angle = value * F_0_0001;
   return result;
}

static inline void encode_SystemCore_Common_FrontWheel_angleRate(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_0001, INT32_MIN, INT32_MAX);
   encode_SystemCore_Common_FrontWheel_Raw_angleRate(stream, &value);
}

static bool decode_SystemCore_Common_FrontWheel_angleRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((SystemCore_Common_FrontWheel*)data)->angleRate = value * F_0_0001;
   return result;
}

static inline void encode_SystemCore_Common_SafePositionsFrontSeats_Raw_left(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Common_SafePositionsFrontSeats_Raw_left(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Common_SafePositionsFrontSeats_Raw*)data)->left, sizeof(bool));
}

static inline void encode_SystemCore_Common_SafePositionsFrontSeats_Raw_right(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Common_SafePositionsFrontSeats_Raw_right(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Common_SafePositionsFrontSeats_Raw*)data)->right, sizeof(bool));
}

static inline void encode_SystemCore_Common_SteeringWheel_Raw_valid(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Common_SteeringWheel_Raw_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Common_SteeringWheel_Raw*)data)->valid, sizeof(bool));
}

static inline void encode_SystemCore_Common_SteeringWheel_Raw_limited(qpb_ostream_t *const stream, const SystemCore_Common_AngleControlLimitState *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Common_SteeringWheel_Raw_limited(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Common_SteeringWheel_Raw*)data)->limited, qpb_membersize(SystemCore_Common_SteeringWheel_Raw, limited));
}

static inline void encode_SystemCore_Common_SteeringWheel_Raw_torque(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_Common_SteeringWheel_Raw_torque(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_Common_SteeringWheel_Raw*)data)->torque, sizeof(int32_t));
}

static inline void encode_SystemCore_Common_SteeringWheel_Raw_functionAppliedTorque(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_Common_SteeringWheel_Raw_functionAppliedTorque(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_Common_SteeringWheel_Raw*)data)->functionAppliedTorque, sizeof(int32_t));
}

static inline void encode_SystemCore_Common_SteeringWheel_Raw_totalAppliedTorque(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_Common_SteeringWheel_Raw_totalAppliedTorque(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_Common_SteeringWheel_Raw*)data)->totalAppliedTorque, sizeof(int32_t));
}

static inline void encode_SystemCore_Common_SteeringWheel_valid(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Common_SteeringWheel_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Common_SteeringWheel*)data)->valid, sizeof(bool));
}

static inline void encode_SystemCore_Common_SteeringWheel_limited(qpb_ostream_t *const stream, const SystemCore_Common_AngleControlLimitState *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Common_SteeringWheel_limited(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Common_SteeringWheel*)data)->limited, qpb_membersize(SystemCore_Common_SteeringWheel, limited));
}

static inline void encode_SystemCore_Common_SteeringWheel_torque(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_01, INT32_MIN, INT32_MAX);
   encode_SystemCore_Common_SteeringWheel_Raw_torque(stream, &value);
}

static bool decode_SystemCore_Common_SteeringWheel_torque(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((SystemCore_Common_SteeringWheel*)data)->torque = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_Common_SteeringWheel_functionAppliedTorque(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_01, INT32_MIN, INT32_MAX);
   encode_SystemCore_Common_SteeringWheel_Raw_functionAppliedTorque(stream, &value);
}

static bool decode_SystemCore_Common_SteeringWheel_functionAppliedTorque(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((SystemCore_Common_SteeringWheel*)data)->functionAppliedTorque = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_Common_SteeringWheel_totalAppliedTorque(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_01, INT32_MIN, INT32_MAX);
   encode_SystemCore_Common_SteeringWheel_Raw_totalAppliedTorque(stream, &value);
}

static bool decode_SystemCore_Common_SteeringWheel_totalAppliedTorque(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((SystemCore_Common_SteeringWheel*)data)->totalAppliedTorque = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_Common_VehicleInput_Raw_acceleratorPedal(qpb_ostream_t *const stream, const SystemCore_Common_AcceleratorPedal_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_Common_AcceleratorPedal_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_Common_VehicleInput_Raw_acceleratorPedal(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_Common_AcceleratorPedal_Raw(&substream, &((SystemCore_Common_VehicleInput_Raw*)data)->acceleratorPedal);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_Common_VehicleInput_Raw_brakeSystem(qpb_ostream_t *const stream, const SystemCore_Common_BrakeSystem_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_Common_BrakeSystem_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_Common_VehicleInput_Raw_brakeSystem(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_Common_BrakeSystem_Raw(&substream, &((SystemCore_Common_VehicleInput_Raw*)data)->brakeSystem);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_Common_VehicleInput_Raw_steeringWheel(qpb_ostream_t *const stream, const SystemCore_Common_SteeringWheel_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_Common_SteeringWheel_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_Common_VehicleInput_Raw_steeringWheel(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_Common_SteeringWheel_Raw(&substream, &((SystemCore_Common_VehicleInput_Raw*)data)->steeringWheel);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_Common_VehicleInput_Raw_frontWheel(qpb_ostream_t *const stream, const SystemCore_Common_FrontWheel_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_Common_FrontWheel_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_Common_VehicleInput_Raw_frontWheel(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_Common_FrontWheel_Raw(&substream, &((SystemCore_Common_VehicleInput_Raw*)data)->frontWheel);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_Common_VehicleInput_Raw_turnIndicator(qpb_ostream_t *const stream, const SystemCore_Common_TurnIndicatorState *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Common_VehicleInput_Raw_turnIndicator(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Common_VehicleInput_Raw*)data)->turnIndicator, qpb_membersize(SystemCore_Common_VehicleInput_Raw, turnIndicator));
}

static inline void encode_SystemCore_Common_VehicleInput_Raw_driverDoorOpen(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Common_VehicleInput_Raw_driverDoorOpen(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Common_VehicleInput_Raw*)data)->driverDoorOpen, sizeof(bool));
}

static inline void encode_SystemCore_Common_VehicleInput_Raw_safePositionsFrontSeats(qpb_ostream_t *const stream, const SystemCore_Common_SafePositionsFrontSeats_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 58;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_Common_SafePositionsFrontSeats_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_Common_VehicleInput_Raw_safePositionsFrontSeats(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_Common_SafePositionsFrontSeats_Raw(&substream, &((SystemCore_Common_VehicleInput_Raw*)data)->safePositionsFrontSeats);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_Common_VehicleInput_acceleratorPedal(qpb_ostream_t *const stream, const SystemCore_Common_AcceleratorPedal *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_Common_AcceleratorPedal(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_Common_VehicleInput_acceleratorPedal(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_Common_AcceleratorPedal(&substream, &((SystemCore_Common_VehicleInput*)data)->acceleratorPedal);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_Common_VehicleInput_brakeSystem(qpb_ostream_t *const stream, const SystemCore_Common_BrakeSystem *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_Common_BrakeSystem(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_Common_VehicleInput_brakeSystem(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_Common_BrakeSystem(&substream, &((SystemCore_Common_VehicleInput*)data)->brakeSystem);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_Common_VehicleInput_steeringWheel(qpb_ostream_t *const stream, const SystemCore_Common_SteeringWheel *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_Common_SteeringWheel(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_Common_VehicleInput_steeringWheel(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_Common_SteeringWheel(&substream, &((SystemCore_Common_VehicleInput*)data)->steeringWheel);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_Common_VehicleInput_frontWheel(qpb_ostream_t *const stream, const SystemCore_Common_FrontWheel *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_Common_FrontWheel(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_Common_VehicleInput_frontWheel(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_Common_FrontWheel(&substream, &((SystemCore_Common_VehicleInput*)data)->frontWheel);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_Common_VehicleInput_turnIndicator(qpb_ostream_t *const stream, const SystemCore_Common_TurnIndicatorState *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Common_VehicleInput_turnIndicator(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Common_VehicleInput*)data)->turnIndicator, qpb_membersize(SystemCore_Common_VehicleInput, turnIndicator));
}

static inline void encode_SystemCore_Common_VehicleInput_driverDoorOpen(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Common_VehicleInput_driverDoorOpen(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Common_VehicleInput*)data)->driverDoorOpen, sizeof(bool));
}

static inline void encode_SystemCore_Common_VehicleInput_safePositionsFrontSeats(qpb_ostream_t *const stream, const SystemCore_Common_SafePositionsFrontSeats *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 58;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_Common_SafePositionsFrontSeats(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_Common_VehicleInput_safePositionsFrontSeats(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_Common_SafePositionsFrontSeats(&substream, &((SystemCore_Common_VehicleInput*)data)->safePositionsFrontSeats);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

/* Encoding / decoding functions */
bool encode_SystemCore_Common_AcceleratorPedal_Raw(qpb_ostream_t *const stream, const SystemCore_Common_AcceleratorPedal_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Common_AcceleratorPedal_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Common_AcceleratorPedal_Raw_valid(stream, &data->valid);
   encode_SystemCore_Common_AcceleratorPedal_Raw_pressedAmount(stream, &data->pressedAmount);
   return true;
}

bool decode_SystemCore_Common_AcceleratorPedal_Raw(qpb_istream_t *const stream, SystemCore_Common_AcceleratorPedal_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Common_AcceleratorPedal_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Common_AcceleratorPedal_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_Common_BrakeSystem_Raw(qpb_ostream_t *const stream, const SystemCore_Common_BrakeSystem_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Common_BrakeSystem_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Common_BrakeSystem_Raw_valid(stream, &data->valid);
   encode_SystemCore_Common_BrakeSystem_Raw_brakePedalState(stream, &data->brakePedalState);
   encode_SystemCore_Common_BrakeSystem_Raw_decelerationRequest(stream, &data->decelerationRequest);
   return true;
}

bool decode_SystemCore_Common_BrakeSystem_Raw(qpb_istream_t *const stream, SystemCore_Common_BrakeSystem_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Common_BrakeSystem_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Common_BrakeSystem_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_Common_BrakeSystem(qpb_ostream_t *const stream, const SystemCore_Common_BrakeSystem *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Common_BrakeSystem_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Common_BrakeSystem_Raw_valid(stream, &data->valid);
   encode_SystemCore_Common_BrakeSystem_Raw_brakePedalState(stream, &data->brakePedalState);
   encode_SystemCore_Common_BrakeSystem_decelerationRequest(stream, &data->decelerationRequest);
   return true;
}

bool decode_SystemCore_Common_BrakeSystem(qpb_istream_t *const stream, SystemCore_Common_BrakeSystem *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Common_BrakeSystem_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Common_BrakeSystem_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_Common_FrontWheel_Raw(qpb_ostream_t *const stream, const SystemCore_Common_FrontWheel_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Common_FrontWheel_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Common_FrontWheel_Raw_valid(stream, &data->valid);
   encode_SystemCore_Common_FrontWheel_Raw_angle(stream, &data->angle);
   encode_SystemCore_Common_FrontWheel_Raw_angleRate(stream, &data->angleRate);
   return true;
}

bool decode_SystemCore_Common_FrontWheel_Raw(qpb_istream_t *const stream, SystemCore_Common_FrontWheel_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Common_FrontWheel_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Common_FrontWheel_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_Common_FrontWheel(qpb_ostream_t *const stream, const SystemCore_Common_FrontWheel *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Common_FrontWheel_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Common_FrontWheel_Raw_valid(stream, &data->valid);
   encode_SystemCore_Common_FrontWheel_angle(stream, &data->angle);
   encode_SystemCore_Common_FrontWheel_angleRate(stream, &data->angleRate);
   return true;
}

bool decode_SystemCore_Common_FrontWheel(qpb_istream_t *const stream, SystemCore_Common_FrontWheel *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Common_FrontWheel_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Common_FrontWheel_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_Common_SafePositionsFrontSeats_Raw(qpb_ostream_t *const stream, const SystemCore_Common_SafePositionsFrontSeats_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Common_SafePositionsFrontSeats_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Common_SafePositionsFrontSeats_Raw_left(stream, &data->left);
   encode_SystemCore_Common_SafePositionsFrontSeats_Raw_right(stream, &data->right);
   return true;
}

bool decode_SystemCore_Common_SafePositionsFrontSeats_Raw(qpb_istream_t *const stream, SystemCore_Common_SafePositionsFrontSeats_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Common_SafePositionsFrontSeats_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Common_SafePositionsFrontSeats_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_Common_SteeringWheel_Raw(qpb_ostream_t *const stream, const SystemCore_Common_SteeringWheel_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Common_SteeringWheel_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Common_SteeringWheel_Raw_valid(stream, &data->valid);
   encode_SystemCore_Common_SteeringWheel_Raw_limited(stream, &data->limited);
   encode_SystemCore_Common_SteeringWheel_Raw_torque(stream, &data->torque);
   encode_SystemCore_Common_SteeringWheel_Raw_functionAppliedTorque(stream, &data->functionAppliedTorque);
   encode_SystemCore_Common_SteeringWheel_Raw_totalAppliedTorque(stream, &data->totalAppliedTorque);
   return true;
}

bool decode_SystemCore_Common_SteeringWheel_Raw(qpb_istream_t *const stream, SystemCore_Common_SteeringWheel_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Common_SteeringWheel_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Common_SteeringWheel_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_Common_SteeringWheel(qpb_ostream_t *const stream, const SystemCore_Common_SteeringWheel *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Common_SteeringWheel_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Common_SteeringWheel_Raw_valid(stream, &data->valid);
   encode_SystemCore_Common_SteeringWheel_Raw_limited(stream, &data->limited);
   encode_SystemCore_Common_SteeringWheel_torque(stream, &data->torque);
   encode_SystemCore_Common_SteeringWheel_functionAppliedTorque(stream, &data->functionAppliedTorque);
   encode_SystemCore_Common_SteeringWheel_totalAppliedTorque(stream, &data->totalAppliedTorque);
   return true;
}

bool decode_SystemCore_Common_SteeringWheel(qpb_istream_t *const stream, SystemCore_Common_SteeringWheel *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Common_SteeringWheel_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Common_SteeringWheel_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_Common_VehicleInput_Raw(qpb_ostream_t *const stream, const SystemCore_Common_VehicleInput_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Common_VehicleInput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Common_VehicleInput_Raw_acceleratorPedal(stream, &data->acceleratorPedal);
   encode_SystemCore_Common_VehicleInput_Raw_brakeSystem(stream, &data->brakeSystem);
   encode_SystemCore_Common_VehicleInput_Raw_steeringWheel(stream, &data->steeringWheel);
   encode_SystemCore_Common_VehicleInput_Raw_frontWheel(stream, &data->frontWheel);
   encode_SystemCore_Common_VehicleInput_Raw_turnIndicator(stream, &data->turnIndicator);
   encode_SystemCore_Common_VehicleInput_Raw_driverDoorOpen(stream, &data->driverDoorOpen);
   encode_SystemCore_Common_VehicleInput_Raw_safePositionsFrontSeats(stream, &data->safePositionsFrontSeats);
   return true;
}

bool decode_SystemCore_Common_VehicleInput_Raw(qpb_istream_t *const stream, SystemCore_Common_VehicleInput_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Common_VehicleInput_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Common_VehicleInput_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_Common_VehicleInput(qpb_ostream_t *const stream, const SystemCore_Common_VehicleInput *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Common_VehicleInput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Common_VehicleInput_acceleratorPedal(stream, &data->acceleratorPedal);
   encode_SystemCore_Common_VehicleInput_brakeSystem(stream, &data->brakeSystem);
   encode_SystemCore_Common_VehicleInput_steeringWheel(stream, &data->steeringWheel);
   encode_SystemCore_Common_VehicleInput_frontWheel(stream, &data->frontWheel);
   encode_SystemCore_Common_VehicleInput_Raw_turnIndicator(stream, &data->turnIndicator);
   encode_SystemCore_Common_VehicleInput_Raw_driverDoorOpen(stream, &data->driverDoorOpen);
   encode_SystemCore_Common_VehicleInput_safePositionsFrontSeats(stream, &data->safePositionsFrontSeats);
   return true;
}

bool decode_SystemCore_Common_VehicleInput(qpb_istream_t *const stream, SystemCore_Common_VehicleInput *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Common_VehicleInput_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Common_VehicleInput_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

