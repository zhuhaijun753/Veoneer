/* Automatically generated qpb constant definitions */
/* Generated by Quick Protocol Buffers - 2 */

#include "SystemCore/CollisionAvoidance/SettingsInput.qpb.h"
#include "Tools/QuickProtobuf/qpb_decode.h"
#include "Tools/QuickProtobuf/qpb_encode.h"
#include "Tools/CSupport/ConversionSupport.h"

#if QPB_PROTO_HEADER_VERSION != 2
#error Regenerate this file with the current version of qpb generator.
#endif

#define F_0_01               0.01f
#define F_0_05               0.05f
#define F_0_1                0.1f

static inline void encode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_timeWithHighTtc(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_timeWithHighTtc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_standstillTime(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_standstillTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_AebDeactivationParameters_timeWithHighTtc(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_AebDeactivationParameters_timeWithHighTtc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_AebDeactivationParameters_standstillTime(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_AebDeactivationParameters_standstillTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw_activateAebOncoming(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw_activateAebOncoming(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw_activateAebCrossing(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw_activateAebCrossing(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_beltActivationDelay(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_beltActivationDelay(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_postEventMessageActivationDelay(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_postEventMessageActivationDelay(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_standstillRequestHoldTime(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_standstillRequestHoldTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_AebTimingParameters_beltActivationDelay(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_AebTimingParameters_beltActivationDelay(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_AebTimingParameters_postEventMessageActivationDelay(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_AebTimingParameters_postEventMessageActivationDelay(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_AebTimingParameters_standstillRequestHoldTime(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_AebTimingParameters_standstillRequestHoldTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateActuatingFunctions(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateActuatingFunctions(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateSteeringThreat(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateSteeringThreat(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateVruObjects(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateVruObjects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_EmaParameters_Raw_lateralJerkActivationThreshold(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_EmaParameters_Raw_lateralJerkActivationThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_EmaParameters_lateralJerkActivationThreshold(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_EmaParameters_lateralJerkActivationThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaBlisInjectedTargetLeft(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaBlisInjectedTargetLeft(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaBlisInjectedTargetRight(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaBlisInjectedTargetRight(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaFrontObjectsInjectedTargetLeft(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaFrontObjectsInjectedTargetLeft(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaFrontObjectsInjectedTargetRight(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaFrontObjectsInjectedTargetRight(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_lkaEnableStraightTestPath(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_lkaEnableStraightTestPath(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_virtualRoadEdge(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_virtualRoadEdge(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_saturateLateralPositionForCriticalObjects(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_saturateLateralPositionForCriticalObjects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lkaMaxTimeNeeded(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lkaMaxTimeNeeded(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_elkaRoadEdgeMaxTimeNeeded(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_elkaRoadEdgeMaxTimeNeeded(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lkaLaneWidthEnableMargin(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lkaLaneWidthEnableMargin(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssEnableObjectTypeSuppression(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssEnableObjectTypeSuppression(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionSensitivity(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionSensitivity(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionTime(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionTime(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssAccelerationExtrapolationTimeForObjectSuppression(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssAccelerationExtrapolationTimeForObjectSuppression(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionTimeToReachLimit(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionTimeToReachLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionTimeToReachLimit(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionTimeToReachLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionLateralPositionLimit(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionLateralPositionLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionLateralGapLimit(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionLateralGapLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssObjectSuppressionNarrowRoadLimit(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssObjectSuppressionNarrowRoadLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lkaMaxTimeNeeded(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lkaMaxTimeNeeded(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_elkaRoadEdgeMaxTimeNeeded(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_elkaRoadEdgeMaxTimeNeeded(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lkaLaneWidthEnableMargin(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lkaLaneWidthEnableMargin(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssEnableObjectTypeSuppression(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssEnableObjectTypeSuppression(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionSensitivity(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionSensitivity(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionTime(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionTime(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssAccelerationExtrapolationTimeForObjectSuppression(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssAccelerationExtrapolationTimeForObjectSuppression(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionTimeToReachLimit(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionTimeToReachLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionTimeToReachLimit(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionTimeToReachLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionLateralPositionLimit(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionLateralPositionLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionLateralGapLimit(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionLateralGapLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssObjectSuppressionNarrowRoadLimit(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssObjectSuppressionNarrowRoadLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_offset(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_offset(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_correction(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_correction(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_offset(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_offset(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_correction(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_correction(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_brakeDelayEstimate(qpb_ostream_t *const stream, const uint8_t arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_brakeDelayEstimate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_longitudinalMarginWhenAebActive(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_longitudinalMarginWhenAebActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_brakeDelayEstimate(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_brakeDelayEstimate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_longitudinalMarginWhenAebActive(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_longitudinalMarginWhenAebActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_enable(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_enable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_suppress(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssSideStatus *const data);
static bool decode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_suppress(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_abort(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssSideStatus *const data);
static bool decode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_abort(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_values(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_values(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_breakpoints(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_breakpoints(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_values(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_values(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_breakpoints(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_breakpoints(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_values(qpb_ostream_t *const stream, const uint8_t arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_values(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_breakpoints(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_breakpoints(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_values(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_values(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_breakpoints(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_breakpoints(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_StaticDistanceWarningParameters_Raw_enableSdw(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_StaticDistanceWarningParameters_Raw_enableSdw(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_funnelBreakpoints(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_funnelBreakpoints(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_innerFunnelWidths(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_innerFunnelWidths(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_outerFunnelWidths(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_outerFunnelWidths(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_enabledObjectTypes(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_enabledObjectTypes(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_cutInTimeThreshold(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_cutInTimeThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_enableCutIn(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_enableCutIn(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_funnelBreakpoints(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_funnelBreakpoints(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_innerFunnelWidths(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_innerFunnelWidths(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_outerFunnelWidths(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_outerFunnelWidths(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_enabledObjectTypes(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_enabledObjectTypes(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_cutInTimeThreshold(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_cutInTimeThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_enableCutIn(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_enableCutIn(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_values(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_values(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_breakpoints(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_breakpoints(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_values(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_values(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_breakpoints(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_breakpoints(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_offset(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_offset(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_correction(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_correction(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_offset(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_offset(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_correction(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_correction(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_closedLoopEnable(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_closedLoopEnable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_avoidanceDecelerationLag(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_avoidanceDecelerationLag(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_avoidanceDistance(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_avoidanceDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_closedLoopEnable(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_closedLoopEnable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_avoidanceDecelerationLag(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_avoidanceDecelerationLag(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_avoidanceDistance(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_avoidanceDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_light(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_light(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_steeringWheelAngle(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_steeringWheelAngle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_yawRate(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_yawRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_brakePedalPosition(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_brakePedalPosition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_numberOfPedestrians(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_numberOfPedestrians(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_wiperStatus(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_wiperStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_pedestrianSize(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_pedestrianSize(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_light(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_light(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_steeringWheelAngle(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_steeringWheelAngle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_yawRate(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_yawRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_brakePedalPosition(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_brakePedalPosition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_numberOfPedestrians(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_numberOfPedestrians(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_wiperStatus(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_wiperStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_pedestrianSize(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_pedestrianSize(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_lowSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_lowSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_normalSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_normalSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_highSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_highSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_lowSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable *const data);
static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_lowSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_normalSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable *const data);
static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_normalSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_highSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable *const data);
static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_highSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_lowSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_lowSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_normalSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_normalSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_highSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_highSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_lowSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTable *const data);
static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_lowSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_normalSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTable *const data);
static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_normalSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_highSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTable *const data);
static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_highSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw_lowThreatThreshold(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw_lowThreatThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw_highThreatThreshold(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw_highThreatThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_lowThreatThreshold(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdLookupTable *const data);
static bool decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_lowThreatThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_highThreatThreshold(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdLookupTable *const data);
static bool decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_highThreatThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_light(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_light(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_steeringWheelAngle(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_steeringWheelAngle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_yawRate(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_yawRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_brakePedalPosition(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_brakePedalPosition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_numberOfPedestrians(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_numberOfPedestrians(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_wiperStatus(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_wiperStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_pedestrianSize(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_pedestrianSize(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_light(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_light(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_steeringWheelAngle(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_steeringWheelAngle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_yawRate(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_yawRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_brakePedalPosition(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_brakePedalPosition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_numberOfPedestrians(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_numberOfPedestrians(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_wiperStatus(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_wiperStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_pedestrianSize(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_pedestrianSize(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_predictedDeceleration(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_predictedDeceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_reactionTime(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_reactionTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_disableAdjustments(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_disableAdjustments(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionWarning_predictedDeceleration(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionWarning_predictedDeceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionWarning_reactionTime(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionWarning_reactionTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionWarning_disableAdjustments(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionWarning_disableAdjustments(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_negativeAccelerationMaximum(qpb_ostream_t *const stream, const int8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_negativeAccelerationMaximum(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_nominalAccelerationFactor(qpb_ostream_t *const stream, const int8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_nominalAccelerationFactor(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_previousAccelerationRequestFactor(qpb_ostream_t *const stream, const int8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_previousAccelerationRequestFactor(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_previousNominalRequestFactor(qpb_ostream_t *const stream, const int8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_previousNominalRequestFactor(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_threatThreshold(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_threatThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_negativeAccelerationMaximum(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_negativeAccelerationMaximum(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_nominalAccelerationFactor(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_nominalAccelerationFactor(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_previousAccelerationRequestFactor(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_previousAccelerationRequestFactor(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_previousNominalRequestFactor(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_previousNominalRequestFactor(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_threatThreshold(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdTableParameters *const data);
static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_threatThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_min(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_min(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_max(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_max(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_baseline(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_baseline(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_modifications(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginModifications_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_modifications(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_min(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_min(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_max(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_max(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_baseline(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_baseline(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_modifications(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginModifications *const data);
static bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_modifications(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_negativeAccelerationMaximum(qpb_ostream_t *const stream, const int8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_negativeAccelerationMaximum(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_nominalRequestFactor(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_nominalRequestFactor(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_negativeJerkMinimum(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_negativeJerkMinimum(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_threatThreshold(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_threatThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PreBrakeParameters_negativeAccelerationMaximum(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters_negativeAccelerationMaximum(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PreBrakeParameters_nominalRequestFactor(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters_nominalRequestFactor(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PreBrakeParameters_negativeJerkMinimum(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters_negativeJerkMinimum(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_PreBrakeParameters_threatThreshold(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdTableParameters *const data);
static bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters_threatThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_min(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_min(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_max(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_max(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_baseline(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_baseline(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_modifications(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_modifications(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_min(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_min(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_max(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_max(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_baseline(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_baseline(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_modifications(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionModifications *const data);
static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_modifications(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_fullBrake(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_FullBrakeParameters_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_fullBrake(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_preBrake(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PreBrakeParameters_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_preBrake(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebTiming(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_AebTimingParameters_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebTiming(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebDeactivation(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebDeactivation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_ema(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_EmaParameters_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_ema(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_caLongActivation(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_caLongActivation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_longitudinalTaTunable(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_longitudinalTaTunable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebScenarioActivation(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebScenarioActivation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_lssDevelopmentOverrideParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_lssDevelopmentOverrideParameters(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_lssTunableParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LSSTunableParameters_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_lssTunableParameters(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_collisionWarning(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_CollisionWarning_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_collisionWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_fullBrake(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_FullBrakeParameters *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_fullBrake(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_preBrake(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PreBrakeParameters *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_preBrake(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_aebTiming(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_AebTimingParameters *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_aebTiming(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_aebDeactivation(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_AebDeactivationParameters *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_aebDeactivation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_ema(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_EmaParameters *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_ema(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_caLongActivation(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_CaLongActivationParameters *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_caLongActivation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_longitudinalTaTunable(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_longitudinalTaTunable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_aebScenarioActivation(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_AebScenarioActivationParameters *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_aebScenarioActivation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_lssDevelopmentOverrideParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_lssDevelopmentOverrideParameters(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_lssTunableParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LSSTunableParameters *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_lssTunableParameters(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_collisionWarning(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_CollisionWarning *const data);
static bool decode_SystemCore_CollisionAvoidance_TunableParameters_collisionWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw_timeToCollision(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw_timeToCollision(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw_lateralMargin(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw_lateralMargin(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ZoneCalibration_timeToCollision(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable *const data);
static bool decode_SystemCore_CollisionAvoidance_ZoneCalibration_timeToCollision(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_ZoneCalibration_lateralMargin(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginCalibrationTable *const data);
static bool decode_SystemCore_CollisionAvoidance_ZoneCalibration_lateralMargin(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_aebSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_SensitivitySettings *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_aebSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableAeb(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableAeb(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableEma(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableEma(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableOsp(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableOsp(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableCw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableCw(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_tunableParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TunableParameters_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_tunableParameters(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableDbs(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableDbs(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_lka(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_lka(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_ldw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_ldw(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaRoadEdge(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaRoadEdge(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaFrontObjects(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaFrontObjects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaRearObjects(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaRearObjects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_aebSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_SensitivitySettings *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_aebSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableAeb(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableAeb(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableEma(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableEma(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableOsp(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableOsp(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableCw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableCw(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_tunableParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TunableParameters *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_tunableParameters(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableDbs(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableDbs(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_lka(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_lka(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_ldw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_ldw(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaRoadEdge(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaRoadEdge(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaFrontObjects(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaFrontObjects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaRearObjects(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput *const data);
static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaRearObjects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_cib(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_cib(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_prefill(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_prefill(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_fca(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_fca(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_notification(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_notification(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_speedNodes(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_speedNodes(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_cib(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration *const data);
static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_cib(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_prefill(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration *const data);
static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_prefill(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_fca(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration *const data);
static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_fca(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_notification(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration *const data);
static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_notification(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_speedNodes(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_speedNodes(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw_zoneCalibration(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw_zoneCalibration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw_decelerationRequest(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw *const data);
static bool decode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw_decelerationRequest(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_zoneCalibration(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters *const data);
static bool decode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_zoneCalibration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_decelerationRequest(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_VruDecelerationRequestParameters *const data);
static bool decode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_decelerationRequest(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);

#define SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_decoders[SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_timeWithHighTtc },
   { &decode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_standstillTime }
};

#define SystemCore_CollisionAvoidance_AebDeactivationParameters_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_AebDeactivationParameters_decoders[SystemCore_CollisionAvoidance_AebDeactivationParameters_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_AebDeactivationParameters_timeWithHighTtc },
   { &decode_SystemCore_CollisionAvoidance_AebDeactivationParameters_standstillTime }
};

#define SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw_decoders[SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw_activateAebOncoming },
   { &decode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw_activateAebCrossing }
};

#define SystemCore_CollisionAvoidance_AebTimingParameters_Raw_DECODERS_COUNT 4
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_AebTimingParameters_Raw_decoders[SystemCore_CollisionAvoidance_AebTimingParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_beltActivationDelay },
   { &decode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_postEventMessageActivationDelay },
   { &decode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_standstillRequestHoldTime }
};

#define SystemCore_CollisionAvoidance_AebTimingParameters_DECODERS_COUNT 4
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_AebTimingParameters_decoders[SystemCore_CollisionAvoidance_AebTimingParameters_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_AebTimingParameters_beltActivationDelay },
   { &decode_SystemCore_CollisionAvoidance_AebTimingParameters_postEventMessageActivationDelay },
   { &decode_SystemCore_CollisionAvoidance_AebTimingParameters_standstillRequestHoldTime }
};

#define SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_DECODERS_COUNT 4
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_decoders[SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateActuatingFunctions },
   { &decode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateSteeringThreat },
   { &decode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateVruObjects }
};

#define SystemCore_CollisionAvoidance_EmaParameters_Raw_DECODERS_COUNT 2
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_EmaParameters_Raw_decoders[SystemCore_CollisionAvoidance_EmaParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_EmaParameters_Raw_lateralJerkActivationThreshold }
};

#define SystemCore_CollisionAvoidance_EmaParameters_DECODERS_COUNT 2
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_EmaParameters_decoders[SystemCore_CollisionAvoidance_EmaParameters_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_EmaParameters_lateralJerkActivationThreshold }
};

#define SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_DECODERS_COUNT 8
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_decoders[SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaBlisInjectedTargetLeft },
   { &decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaBlisInjectedTargetRight },
   { &decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaFrontObjectsInjectedTargetLeft },
   { &decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaFrontObjectsInjectedTargetRight },
   { &decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_lkaEnableStraightTestPath },
   { &decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_virtualRoadEdge },
   { &decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_saturateLateralPositionForCriticalObjects }
};

#define SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_DECODERS_COUNT 15
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_decoders[SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lkaMaxTimeNeeded },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_elkaRoadEdgeMaxTimeNeeded },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lkaLaneWidthEnableMargin },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssEnableObjectTypeSuppression },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionSensitivity },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionSensitivity },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionTime },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionTime },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssAccelerationExtrapolationTimeForObjectSuppression },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionTimeToReachLimit },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionTimeToReachLimit },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionLateralPositionLimit },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionLateralGapLimit },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssObjectSuppressionNarrowRoadLimit }
};

#define SystemCore_CollisionAvoidance_LSSTunableParameters_DECODERS_COUNT 15
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_LSSTunableParameters_decoders[SystemCore_CollisionAvoidance_LSSTunableParameters_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lkaMaxTimeNeeded },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_elkaRoadEdgeMaxTimeNeeded },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lkaLaneWidthEnableMargin },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssEnableObjectTypeSuppression },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionSensitivity },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionSensitivity },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionTime },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionTime },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssAccelerationExtrapolationTimeForObjectSuppression },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionTimeToReachLimit },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionTimeToReachLimit },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionLateralPositionLimit },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionLateralGapLimit },
   { &decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssObjectSuppressionNarrowRoadLimit }
};

#define SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_decoders[SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_offset },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_correction }
};

#define SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_decoders[SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_offset },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_correction }
};

#define SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_decoders[SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_brakeDelayEstimate },
   { &decode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_longitudinalMarginWhenAebActive }
};

#define SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_decoders[SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_brakeDelayEstimate },
   { &decode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_longitudinalMarginWhenAebActive }
};

#define SystemCore_CollisionAvoidance_LssFeatureInput_Raw_DECODERS_COUNT 4
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_LssFeatureInput_Raw_decoders[SystemCore_CollisionAvoidance_LssFeatureInput_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_enable },
   { &decode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_suppress },
   { &decode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_abort }
};

#define SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_decoders[SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_values },
   { &decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_breakpoints }
};

#define SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_decoders[SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_values },
   { &decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_breakpoints }
};

#define SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_decoders[SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_values },
   { &decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_breakpoints }
};

#define SystemCore_CollisionAvoidance_ReactionTimeLookupTable_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_ReactionTimeLookupTable_decoders[SystemCore_CollisionAvoidance_ReactionTimeLookupTable_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_values },
   { &decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_breakpoints }
};

#define SystemCore_CollisionAvoidance_StaticDistanceWarningParameters_Raw_DECODERS_COUNT 2
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_StaticDistanceWarningParameters_Raw_decoders[SystemCore_CollisionAvoidance_StaticDistanceWarningParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_StaticDistanceWarningParameters_Raw_enableSdw }
};

#define SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_DECODERS_COUNT 7
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_decoders[SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_funnelBreakpoints },
   { &decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_innerFunnelWidths },
   { &decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_outerFunnelWidths },
   { &decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_enabledObjectTypes },
   { &decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_cutInTimeThreshold },
   { &decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_enableCutIn }
};

#define SystemCore_CollisionAvoidance_TargetSelectionParameters_DECODERS_COUNT 7
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_TargetSelectionParameters_decoders[SystemCore_CollisionAvoidance_TargetSelectionParameters_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_funnelBreakpoints },
   { &decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_innerFunnelWidths },
   { &decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_outerFunnelWidths },
   { &decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_enabledObjectTypes },
   { &decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_cutInTimeThreshold },
   { &decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_enableCutIn }
};

#define SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_decoders[SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_values },
   { &decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_breakpoints }
};

#define SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_decoders[SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_values },
   { &decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_breakpoints }
};

#define SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_decoders[SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_offset },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_correction }
};

#define SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_decoders[SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_offset },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_correction }
};

#define SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_DECODERS_COUNT 4
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_decoders[SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_closedLoopEnable },
   { &decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_avoidanceDecelerationLag },
   { &decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_avoidanceDistance }
};

#define SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_DECODERS_COUNT 4
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_decoders[SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_closedLoopEnable },
   { &decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_avoidanceDecelerationLag },
   { &decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_avoidanceDistance }
};

#define SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_DECODERS_COUNT 8
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_decoders[SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_light },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_steeringWheelAngle },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_yawRate },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_brakePedalPosition },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_numberOfPedestrians },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_wiperStatus },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_pedestrianSize }
};

#define SystemCore_CollisionAvoidance_LateralMarginModifications_DECODERS_COUNT 8
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_LateralMarginModifications_decoders[SystemCore_CollisionAvoidance_LateralMarginModifications_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_LateralMarginModifications_light },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginModifications_steeringWheelAngle },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginModifications_yawRate },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginModifications_brakePedalPosition },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginModifications_numberOfPedestrians },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginModifications_wiperStatus },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginModifications_pedestrianSize }
};

#define SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_DECODERS_COUNT 4
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_decoders[SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_lowSensitivity },
   { &decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_normalSensitivity },
   { &decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_highSensitivity }
};

#define SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_DECODERS_COUNT 4
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_decoders[SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_lowSensitivity },
   { &decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_normalSensitivity },
   { &decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_highSensitivity }
};

#define SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_DECODERS_COUNT 4
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_decoders[SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_lowSensitivity },
   { &decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_normalSensitivity },
   { &decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_highSensitivity }
};

#define SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_DECODERS_COUNT 4
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_decoders[SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_lowSensitivity },
   { &decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_normalSensitivity },
   { &decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_highSensitivity }
};

#define SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw_decoders[SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw_lowThreatThreshold },
   { &decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw_highThreatThreshold }
};

#define SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_decoders[SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_lowThreatThreshold },
   { &decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_highThreatThreshold }
};

#define SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_DECODERS_COUNT 8
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_decoders[SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_light },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_steeringWheelAngle },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_yawRate },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_brakePedalPosition },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_numberOfPedestrians },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_wiperStatus },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_pedestrianSize }
};

#define SystemCore_CollisionAvoidance_TimeToCollisionModifications_DECODERS_COUNT 8
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_TimeToCollisionModifications_decoders[SystemCore_CollisionAvoidance_TimeToCollisionModifications_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_light },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_steeringWheelAngle },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_yawRate },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_brakePedalPosition },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_numberOfPedestrians },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_wiperStatus },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_pedestrianSize }
};

#define SystemCore_CollisionAvoidance_CollisionWarning_Raw_DECODERS_COUNT 4
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_CollisionWarning_Raw_decoders[SystemCore_CollisionAvoidance_CollisionWarning_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_predictedDeceleration },
   { &decode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_reactionTime },
   { &decode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_disableAdjustments }
};

#define SystemCore_CollisionAvoidance_CollisionWarning_DECODERS_COUNT 4
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_CollisionWarning_decoders[SystemCore_CollisionAvoidance_CollisionWarning_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_CollisionWarning_predictedDeceleration },
   { &decode_SystemCore_CollisionAvoidance_CollisionWarning_reactionTime },
   { &decode_SystemCore_CollisionAvoidance_CollisionWarning_disableAdjustments }
};

#define SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_DECODERS_COUNT 6
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_decoders[SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_negativeAccelerationMaximum },
   { &decode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_nominalAccelerationFactor },
   { &decode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_previousAccelerationRequestFactor },
   { &decode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_previousNominalRequestFactor },
   { &decode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_threatThreshold }
};

#define SystemCore_CollisionAvoidance_FullBrakeParameters_DECODERS_COUNT 6
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_FullBrakeParameters_decoders[SystemCore_CollisionAvoidance_FullBrakeParameters_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_FullBrakeParameters_negativeAccelerationMaximum },
   { &decode_SystemCore_CollisionAvoidance_FullBrakeParameters_nominalAccelerationFactor },
   { &decode_SystemCore_CollisionAvoidance_FullBrakeParameters_previousAccelerationRequestFactor },
   { &decode_SystemCore_CollisionAvoidance_FullBrakeParameters_previousNominalRequestFactor },
   { &decode_SystemCore_CollisionAvoidance_FullBrakeParameters_threatThreshold }
};

#define SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_decoders[SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_min },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_max },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_baseline },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_modifications }
};

#define SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_DECODERS_COUNT 5
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_decoders[SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_min },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_max },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_baseline },
   { &decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_modifications }
};

#define SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_DECODERS_COUNT 6
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_decoders[SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_negativeAccelerationMaximum },
   { &decode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_nominalRequestFactor },
   { &decode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_negativeJerkMinimum },
   { &qpb_skip_field },
   { &decode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_threatThreshold }
};

#define SystemCore_CollisionAvoidance_PreBrakeParameters_DECODERS_COUNT 6
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_PreBrakeParameters_decoders[SystemCore_CollisionAvoidance_PreBrakeParameters_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_PreBrakeParameters_negativeAccelerationMaximum },
   { &decode_SystemCore_CollisionAvoidance_PreBrakeParameters_nominalRequestFactor },
   { &decode_SystemCore_CollisionAvoidance_PreBrakeParameters_negativeJerkMinimum },
   { &qpb_skip_field },
   { &decode_SystemCore_CollisionAvoidance_PreBrakeParameters_threatThreshold }
};

#define SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_decoders[SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_min },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_max },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_baseline },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_modifications }
};

#define SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_DECODERS_COUNT 5
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_decoders[SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_min },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_max },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_baseline },
   { &decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_modifications }
};

#define SystemCore_CollisionAvoidance_TunableParameters_Raw_DECODERS_COUNT 12
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_TunableParameters_Raw_decoders[SystemCore_CollisionAvoidance_TunableParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_fullBrake },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_preBrake },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebTiming },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebDeactivation },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_ema },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_caLongActivation },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_longitudinalTaTunable },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebScenarioActivation },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_lssDevelopmentOverrideParameters },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_lssTunableParameters },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_collisionWarning }
};

#define SystemCore_CollisionAvoidance_TunableParameters_DECODERS_COUNT 12
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_TunableParameters_decoders[SystemCore_CollisionAvoidance_TunableParameters_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_fullBrake },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_preBrake },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_aebTiming },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_aebDeactivation },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_ema },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_caLongActivation },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_longitudinalTaTunable },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_aebScenarioActivation },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_lssDevelopmentOverrideParameters },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_lssTunableParameters },
   { &decode_SystemCore_CollisionAvoidance_TunableParameters_collisionWarning }
};

#define SystemCore_CollisionAvoidance_ZoneCalibration_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_ZoneCalibration_Raw_decoders[SystemCore_CollisionAvoidance_ZoneCalibration_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw_timeToCollision },
   { &decode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw_lateralMargin }
};

#define SystemCore_CollisionAvoidance_ZoneCalibration_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_ZoneCalibration_decoders[SystemCore_CollisionAvoidance_ZoneCalibration_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_ZoneCalibration_timeToCollision },
   { &decode_SystemCore_CollisionAvoidance_ZoneCalibration_lateralMargin }
};

#define SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_DECODERS_COUNT 13
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_decoders[SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_aebSensitivity },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableAeb },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableEma },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableOsp },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableCw },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_tunableParameters },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableDbs },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_lka },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_ldw },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaRoadEdge },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaFrontObjects },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaRearObjects }
};

#define SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_DECODERS_COUNT 13
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_decoders[SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_aebSensitivity },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableAeb },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableEma },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableOsp },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableCw },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_tunableParameters },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableDbs },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_lka },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_ldw },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaRoadEdge },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaFrontObjects },
   { &decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaRearObjects }
};

#define SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_DECODERS_COUNT 6
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_decoders[SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_cib },
   { &decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_prefill },
   { &decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_fca },
   { &decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_notification },
   { &decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_speedNodes }
};

#define SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_DECODERS_COUNT 6
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_decoders[SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_cib },
   { &decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_prefill },
   { &decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_fca },
   { &decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_notification },
   { &decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_speedNodes }
};

#define SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw_decoders[SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw_zoneCalibration },
   { &decode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw_decelerationRequest }
};

#define SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_decoders[SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_zoneCalibration },
   { &decode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_decelerationRequest }
};

static inline void encode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_timeWithHighTtc(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_timeWithHighTtc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw*)data)->timeWithHighTtc, sizeof(uint16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_standstillTime(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_standstillTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw*)data)->standstillTime, sizeof(uint16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_AebDeactivationParameters_timeWithHighTtc(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_timeWithHighTtc(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_AebDeactivationParameters_timeWithHighTtc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((SystemCore_CollisionAvoidance_AebDeactivationParameters*)data)->timeWithHighTtc = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_AebDeactivationParameters_standstillTime(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_standstillTime(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_AebDeactivationParameters_standstillTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((SystemCore_CollisionAvoidance_AebDeactivationParameters*)data)->standstillTime = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw_activateAebOncoming(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw_activateAebOncoming(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw*)data)->activateAebOncoming, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw_activateAebCrossing(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw_activateAebCrossing(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw*)data)->activateAebCrossing, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_beltActivationDelay(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_beltActivationDelay(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_AebTimingParameters_Raw*)data)->beltActivationDelay, sizeof(uint8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_postEventMessageActivationDelay(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_postEventMessageActivationDelay(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_AebTimingParameters_Raw*)data)->postEventMessageActivationDelay, sizeof(uint8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_standstillRequestHoldTime(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_standstillRequestHoldTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_AebTimingParameters_Raw*)data)->standstillRequestHoldTime, sizeof(uint8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_AebTimingParameters_beltActivationDelay(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_01, 0, UINT8_MAX);
   encode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_beltActivationDelay(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_AebTimingParameters_beltActivationDelay(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((SystemCore_CollisionAvoidance_AebTimingParameters*)data)->beltActivationDelay = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_AebTimingParameters_postEventMessageActivationDelay(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_01, 0, UINT8_MAX);
   encode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_postEventMessageActivationDelay(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_AebTimingParameters_postEventMessageActivationDelay(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((SystemCore_CollisionAvoidance_AebTimingParameters*)data)->postEventMessageActivationDelay = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_AebTimingParameters_standstillRequestHoldTime(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_01, 0, UINT8_MAX);
   encode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_standstillRequestHoldTime(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_AebTimingParameters_standstillRequestHoldTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((SystemCore_CollisionAvoidance_AebTimingParameters*)data)->standstillRequestHoldTime = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateActuatingFunctions(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateActuatingFunctions(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw*)data)->activateActuatingFunctions, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateSteeringThreat(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateSteeringThreat(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw*)data)->activateSteeringThreat, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateVruObjects(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateVruObjects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw*)data)->activateVruObjects, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_EmaParameters_Raw_lateralJerkActivationThreshold(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_EmaParameters_Raw_lateralJerkActivationThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_EmaParameters_Raw*)data)->lateralJerkActivationThreshold, sizeof(uint16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_EmaParameters_lateralJerkActivationThreshold(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_SystemCore_CollisionAvoidance_EmaParameters_Raw_lateralJerkActivationThreshold(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_EmaParameters_lateralJerkActivationThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((SystemCore_CollisionAvoidance_EmaParameters*)data)->lateralJerkActivationThreshold = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaBlisInjectedTargetLeft(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaBlisInjectedTargetLeft(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw*)data)->elkaBlisInjectedTargetLeft, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaBlisInjectedTargetRight(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaBlisInjectedTargetRight(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw*)data)->elkaBlisInjectedTargetRight, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaFrontObjectsInjectedTargetLeft(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaFrontObjectsInjectedTargetLeft(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw*)data)->elkaFrontObjectsInjectedTargetLeft, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaFrontObjectsInjectedTargetRight(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaFrontObjectsInjectedTargetRight(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw*)data)->elkaFrontObjectsInjectedTargetRight, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_lkaEnableStraightTestPath(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_lkaEnableStraightTestPath(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw*)data)->lkaEnableStraightTestPath, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_virtualRoadEdge(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_virtualRoadEdge(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw*)data)->virtualRoadEdge, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_saturateLateralPositionForCriticalObjects(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_saturateLateralPositionForCriticalObjects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw*)data)->saturateLateralPositionForCriticalObjects, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lkaMaxTimeNeeded(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lkaMaxTimeNeeded(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSTunableParameters_Raw*)data)->lkaMaxTimeNeeded, sizeof(uint16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_elkaRoadEdgeMaxTimeNeeded(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_elkaRoadEdgeMaxTimeNeeded(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSTunableParameters_Raw*)data)->elkaRoadEdgeMaxTimeNeeded, sizeof(uint16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lkaLaneWidthEnableMargin(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lkaLaneWidthEnableMargin(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSTunableParameters_Raw*)data)->lkaLaneWidthEnableMargin, sizeof(uint16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssEnableObjectTypeSuppression(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssEnableObjectTypeSuppression(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSTunableParameters_Raw*)data)->lssEnableObjectTypeSuppression, sizeof(uint8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionSensitivity(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSTunableParameters_Raw*)data)->lssOncomingObjectSuppressionSensitivity, sizeof(uint8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionSensitivity(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSTunableParameters_Raw*)data)->lssOvertakeObjectSuppressionSensitivity, sizeof(uint8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionTime(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSTunableParameters_Raw*)data)->lssOncomingObjectSuppressionTime, sizeof(uint16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionTime(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSTunableParameters_Raw*)data)->lssOvertakeObjectSuppressionTime, sizeof(uint16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssAccelerationExtrapolationTimeForObjectSuppression(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 72;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssAccelerationExtrapolationTimeForObjectSuppression(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSTunableParameters_Raw*)data)->lssAccelerationExtrapolationTimeForObjectSuppression, sizeof(uint16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionTimeToReachLimit(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 80;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionTimeToReachLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSTunableParameters_Raw*)data)->lssOncomingObjectSuppressionTimeToReachLimit, sizeof(uint16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionTimeToReachLimit(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 88;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionTimeToReachLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSTunableParameters_Raw*)data)->lssOvertakeObjectSuppressionTimeToReachLimit, sizeof(uint16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionLateralPositionLimit(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 96;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionLateralPositionLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSTunableParameters_Raw*)data)->lssOvertakeObjectSuppressionLateralPositionLimit, sizeof(uint16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionLateralGapLimit(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 104;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionLateralGapLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSTunableParameters_Raw*)data)->lssOncomingObjectSuppressionLateralGapLimit, sizeof(uint16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssObjectSuppressionNarrowRoadLimit(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 112;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssObjectSuppressionNarrowRoadLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSTunableParameters_Raw*)data)->lssObjectSuppressionNarrowRoadLimit, sizeof(uint16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lkaMaxTimeNeeded(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lkaMaxTimeNeeded(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lkaMaxTimeNeeded(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((SystemCore_CollisionAvoidance_LSSTunableParameters*)data)->lkaMaxTimeNeeded = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_elkaRoadEdgeMaxTimeNeeded(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_elkaRoadEdgeMaxTimeNeeded(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_elkaRoadEdgeMaxTimeNeeded(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((SystemCore_CollisionAvoidance_LSSTunableParameters*)data)->elkaRoadEdgeMaxTimeNeeded = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lkaLaneWidthEnableMargin(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lkaLaneWidthEnableMargin(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lkaLaneWidthEnableMargin(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((SystemCore_CollisionAvoidance_LSSTunableParameters*)data)->lkaLaneWidthEnableMargin = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssEnableObjectTypeSuppression(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssEnableObjectTypeSuppression(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSTunableParameters*)data)->lssEnableObjectTypeSuppression, sizeof(uint8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionSensitivity(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSTunableParameters*)data)->lssOncomingObjectSuppressionSensitivity, sizeof(uint8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionSensitivity(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LSSTunableParameters*)data)->lssOvertakeObjectSuppressionSensitivity, sizeof(uint8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionTime(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionTime(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((SystemCore_CollisionAvoidance_LSSTunableParameters*)data)->lssOncomingObjectSuppressionTime = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionTime(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionTime(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((SystemCore_CollisionAvoidance_LSSTunableParameters*)data)->lssOvertakeObjectSuppressionTime = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssAccelerationExtrapolationTimeForObjectSuppression(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssAccelerationExtrapolationTimeForObjectSuppression(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssAccelerationExtrapolationTimeForObjectSuppression(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((SystemCore_CollisionAvoidance_LSSTunableParameters*)data)->lssAccelerationExtrapolationTimeForObjectSuppression = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionTimeToReachLimit(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionTimeToReachLimit(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionTimeToReachLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((SystemCore_CollisionAvoidance_LSSTunableParameters*)data)->lssOncomingObjectSuppressionTimeToReachLimit = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionTimeToReachLimit(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionTimeToReachLimit(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionTimeToReachLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((SystemCore_CollisionAvoidance_LSSTunableParameters*)data)->lssOvertakeObjectSuppressionTimeToReachLimit = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionLateralPositionLimit(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionLateralPositionLimit(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionLateralPositionLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((SystemCore_CollisionAvoidance_LSSTunableParameters*)data)->lssOvertakeObjectSuppressionLateralPositionLimit = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionLateralGapLimit(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionLateralGapLimit(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionLateralGapLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((SystemCore_CollisionAvoidance_LSSTunableParameters*)data)->lssOncomingObjectSuppressionLateralGapLimit = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssObjectSuppressionNarrowRoadLimit(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssObjectSuppressionNarrowRoadLimit(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssObjectSuppressionNarrowRoadLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((SystemCore_CollisionAvoidance_LSSTunableParameters*)data)->lssObjectSuppressionNarrowRoadLimit = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_offset(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_offset(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw*)data)->offset, sizeof(int16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_correction(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_correction(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw*)data)->correction, sizeof(int16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_offset(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_offset(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_offset(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection*)data)->offset = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_correction(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_correction(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_correction(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection*)data)->correction = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_brakeDelayEstimate(qpb_ostream_t *const stream, const uint8_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 10;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_brakeDelayEstimate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw*)data)->brakeDelayEstimate_count + 1 > 10)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw*)data)->brakeDelayEstimate[((SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw*)data)->brakeDelayEstimate_count++], sizeof(uint8_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw*)data)->brakeDelayEstimate_count + 1) > 10)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw*)data)->brakeDelayEstimate[((SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw*)data)->brakeDelayEstimate_count++], sizeof(uint8_t));
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_longitudinalMarginWhenAebActive(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_longitudinalMarginWhenAebActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw*)data)->longitudinalMarginWhenAebActive, sizeof(uint8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_brakeDelayEstimate(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   uint8_t values[10];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (uint8_t)convertToUint32(arrayData[i], F_0_01, 0, UINT8_MAX);
   }
   encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_brakeDelayEstimate(stream, values, arraySize);
}

static bool decode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_brakeDelayEstimate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters*)data)->brakeDelayEstimate_count + 1 > 10)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         uint8_t value;
         result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
         ((SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters*)data)->brakeDelayEstimate[((SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters*)data)->brakeDelayEstimate_count++] = value * F_0_01;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters*)data)->brakeDelayEstimate_count + 1) > 10)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      uint8_t value;
      result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
      ((SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters*)data)->brakeDelayEstimate[((SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters*)data)->brakeDelayEstimate_count++] = value * F_0_01;
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_longitudinalMarginWhenAebActive(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_01, 0, UINT8_MAX);
   encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_longitudinalMarginWhenAebActive(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_longitudinalMarginWhenAebActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters*)data)->longitudinalMarginWhenAebActive = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_enable(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_enable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_LssFeatureInput_Raw*)data)->enable, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_suppress(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssSideStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_suppress(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_LssFeatureInput_Raw*)data)->suppress, qpb_membersize(SystemCore_CollisionAvoidance_LssFeatureInput_Raw, suppress));
}

static inline void encode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_abort(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssSideStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_abort(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_LssFeatureInput_Raw*)data)->abort, qpb_membersize(SystemCore_CollisionAvoidance_LssFeatureInput_Raw, abort));
}

static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_values(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 10;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_values(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw*)data)->values_count + 1 > 4)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw*)data)->values[((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw*)data)->values_count++], sizeof(int8_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw*)data)->values_count + 1) > 4)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw*)data)->values[((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw*)data)->values_count++], sizeof(int8_t));
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_breakpoints(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 18;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_breakpoints(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw*)data)->breakpoints_count + 1 > 4)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw*)data)->breakpoints[((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw*)data)->breakpoints_count++], sizeof(uint16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw*)data)->breakpoints_count + 1) > 4)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw*)data)->breakpoints[((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw*)data)->breakpoints_count++], sizeof(uint16_t));
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_values(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   int8_t values[4];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (int8_t)convertToInt32(arrayData[i], F_0_1, INT8_MIN, INT8_MAX);
   }
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_values(stream, values, arraySize);
}

static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_values(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable*)data)->values_count + 1 > 4)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         int8_t value;
         result = qpb_decode_svarint(stream, (void*)&value, sizeof(int8_t));
         ((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable*)data)->values[((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable*)data)->values_count++] = value * F_0_1;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable*)data)->values_count + 1) > 4)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      int8_t value;
      result = qpb_decode_svarint(stream, (void*)&value, sizeof(int8_t));
      ((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable*)data)->values[((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable*)data)->values_count++] = value * F_0_1;
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_breakpoints(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   uint16_t values[4];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (uint16_t)convertToUint32(arrayData[i], F_0_1, 0, UINT16_MAX);
   }
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_breakpoints(stream, values, arraySize);
}

static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_breakpoints(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable*)data)->breakpoints_count + 1 > 4)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         uint16_t value;
         result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
         ((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable*)data)->breakpoints[((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable*)data)->breakpoints_count++] = value * F_0_1;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable*)data)->breakpoints_count + 1) > 4)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      uint16_t value;
      result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
      ((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable*)data)->breakpoints[((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable*)data)->breakpoints_count++] = value * F_0_1;
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_values(qpb_ostream_t *const stream, const uint8_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 10;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_values(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw*)data)->values_count + 1 > 4)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw*)data)->values[((SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw*)data)->values_count++], sizeof(uint8_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw*)data)->values_count + 1) > 4)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw*)data)->values[((SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw*)data)->values_count++], sizeof(uint8_t));
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_breakpoints(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 18;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_breakpoints(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw*)data)->breakpoints_count + 1 > 4)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw*)data)->breakpoints[((SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw*)data)->breakpoints_count++], sizeof(uint16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw*)data)->breakpoints_count + 1) > 4)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw*)data)->breakpoints[((SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw*)data)->breakpoints_count++], sizeof(uint16_t));
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_values(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   uint8_t values[4];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (uint8_t)convertToUint32(arrayData[i], F_0_01, 0, UINT8_MAX);
   }
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_values(stream, values, arraySize);
}

static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_values(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_ReactionTimeLookupTable*)data)->values_count + 1 > 4)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         uint8_t value;
         result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
         ((SystemCore_CollisionAvoidance_ReactionTimeLookupTable*)data)->values[((SystemCore_CollisionAvoidance_ReactionTimeLookupTable*)data)->values_count++] = value * F_0_01;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_ReactionTimeLookupTable*)data)->values_count + 1) > 4)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      uint8_t value;
      result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
      ((SystemCore_CollisionAvoidance_ReactionTimeLookupTable*)data)->values[((SystemCore_CollisionAvoidance_ReactionTimeLookupTable*)data)->values_count++] = value * F_0_01;
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_breakpoints(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   uint16_t values[4];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (uint16_t)convertToUint32(arrayData[i], F_0_1, 0, UINT16_MAX);
   }
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_breakpoints(stream, values, arraySize);
}

static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_breakpoints(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_ReactionTimeLookupTable*)data)->breakpoints_count + 1 > 4)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         uint16_t value;
         result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
         ((SystemCore_CollisionAvoidance_ReactionTimeLookupTable*)data)->breakpoints[((SystemCore_CollisionAvoidance_ReactionTimeLookupTable*)data)->breakpoints_count++] = value * F_0_1;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_ReactionTimeLookupTable*)data)->breakpoints_count + 1) > 4)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      uint16_t value;
      result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
      ((SystemCore_CollisionAvoidance_ReactionTimeLookupTable*)data)->breakpoints[((SystemCore_CollisionAvoidance_ReactionTimeLookupTable*)data)->breakpoints_count++] = value * F_0_1;
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_StaticDistanceWarningParameters_Raw_enableSdw(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_StaticDistanceWarningParameters_Raw_enableSdw(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_StaticDistanceWarningParameters_Raw*)data)->enableSdw, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_funnelBreakpoints(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 10;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_funnelBreakpoints(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->funnelBreakpoints_count + 1 > 10)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->funnelBreakpoints[((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->funnelBreakpoints_count++], sizeof(uint16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->funnelBreakpoints_count + 1) > 10)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->funnelBreakpoints[((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->funnelBreakpoints_count++], sizeof(uint16_t));
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_innerFunnelWidths(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 18;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_innerFunnelWidths(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->innerFunnelWidths_count + 1 > 10)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->innerFunnelWidths[((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->innerFunnelWidths_count++], sizeof(uint16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->innerFunnelWidths_count + 1) > 10)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->innerFunnelWidths[((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->innerFunnelWidths_count++], sizeof(uint16_t));
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_outerFunnelWidths(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 26;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_outerFunnelWidths(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->outerFunnelWidths_count + 1 > 10)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->outerFunnelWidths[((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->outerFunnelWidths_count++], sizeof(uint16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->outerFunnelWidths_count + 1) > 10)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->outerFunnelWidths[((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->outerFunnelWidths_count++], sizeof(uint16_t));
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_enabledObjectTypes(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_enabledObjectTypes(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->enabledObjectTypes, sizeof(uint8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_cutInTimeThreshold(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_cutInTimeThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->cutInTimeThreshold, sizeof(uint8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_enableCutIn(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_enableCutIn(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw*)data)->enableCutIn, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_funnelBreakpoints(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   uint16_t values[10];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (uint16_t)convertToUint32(arrayData[i], F_0_01, 0, UINT16_MAX);
   }
   encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_funnelBreakpoints(stream, values, arraySize);
}

static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_funnelBreakpoints(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->funnelBreakpoints_count + 1 > 10)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         uint16_t value;
         result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
         ((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->funnelBreakpoints[((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->funnelBreakpoints_count++] = value * F_0_01;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->funnelBreakpoints_count + 1) > 10)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      uint16_t value;
      result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
      ((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->funnelBreakpoints[((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->funnelBreakpoints_count++] = value * F_0_01;
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_innerFunnelWidths(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   uint16_t values[10];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (uint16_t)convertToUint32(arrayData[i], F_0_01, 0, UINT16_MAX);
   }
   encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_innerFunnelWidths(stream, values, arraySize);
}

static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_innerFunnelWidths(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->innerFunnelWidths_count + 1 > 10)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         uint16_t value;
         result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
         ((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->innerFunnelWidths[((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->innerFunnelWidths_count++] = value * F_0_01;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->innerFunnelWidths_count + 1) > 10)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      uint16_t value;
      result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
      ((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->innerFunnelWidths[((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->innerFunnelWidths_count++] = value * F_0_01;
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_outerFunnelWidths(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   uint16_t values[10];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (uint16_t)convertToUint32(arrayData[i], F_0_01, 0, UINT16_MAX);
   }
   encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_outerFunnelWidths(stream, values, arraySize);
}

static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_outerFunnelWidths(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->outerFunnelWidths_count + 1 > 10)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         uint16_t value;
         result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
         ((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->outerFunnelWidths[((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->outerFunnelWidths_count++] = value * F_0_01;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->outerFunnelWidths_count + 1) > 10)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      uint16_t value;
      result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
      ((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->outerFunnelWidths[((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->outerFunnelWidths_count++] = value * F_0_01;
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_enabledObjectTypes(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_enabledObjectTypes(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->enabledObjectTypes, sizeof(uint8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_cutInTimeThreshold(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_05, 0, UINT8_MAX);
   encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_cutInTimeThreshold(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_cutInTimeThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->cutInTimeThreshold = value * F_0_05;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_enableCutIn(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_enableCutIn(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_TargetSelectionParameters*)data)->enableCutIn, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_values(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 10;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_values(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw*)data)->values_count + 1 > 10)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw*)data)->values[((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw*)data)->values_count++], sizeof(int16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw*)data)->values_count + 1) > 10)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw*)data)->values[((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw*)data)->values_count++], sizeof(int16_t));
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_breakpoints(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 18;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_breakpoints(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw*)data)->breakpoints_count + 1 > 10)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw*)data)->breakpoints[((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw*)data)->breakpoints_count++], sizeof(uint16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw*)data)->breakpoints_count + 1) > 10)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw*)data)->breakpoints[((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw*)data)->breakpoints_count++], sizeof(uint16_t));
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_values(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   int16_t values[10];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (int16_t)convertToInt32(arrayData[i], F_0_1, INT16_MIN, INT16_MAX);
   }
   encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_values(stream, values, arraySize);
}

static bool decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_values(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable*)data)->values_count + 1 > 10)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         int16_t value;
         result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
         ((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable*)data)->values[((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable*)data)->values_count++] = value * F_0_1;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable*)data)->values_count + 1) > 10)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      int16_t value;
      result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
      ((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable*)data)->values[((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable*)data)->values_count++] = value * F_0_1;
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_breakpoints(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   uint16_t values[10];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (uint16_t)convertToUint32(arrayData[i], F_0_1, 0, UINT16_MAX);
   }
   encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_breakpoints(stream, values, arraySize);
}

static bool decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_breakpoints(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable*)data)->breakpoints_count + 1 > 10)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         uint16_t value;
         result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
         ((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable*)data)->breakpoints[((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable*)data)->breakpoints_count++] = value * F_0_1;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable*)data)->breakpoints_count + 1) > 10)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      uint16_t value;
      result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
      ((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable*)data)->breakpoints[((SystemCore_CollisionAvoidance_ThreatThresholdLookupTable*)data)->breakpoints_count++] = value * F_0_1;
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_offset(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_offset(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw*)data)->offset, sizeof(int16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_correction(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_correction(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw*)data)->correction, sizeof(int16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_offset(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_1, INT16_MIN, INT16_MAX);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_offset(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_offset(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection*)data)->offset = value * F_0_1;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_correction(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_1, INT16_MIN, INT16_MAX);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_correction(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_correction(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection*)data)->correction = value * F_0_1;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_closedLoopEnable(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_closedLoopEnable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw*)data)->closedLoopEnable, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_avoidanceDecelerationLag(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_avoidanceDecelerationLag(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw*)data)->avoidanceDecelerationLag, sizeof(uint8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_avoidanceDistance(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_avoidanceDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw*)data)->avoidanceDistance, sizeof(uint8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_closedLoopEnable(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_closedLoopEnable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_VruDecelerationRequestParameters*)data)->closedLoopEnable, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_avoidanceDecelerationLag(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_01, 0, UINT8_MAX);
   encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_avoidanceDecelerationLag(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_avoidanceDecelerationLag(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((SystemCore_CollisionAvoidance_VruDecelerationRequestParameters*)data)->avoidanceDecelerationLag = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_avoidanceDistance(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_1, 0, UINT8_MAX);
   encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_avoidanceDistance(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_avoidanceDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((SystemCore_CollisionAvoidance_VruDecelerationRequestParameters*)data)->avoidanceDistance = value * F_0_1;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_light(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 10;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_light(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->light_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw(&substream, &((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->light[((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->light_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_steeringWheelAngle(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 18;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_steeringWheelAngle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->steeringWheelAngle_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw(&substream, &((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->steeringWheelAngle[((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->steeringWheelAngle_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_yawRate(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 26;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_yawRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->yawRate_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw(&substream, &((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->yawRate[((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->yawRate_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_brakePedalPosition(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 34;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_brakePedalPosition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->brakePedalPosition_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw(&substream, &((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->brakePedalPosition[((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->brakePedalPosition_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_numberOfPedestrians(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 42;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_numberOfPedestrians(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->numberOfPedestrians_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw(&substream, &((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->numberOfPedestrians[((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->numberOfPedestrians_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_wiperStatus(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 50;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_wiperStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->wiperStatus_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw(&substream, &((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->wiperStatus[((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->wiperStatus_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_pedestrianSize(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 58;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_pedestrianSize(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->pedestrianSize_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw(&substream, &((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->pedestrianSize[((SystemCore_CollisionAvoidance_LateralMarginModifications_Raw*)data)->pedestrianSize_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_light(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 10;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_light(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->light_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection(&substream, &((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->light[((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->light_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_steeringWheelAngle(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 18;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_steeringWheelAngle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->steeringWheelAngle_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection(&substream, &((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->steeringWheelAngle[((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->steeringWheelAngle_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_yawRate(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 26;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_yawRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->yawRate_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection(&substream, &((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->yawRate[((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->yawRate_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_brakePedalPosition(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 34;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_brakePedalPosition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->brakePedalPosition_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection(&substream, &((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->brakePedalPosition[((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->brakePedalPosition_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_numberOfPedestrians(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 42;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_numberOfPedestrians(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->numberOfPedestrians_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection(&substream, &((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->numberOfPedestrians[((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->numberOfPedestrians_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_wiperStatus(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 50;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_wiperStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->wiperStatus_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection(&substream, &((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->wiperStatus[((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->wiperStatus_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginModifications_pedestrianSize(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 58;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_pedestrianSize(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->pedestrianSize_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection(&substream, &((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->pedestrianSize[((SystemCore_CollisionAvoidance_LateralMarginModifications*)data)->pedestrianSize_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_lowSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_lowSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw(&substream, &((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw*)data)->lowSensitivity);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_normalSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_normalSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw(&substream, &((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw*)data)->normalSensitivity);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_highSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_highSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw(&substream, &((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw*)data)->highSensitivity);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_lowSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_lowSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable(&substream, &((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters*)data)->lowSensitivity);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_normalSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_normalSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable(&substream, &((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters*)data)->normalSensitivity);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_highSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_highSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable(&substream, &((SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters*)data)->highSensitivity);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_lowSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_lowSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw(&substream, &((SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw*)data)->lowSensitivity);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_normalSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_normalSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw(&substream, &((SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw*)data)->normalSensitivity);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_highSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_highSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw(&substream, &((SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw*)data)->highSensitivity);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_lowSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTable *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_lowSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable(&substream, &((SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters*)data)->lowSensitivity);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_normalSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTable *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_normalSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable(&substream, &((SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters*)data)->normalSensitivity);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_highSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTable *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_highSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable(&substream, &((SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters*)data)->highSensitivity);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw_lowThreatThreshold(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw_lowThreatThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw(&substream, &((SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw*)data)->lowThreatThreshold);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw_highThreatThreshold(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw_highThreatThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw(&substream, &((SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw*)data)->highThreatThreshold);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_lowThreatThreshold(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdLookupTable *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_lowThreatThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable(&substream, &((SystemCore_CollisionAvoidance_ThreatThresholdTableParameters*)data)->lowThreatThreshold);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_highThreatThreshold(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdLookupTable *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_highThreatThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable(&substream, &((SystemCore_CollisionAvoidance_ThreatThresholdTableParameters*)data)->highThreatThreshold);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_light(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 10;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_light(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->light_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw(&substream, &((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->light[((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->light_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_steeringWheelAngle(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 18;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_steeringWheelAngle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->steeringWheelAngle_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw(&substream, &((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->steeringWheelAngle[((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->steeringWheelAngle_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_yawRate(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 26;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_yawRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->yawRate_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw(&substream, &((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->yawRate[((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->yawRate_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_brakePedalPosition(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 34;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_brakePedalPosition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->brakePedalPosition_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw(&substream, &((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->brakePedalPosition[((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->brakePedalPosition_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_numberOfPedestrians(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 42;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_numberOfPedestrians(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->numberOfPedestrians_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw(&substream, &((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->numberOfPedestrians[((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->numberOfPedestrians_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_wiperStatus(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 50;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_wiperStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->wiperStatus_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw(&substream, &((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->wiperStatus[((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->wiperStatus_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_pedestrianSize(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 58;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_pedestrianSize(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->pedestrianSize_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw(&substream, &((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->pedestrianSize[((SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw*)data)->pedestrianSize_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_light(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 10;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_light(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->light_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection(&substream, &((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->light[((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->light_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_steeringWheelAngle(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 18;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_steeringWheelAngle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->steeringWheelAngle_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection(&substream, &((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->steeringWheelAngle[((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->steeringWheelAngle_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_yawRate(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 26;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_yawRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->yawRate_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection(&substream, &((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->yawRate[((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->yawRate_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_brakePedalPosition(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 34;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_brakePedalPosition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->brakePedalPosition_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection(&substream, &((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->brakePedalPosition[((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->brakePedalPosition_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_numberOfPedestrians(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 42;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_numberOfPedestrians(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->numberOfPedestrians_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection(&substream, &((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->numberOfPedestrians[((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->numberOfPedestrians_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_wiperStatus(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 50;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_wiperStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->wiperStatus_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection(&substream, &((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->wiperStatus[((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->wiperStatus_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_pedestrianSize(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 58;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_pedestrianSize(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->pedestrianSize_count + 1) > 3)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection(&substream, &((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->pedestrianSize[((SystemCore_CollisionAvoidance_TimeToCollisionModifications*)data)->pedestrianSize_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_predictedDeceleration(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_predictedDeceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw(&substream, &((SystemCore_CollisionAvoidance_CollisionWarning_Raw*)data)->predictedDeceleration);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_reactionTime(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_reactionTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw(&substream, &((SystemCore_CollisionAvoidance_CollisionWarning_Raw*)data)->reactionTime);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_disableAdjustments(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_disableAdjustments(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_CollisionWarning_Raw*)data)->disableAdjustments, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionWarning_predictedDeceleration(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionWarning_predictedDeceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters(&substream, &((SystemCore_CollisionAvoidance_CollisionWarning*)data)->predictedDeceleration);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionWarning_reactionTime(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionWarning_reactionTime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters(&substream, &((SystemCore_CollisionAvoidance_CollisionWarning*)data)->reactionTime);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionWarning_disableAdjustments(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionWarning_disableAdjustments(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_CollisionWarning*)data)->disableAdjustments, sizeof(bool));
}

static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_negativeAccelerationMaximum(qpb_ostream_t *const stream, const int8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_negativeAccelerationMaximum(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_FullBrakeParameters_Raw*)data)->negativeAccelerationMaximum, sizeof(int8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_nominalAccelerationFactor(qpb_ostream_t *const stream, const int8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_nominalAccelerationFactor(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_FullBrakeParameters_Raw*)data)->nominalAccelerationFactor, sizeof(int8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_previousAccelerationRequestFactor(qpb_ostream_t *const stream, const int8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_previousAccelerationRequestFactor(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_FullBrakeParameters_Raw*)data)->previousAccelerationRequestFactor, sizeof(int8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_previousNominalRequestFactor(qpb_ostream_t *const stream, const int8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_previousNominalRequestFactor(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_FullBrakeParameters_Raw*)data)->previousNominalRequestFactor, sizeof(int8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_threatThreshold(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 42;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_threatThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw(&substream, &((SystemCore_CollisionAvoidance_FullBrakeParameters_Raw*)data)->threatThreshold);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_negativeAccelerationMaximum(qpb_ostream_t *const stream, const float *const data)
{
   int8_t value = (int8_t)convertToInt32(*data, F_0_1, INT8_MIN, INT8_MAX);
   encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_negativeAccelerationMaximum(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_negativeAccelerationMaximum(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int8_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int8_t));
   ((SystemCore_CollisionAvoidance_FullBrakeParameters*)data)->negativeAccelerationMaximum = value * F_0_1;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_nominalAccelerationFactor(qpb_ostream_t *const stream, const float *const data)
{
   int8_t value = (int8_t)convertToInt32(*data, F_0_01, INT8_MIN, INT8_MAX);
   encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_nominalAccelerationFactor(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_nominalAccelerationFactor(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int8_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int8_t));
   ((SystemCore_CollisionAvoidance_FullBrakeParameters*)data)->nominalAccelerationFactor = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_previousAccelerationRequestFactor(qpb_ostream_t *const stream, const float *const data)
{
   int8_t value = (int8_t)convertToInt32(*data, F_0_01, INT8_MIN, INT8_MAX);
   encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_previousAccelerationRequestFactor(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_previousAccelerationRequestFactor(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int8_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int8_t));
   ((SystemCore_CollisionAvoidance_FullBrakeParameters*)data)->previousAccelerationRequestFactor = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_previousNominalRequestFactor(qpb_ostream_t *const stream, const float *const data)
{
   int8_t value = (int8_t)convertToInt32(*data, F_0_01, INT8_MIN, INT8_MAX);
   encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_previousNominalRequestFactor(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_previousNominalRequestFactor(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int8_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int8_t));
   ((SystemCore_CollisionAvoidance_FullBrakeParameters*)data)->previousNominalRequestFactor = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_FullBrakeParameters_threatThreshold(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdTableParameters *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 42;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_threatThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters(&substream, &((SystemCore_CollisionAvoidance_FullBrakeParameters*)data)->threatThreshold);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_min(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_min(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw*)data)->min, sizeof(int16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_max(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_max(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw*)data)->max, sizeof(int16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_baseline(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 26;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_baseline(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw*)data)->baseline_count + 1 > 6)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw*)data)->baseline[((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw*)data)->baseline_count++], sizeof(int16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw*)data)->baseline_count + 1) > 6)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw*)data)->baseline[((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw*)data)->baseline_count++], sizeof(int16_t));
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_modifications(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginModifications_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_modifications(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw(&substream, &((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw*)data)->modifications);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_min(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_min(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_min(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable*)data)->min = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_max(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_max(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_max(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable*)data)->max = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_baseline(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   int16_t values[6];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (int16_t)convertToInt32(arrayData[i], F_0_01, INT16_MIN, INT16_MAX);
   }
   encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_baseline(stream, values, arraySize);
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_baseline(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable*)data)->baseline_count + 1 > 6)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         int16_t value;
         result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
         ((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable*)data)->baseline[((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable*)data)->baseline_count++] = value * F_0_01;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable*)data)->baseline_count + 1) > 6)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      int16_t value;
      result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
      ((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable*)data)->baseline[((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable*)data)->baseline_count++] = value * F_0_01;
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_modifications(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginModifications *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LateralMarginModifications(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_modifications(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LateralMarginModifications(&substream, &((SystemCore_CollisionAvoidance_LateralMarginCalibrationTable*)data)->modifications);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_negativeAccelerationMaximum(qpb_ostream_t *const stream, const int8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_negativeAccelerationMaximum(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_PreBrakeParameters_Raw*)data)->negativeAccelerationMaximum, sizeof(int8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_nominalRequestFactor(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_nominalRequestFactor(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_PreBrakeParameters_Raw*)data)->nominalRequestFactor, sizeof(uint8_t));
}

static inline void encode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_negativeJerkMinimum(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_negativeJerkMinimum(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_PreBrakeParameters_Raw*)data)->negativeJerkMinimum, sizeof(int16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_threatThreshold(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 42;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_threatThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw(&substream, &((SystemCore_CollisionAvoidance_PreBrakeParameters_Raw*)data)->threatThreshold);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_PreBrakeParameters_negativeAccelerationMaximum(qpb_ostream_t *const stream, const float *const data)
{
   int8_t value = (int8_t)convertToInt32(*data, F_0_1, INT8_MIN, INT8_MAX);
   encode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_negativeAccelerationMaximum(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters_negativeAccelerationMaximum(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int8_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int8_t));
   ((SystemCore_CollisionAvoidance_PreBrakeParameters*)data)->negativeAccelerationMaximum = value * F_0_1;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_PreBrakeParameters_nominalRequestFactor(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_01, 0, UINT8_MAX);
   encode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_nominalRequestFactor(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters_nominalRequestFactor(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((SystemCore_CollisionAvoidance_PreBrakeParameters*)data)->nominalRequestFactor = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_PreBrakeParameters_negativeJerkMinimum(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_negativeJerkMinimum(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters_negativeJerkMinimum(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((SystemCore_CollisionAvoidance_PreBrakeParameters*)data)->negativeJerkMinimum = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_PreBrakeParameters_threatThreshold(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdTableParameters *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 42;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters_threatThreshold(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters(&substream, &((SystemCore_CollisionAvoidance_PreBrakeParameters*)data)->threatThreshold);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_min(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_min(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw*)data)->min, sizeof(int16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_max(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_max(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw*)data)->max, sizeof(int16_t));
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_baseline(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 26;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_baseline(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw*)data)->baseline_count + 1 > 6)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw*)data)->baseline[((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw*)data)->baseline_count++], sizeof(int16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw*)data)->baseline_count + 1) > 6)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw*)data)->baseline[((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw*)data)->baseline_count++], sizeof(int16_t));
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_modifications(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_modifications(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw(&substream, &((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw*)data)->modifications);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_min(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_1, INT16_MIN, INT16_MAX);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_min(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_min(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable*)data)->min = value * F_0_1;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_max(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_1, INT16_MIN, INT16_MAX);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_max(stream, &value);
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_max(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable*)data)->max = value * F_0_1;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_baseline(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   int16_t values[6];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (int16_t)convertToInt32(arrayData[i], F_0_1, INT16_MIN, INT16_MAX);
   }
   encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_baseline(stream, values, arraySize);
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_baseline(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable*)data)->baseline_count + 1 > 6)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         int16_t value;
         result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
         ((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable*)data)->baseline[((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable*)data)->baseline_count++] = value * F_0_1;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable*)data)->baseline_count + 1) > 6)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      int16_t value;
      result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
      ((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable*)data)->baseline[((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable*)data)->baseline_count++] = value * F_0_1;
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_modifications(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionModifications *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_modifications(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications(&substream, &((SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable*)data)->modifications);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_fullBrake(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_FullBrakeParameters_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_fullBrake(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw(&substream, &((SystemCore_CollisionAvoidance_TunableParameters_Raw*)data)->fullBrake);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_preBrake(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PreBrakeParameters_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_preBrake(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw(&substream, &((SystemCore_CollisionAvoidance_TunableParameters_Raw*)data)->preBrake);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebTiming(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_AebTimingParameters_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebTiming(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw(&substream, &((SystemCore_CollisionAvoidance_TunableParameters_Raw*)data)->aebTiming);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebDeactivation(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebDeactivation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw(&substream, &((SystemCore_CollisionAvoidance_TunableParameters_Raw*)data)->aebDeactivation);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_ema(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_EmaParameters_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 42;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_EmaParameters_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_ema(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_EmaParameters_Raw(&substream, &((SystemCore_CollisionAvoidance_TunableParameters_Raw*)data)->ema);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_caLongActivation(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 50;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_caLongActivation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw(&substream, &((SystemCore_CollisionAvoidance_TunableParameters_Raw*)data)->caLongActivation);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_longitudinalTaTunable(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 58;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_longitudinalTaTunable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw(&substream, &((SystemCore_CollisionAvoidance_TunableParameters_Raw*)data)->longitudinalTaTunable);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebScenarioActivation(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 66;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebScenarioActivation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw(&substream, &((SystemCore_CollisionAvoidance_TunableParameters_Raw*)data)->aebScenarioActivation);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_lssDevelopmentOverrideParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 74;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_lssDevelopmentOverrideParameters(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw(&substream, &((SystemCore_CollisionAvoidance_TunableParameters_Raw*)data)->lssDevelopmentOverrideParameters);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_lssTunableParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LSSTunableParameters_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 82;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_lssTunableParameters(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw(&substream, &((SystemCore_CollisionAvoidance_TunableParameters_Raw*)data)->lssTunableParameters);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_collisionWarning(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_CollisionWarning_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 90;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_CollisionWarning_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw_collisionWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_CollisionWarning_Raw(&substream, &((SystemCore_CollisionAvoidance_TunableParameters_Raw*)data)->collisionWarning);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_fullBrake(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_FullBrakeParameters *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_FullBrakeParameters(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_fullBrake(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_FullBrakeParameters(&substream, &((SystemCore_CollisionAvoidance_TunableParameters*)data)->fullBrake);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_preBrake(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PreBrakeParameters *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_PreBrakeParameters(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_preBrake(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_PreBrakeParameters(&substream, &((SystemCore_CollisionAvoidance_TunableParameters*)data)->preBrake);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_aebTiming(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_AebTimingParameters *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_AebTimingParameters(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_aebTiming(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_AebTimingParameters(&substream, &((SystemCore_CollisionAvoidance_TunableParameters*)data)->aebTiming);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_aebDeactivation(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_AebDeactivationParameters *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_AebDeactivationParameters(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_aebDeactivation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_AebDeactivationParameters(&substream, &((SystemCore_CollisionAvoidance_TunableParameters*)data)->aebDeactivation);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_ema(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_EmaParameters *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 42;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_EmaParameters(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_ema(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_EmaParameters(&substream, &((SystemCore_CollisionAvoidance_TunableParameters*)data)->ema);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_caLongActivation(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_CaLongActivationParameters *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 50;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_CaLongActivationParameters(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_caLongActivation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_CaLongActivationParameters(&substream, &((SystemCore_CollisionAvoidance_TunableParameters*)data)->caLongActivation);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_longitudinalTaTunable(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 58;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_longitudinalTaTunable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters(&substream, &((SystemCore_CollisionAvoidance_TunableParameters*)data)->longitudinalTaTunable);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_aebScenarioActivation(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_AebScenarioActivationParameters *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 66;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_aebScenarioActivation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters(&substream, &((SystemCore_CollisionAvoidance_TunableParameters*)data)->aebScenarioActivation);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_lssDevelopmentOverrideParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 74;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_lssDevelopmentOverrideParameters(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters(&substream, &((SystemCore_CollisionAvoidance_TunableParameters*)data)->lssDevelopmentOverrideParameters);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_lssTunableParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LSSTunableParameters *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 82;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_lssTunableParameters(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LSSTunableParameters(&substream, &((SystemCore_CollisionAvoidance_TunableParameters*)data)->lssTunableParameters);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_TunableParameters_collisionWarning(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_CollisionWarning *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 90;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_CollisionWarning(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_TunableParameters_collisionWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_CollisionWarning(&substream, &((SystemCore_CollisionAvoidance_TunableParameters*)data)->collisionWarning);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw_timeToCollision(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw_timeToCollision(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw(&substream, &((SystemCore_CollisionAvoidance_ZoneCalibration_Raw*)data)->timeToCollision);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw_lateralMargin(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw_lateralMargin(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw(&substream, &((SystemCore_CollisionAvoidance_ZoneCalibration_Raw*)data)->lateralMargin);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ZoneCalibration_timeToCollision(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ZoneCalibration_timeToCollision(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable(&substream, &((SystemCore_CollisionAvoidance_ZoneCalibration*)data)->timeToCollision);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_ZoneCalibration_lateralMargin(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginCalibrationTable *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_ZoneCalibration_lateralMargin(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable(&substream, &((SystemCore_CollisionAvoidance_ZoneCalibration*)data)->lateralMargin);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_aebSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_SensitivitySettings *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_aebSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw*)data)->aebSensitivity, qpb_membersize(SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw, aebSensitivity));
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableAeb(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableAeb(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw*)data)->enableAeb, qpb_membersize(SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw, enableAeb));
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableEma(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableEma(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw*)data)->enableEma, qpb_membersize(SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw, enableEma));
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableOsp(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableOsp(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw*)data)->enableOsp, qpb_membersize(SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw, enableOsp));
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableCw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableCw(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw*)data)->enableCw, qpb_membersize(SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw, enableCw));
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_tunableParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TunableParameters_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 50;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_TunableParameters_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_tunableParameters(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_TunableParameters_Raw(&substream, &((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw*)data)->tunableParameters);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableDbs(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableDbs(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw*)data)->enableDbs, qpb_membersize(SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw, enableDbs));
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_lka(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 66;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_lka(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw(&substream, &((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw*)data)->lka);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_ldw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 74;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_ldw(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw(&substream, &((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw*)data)->ldw);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaRoadEdge(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 82;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaRoadEdge(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw(&substream, &((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw*)data)->elkaRoadEdge);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaFrontObjects(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 90;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaFrontObjects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw(&substream, &((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw*)data)->elkaFrontObjects);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaRearObjects(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 98;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaRearObjects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw(&substream, &((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw*)data)->elkaRearObjects);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_aebSensitivity(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_SensitivitySettings *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_aebSensitivity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings*)data)->aebSensitivity, qpb_membersize(SystemCore_CollisionAvoidance_CollisionAvoidanceSettings, aebSensitivity));
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableAeb(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableAeb(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings*)data)->enableAeb, qpb_membersize(SystemCore_CollisionAvoidance_CollisionAvoidanceSettings, enableAeb));
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableEma(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableEma(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings*)data)->enableEma, qpb_membersize(SystemCore_CollisionAvoidance_CollisionAvoidanceSettings, enableEma));
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableOsp(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableOsp(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings*)data)->enableOsp, qpb_membersize(SystemCore_CollisionAvoidance_CollisionAvoidanceSettings, enableOsp));
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableCw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableCw(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings*)data)->enableCw, qpb_membersize(SystemCore_CollisionAvoidance_CollisionAvoidanceSettings, enableCw));
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_tunableParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TunableParameters *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 50;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_TunableParameters(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_tunableParameters(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_TunableParameters(&substream, &((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings*)data)->tunableParameters);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableDbs(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_Switch *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_enableDbs(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings*)data)->enableDbs, qpb_membersize(SystemCore_CollisionAvoidance_CollisionAvoidanceSettings, enableDbs));
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_lka(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 66;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LssFeatureInput(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_lka(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LssFeatureInput(&substream, &((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings*)data)->lka);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_ldw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 74;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LssFeatureInput(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_ldw(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LssFeatureInput(&substream, &((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings*)data)->ldw);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaRoadEdge(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 82;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LssFeatureInput(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaRoadEdge(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LssFeatureInput(&substream, &((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings*)data)->elkaRoadEdge);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaFrontObjects(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 90;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LssFeatureInput(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaFrontObjects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LssFeatureInput(&substream, &((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings*)data)->elkaFrontObjects);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaRearObjects(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 98;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_LssFeatureInput(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaRearObjects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_LssFeatureInput(&substream, &((SystemCore_CollisionAvoidance_CollisionAvoidanceSettings*)data)->elkaRearObjects);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_cib(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_cib(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw(&substream, &((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw*)data)->cib);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_prefill(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_prefill(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw(&substream, &((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw*)data)->prefill);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_fca(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_fca(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw(&substream, &((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw*)data)->fca);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_notification(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_notification(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw(&substream, &((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw*)data)->notification);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_speedNodes(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 42;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_speedNodes(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw*)data)->speedNodes_count + 1 > 6)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw*)data)->speedNodes[((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw*)data)->speedNodes_count++], sizeof(uint16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw*)data)->speedNodes_count + 1) > 6)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw*)data)->speedNodes[((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw*)data)->speedNodes_count++], sizeof(uint16_t));
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_cib(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ZoneCalibration(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_cib(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ZoneCalibration(&substream, &((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters*)data)->cib);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_prefill(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ZoneCalibration(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_prefill(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ZoneCalibration(&substream, &((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters*)data)->prefill);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_fca(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ZoneCalibration(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_fca(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ZoneCalibration(&substream, &((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters*)data)->fca);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_notification(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_ZoneCalibration(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_notification(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_ZoneCalibration(&substream, &((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters*)data)->notification);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_speedNodes(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   uint16_t values[6];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (uint16_t)convertToUint32(arrayData[i], F_0_1, 0, UINT16_MAX);
   }
   encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_speedNodes(stream, values, arraySize);
}

static bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_speedNodes(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters*)data)->speedNodes_count + 1 > 6)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         uint16_t value;
         result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
         ((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters*)data)->speedNodes[((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters*)data)->speedNodes_count++] = value * F_0_1;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters*)data)->speedNodes_count + 1) > 6)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      uint16_t value;
      result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
      ((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters*)data)->speedNodes[((SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters*)data)->speedNodes_count++] = value * F_0_1;
   }
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw_zoneCalibration(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw_zoneCalibration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw(&substream, &((SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw*)data)->zoneCalibration);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw_decelerationRequest(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw_decelerationRequest(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw(&substream, &((SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw*)data)->decelerationRequest);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_zoneCalibration(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_zoneCalibration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters(&substream, &((SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters*)data)->zoneCalibration);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_decelerationRequest(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_VruDecelerationRequestParameters *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_decelerationRequest(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters(&substream, &((SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters*)data)->decelerationRequest);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

/* Encoding / decoding functions */
bool encode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_AebDeactivationParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_timeWithHighTtc(stream, &data->timeWithHighTtc);
   encode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_standstillTime(stream, &data->standstillTime);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_AebDeactivationParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_AebDeactivationParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_AebDeactivationParameters *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_AebDeactivationParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_AebDeactivationParameters_timeWithHighTtc(stream, &data->timeWithHighTtc);
   encode_SystemCore_CollisionAvoidance_AebDeactivationParameters_standstillTime(stream, &data->standstillTime);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_AebDeactivationParameters(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_AebDeactivationParameters *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_AebDeactivationParameters_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_AebDeactivationParameters_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_AebScenarioActivationParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw_activateAebOncoming(stream, &data->activateAebOncoming);
   encode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw_activateAebCrossing(stream, &data->activateAebCrossing);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_AebScenarioActivationParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_AebTimingParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_AebTimingParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_beltActivationDelay(stream, &data->beltActivationDelay);
   encode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_postEventMessageActivationDelay(stream, &data->postEventMessageActivationDelay);
   encode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw_standstillRequestHoldTime(stream, &data->standstillRequestHoldTime);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_AebTimingParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_AebTimingParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_AebTimingParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_AebTimingParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_AebTimingParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_AebTimingParameters *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_AebTimingParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_AebTimingParameters_beltActivationDelay(stream, &data->beltActivationDelay);
   encode_SystemCore_CollisionAvoidance_AebTimingParameters_postEventMessageActivationDelay(stream, &data->postEventMessageActivationDelay);
   encode_SystemCore_CollisionAvoidance_AebTimingParameters_standstillRequestHoldTime(stream, &data->standstillRequestHoldTime);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_AebTimingParameters(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_AebTimingParameters *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_AebTimingParameters_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_AebTimingParameters_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_CaLongActivationParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateActuatingFunctions(stream, &data->activateActuatingFunctions);
   encode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateSteeringThreat(stream, &data->activateSteeringThreat);
   encode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_activateVruObjects(stream, &data->activateVruObjects);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_CaLongActivationParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_EmaParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_EmaParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_EmaParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_EmaParameters_Raw_lateralJerkActivationThreshold(stream, &data->lateralJerkActivationThreshold);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_EmaParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_EmaParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_EmaParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_EmaParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_EmaParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_EmaParameters *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_EmaParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_EmaParameters_lateralJerkActivationThreshold(stream, &data->lateralJerkActivationThreshold);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_EmaParameters(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_EmaParameters *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_EmaParameters_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_EmaParameters_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaBlisInjectedTargetLeft(stream, &data->elkaBlisInjectedTargetLeft);
   encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaBlisInjectedTargetRight(stream, &data->elkaBlisInjectedTargetRight);
   encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaFrontObjectsInjectedTargetLeft(stream, &data->elkaFrontObjectsInjectedTargetLeft);
   encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_elkaFrontObjectsInjectedTargetRight(stream, &data->elkaFrontObjectsInjectedTargetRight);
   encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_lkaEnableStraightTestPath(stream, &data->lkaEnableStraightTestPath);
   encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_virtualRoadEdge(stream, &data->virtualRoadEdge);
   encode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_saturateLateralPositionForCriticalObjects(stream, &data->saturateLateralPositionForCriticalObjects);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_LSSDevelopmentOverrideParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LSSTunableParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_LSSTunableParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lkaMaxTimeNeeded(stream, &data->lkaMaxTimeNeeded);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_elkaRoadEdgeMaxTimeNeeded(stream, &data->elkaRoadEdgeMaxTimeNeeded);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lkaLaneWidthEnableMargin(stream, &data->lkaLaneWidthEnableMargin);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssEnableObjectTypeSuppression(stream, &data->lssEnableObjectTypeSuppression);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionSensitivity(stream, &data->lssOncomingObjectSuppressionSensitivity);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionSensitivity(stream, &data->lssOvertakeObjectSuppressionSensitivity);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionTime(stream, &data->lssOncomingObjectSuppressionTime);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionTime(stream, &data->lssOvertakeObjectSuppressionTime);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssAccelerationExtrapolationTimeForObjectSuppression(stream, &data->lssAccelerationExtrapolationTimeForObjectSuppression);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionTimeToReachLimit(stream, &data->lssOncomingObjectSuppressionTimeToReachLimit);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionTimeToReachLimit(stream, &data->lssOvertakeObjectSuppressionTimeToReachLimit);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionLateralPositionLimit(stream, &data->lssOvertakeObjectSuppressionLateralPositionLimit);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionLateralGapLimit(stream, &data->lssOncomingObjectSuppressionLateralGapLimit);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssObjectSuppressionNarrowRoadLimit(stream, &data->lssObjectSuppressionNarrowRoadLimit);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_LSSTunableParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_LSSTunableParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LSSTunableParameters *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_LSSTunableParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lkaMaxTimeNeeded(stream, &data->lkaMaxTimeNeeded);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_elkaRoadEdgeMaxTimeNeeded(stream, &data->elkaRoadEdgeMaxTimeNeeded);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lkaLaneWidthEnableMargin(stream, &data->lkaLaneWidthEnableMargin);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssEnableObjectTypeSuppression(stream, &data->lssEnableObjectTypeSuppression);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOncomingObjectSuppressionSensitivity(stream, &data->lssOncomingObjectSuppressionSensitivity);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_Raw_lssOvertakeObjectSuppressionSensitivity(stream, &data->lssOvertakeObjectSuppressionSensitivity);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionTime(stream, &data->lssOncomingObjectSuppressionTime);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionTime(stream, &data->lssOvertakeObjectSuppressionTime);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssAccelerationExtrapolationTimeForObjectSuppression(stream, &data->lssAccelerationExtrapolationTimeForObjectSuppression);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionTimeToReachLimit(stream, &data->lssOncomingObjectSuppressionTimeToReachLimit);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionTimeToReachLimit(stream, &data->lssOvertakeObjectSuppressionTimeToReachLimit);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOvertakeObjectSuppressionLateralPositionLimit(stream, &data->lssOvertakeObjectSuppressionLateralPositionLimit);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssOncomingObjectSuppressionLateralGapLimit(stream, &data->lssOncomingObjectSuppressionLateralGapLimit);
   encode_SystemCore_CollisionAvoidance_LSSTunableParameters_lssObjectSuppressionNarrowRoadLimit(stream, &data->lssObjectSuppressionNarrowRoadLimit);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_LSSTunableParameters(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_LSSTunableParameters *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_LSSTunableParameters_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_LSSTunableParameters_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_offset(stream, &data->offset);
   encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_correction(stream, &data->correction);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_offset(stream, &data->offset);
   encode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_correction(stream, &data->correction);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_LateralMarginOffsetAndCorrection_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_brakeDelayEstimate(stream, data->brakeDelayEstimate, data->brakeDelayEstimate_count);
   encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_longitudinalMarginWhenAebActive(stream, &data->longitudinalMarginWhenAebActive);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_brakeDelayEstimate(stream, data->brakeDelayEstimate, data->brakeDelayEstimate_count);
   encode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_longitudinalMarginWhenAebActive(stream, &data->longitudinalMarginWhenAebActive);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_LongitudinalTaTunableParameters_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LssFeatureInput_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_LssFeatureInput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_enable(stream, &data->enable);
   encode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_suppress(stream, &data->suppress);
   encode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw_abort(stream, &data->abort);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_LssFeatureInput_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_LssFeatureInput_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_LssFeatureInput_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_LssFeatureInput_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_values(stream, data->values, data->values_count);
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_breakpoints(stream, data->breakpoints, data->breakpoints_count);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_values(stream, data->values, data->values_count);
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_breakpoints(stream, data->breakpoints, data->breakpoints_count);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityLookupTable_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_ReactionTimeLookupTable_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_values(stream, data->values, data->values_count);
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_breakpoints(stream, data->breakpoints, data->breakpoints_count);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_ReactionTimeLookupTable_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTable *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_ReactionTimeLookupTable_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_values(stream, data->values, data->values_count);
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable_breakpoints(stream, data->breakpoints, data->breakpoints_count);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTable(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_ReactionTimeLookupTable *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_ReactionTimeLookupTable_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_ReactionTimeLookupTable_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_StaticDistanceWarningParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_StaticDistanceWarningParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_StaticDistanceWarningParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_StaticDistanceWarningParameters_Raw_enableSdw(stream, &data->enableSdw);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_StaticDistanceWarningParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_StaticDistanceWarningParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_StaticDistanceWarningParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_StaticDistanceWarningParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_TargetSelectionParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_funnelBreakpoints(stream, data->funnelBreakpoints, data->funnelBreakpoints_count);
   encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_innerFunnelWidths(stream, data->innerFunnelWidths, data->innerFunnelWidths_count);
   encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_outerFunnelWidths(stream, data->outerFunnelWidths, data->outerFunnelWidths_count);
   encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_enabledObjectTypes(stream, &data->enabledObjectTypes);
   encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_cutInTimeThreshold(stream, &data->cutInTimeThreshold);
   encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_enableCutIn(stream, &data->enableCutIn);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_TargetSelectionParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TargetSelectionParameters *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_TargetSelectionParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_funnelBreakpoints(stream, data->funnelBreakpoints, data->funnelBreakpoints_count);
   encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_innerFunnelWidths(stream, data->innerFunnelWidths, data->innerFunnelWidths_count);
   encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_outerFunnelWidths(stream, data->outerFunnelWidths, data->outerFunnelWidths_count);
   encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_enabledObjectTypes(stream, &data->enabledObjectTypes);
   encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_cutInTimeThreshold(stream, &data->cutInTimeThreshold);
   encode_SystemCore_CollisionAvoidance_TargetSelectionParameters_Raw_enableCutIn(stream, &data->enableCutIn);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_TargetSelectionParameters(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_TargetSelectionParameters *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_TargetSelectionParameters_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_TargetSelectionParameters_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_values(stream, data->values, data->values_count);
   encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_breakpoints(stream, data->breakpoints, data->breakpoints_count);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdLookupTable *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_values(stream, data->values, data->values_count);
   encode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_breakpoints(stream, data->breakpoints, data->breakpoints_count);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_ThreatThresholdLookupTable(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_ThreatThresholdLookupTable *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_ThreatThresholdLookupTable_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_offset(stream, &data->offset);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_correction(stream, &data->correction);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_offset(stream, &data->offset);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_correction(stream, &data->correction);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_TimeToCollisionOffsetAndCorrection_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_closedLoopEnable(stream, &data->closedLoopEnable);
   encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_avoidanceDecelerationLag(stream, &data->avoidanceDecelerationLag);
   encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_avoidanceDistance(stream, &data->avoidanceDistance);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_VruDecelerationRequestParameters *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_Raw_closedLoopEnable(stream, &data->closedLoopEnable);
   encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_avoidanceDecelerationLag(stream, &data->avoidanceDecelerationLag);
   encode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_avoidanceDistance(stream, &data->avoidanceDistance);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_VruDecelerationRequestParameters(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_VruDecelerationRequestParameters *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_VruDecelerationRequestParameters_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginModifications_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_LateralMarginModifications_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_light(stream, data->light, data->light_count);
   encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_steeringWheelAngle(stream, data->steeringWheelAngle, data->steeringWheelAngle_count);
   encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_yawRate(stream, data->yawRate, data->yawRate_count);
   encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_brakePedalPosition(stream, data->brakePedalPosition, data->brakePedalPosition_count);
   encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_numberOfPedestrians(stream, data->numberOfPedestrians, data->numberOfPedestrians_count);
   encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_wiperStatus(stream, data->wiperStatus, data->wiperStatus_count);
   encode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_pedestrianSize(stream, data->pedestrianSize, data->pedestrianSize_count);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_LateralMarginModifications_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_LateralMarginModifications_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_LateralMarginModifications(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginModifications *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_LateralMarginModifications_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_LateralMarginModifications_light(stream, data->light, data->light_count);
   encode_SystemCore_CollisionAvoidance_LateralMarginModifications_steeringWheelAngle(stream, data->steeringWheelAngle, data->steeringWheelAngle_count);
   encode_SystemCore_CollisionAvoidance_LateralMarginModifications_yawRate(stream, data->yawRate, data->yawRate_count);
   encode_SystemCore_CollisionAvoidance_LateralMarginModifications_brakePedalPosition(stream, data->brakePedalPosition, data->brakePedalPosition_count);
   encode_SystemCore_CollisionAvoidance_LateralMarginModifications_numberOfPedestrians(stream, data->numberOfPedestrians, data->numberOfPedestrians_count);
   encode_SystemCore_CollisionAvoidance_LateralMarginModifications_wiperStatus(stream, data->wiperStatus, data->wiperStatus_count);
   encode_SystemCore_CollisionAvoidance_LateralMarginModifications_pedestrianSize(stream, data->pedestrianSize, data->pedestrianSize_count);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_LateralMarginModifications(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_LateralMarginModifications *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_LateralMarginModifications_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_LateralMarginModifications_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_lowSensitivity(stream, &data->lowSensitivity);
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_normalSensitivity(stream, &data->normalSensitivity);
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_highSensitivity(stream, &data->highSensitivity);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_lowSensitivity(stream, &data->lowSensitivity);
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_normalSensitivity(stream, &data->normalSensitivity);
   encode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_highSensitivity(stream, &data->highSensitivity);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_PredictedDecelerationSensitivityTableParameters_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_lowSensitivity(stream, &data->lowSensitivity);
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_normalSensitivity(stream, &data->normalSensitivity);
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_highSensitivity(stream, &data->highSensitivity);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_lowSensitivity(stream, &data->lowSensitivity);
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_normalSensitivity(stream, &data->normalSensitivity);
   encode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_highSensitivity(stream, &data->highSensitivity);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_ReactionTimeLookupTableParameters_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw_lowThreatThreshold(stream, &data->lowThreatThreshold);
   encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw_highThreatThreshold(stream, &data->highThreatThreshold);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ThreatThresholdTableParameters *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_lowThreatThreshold(stream, &data->lowThreatThreshold);
   encode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_highThreatThreshold(stream, &data->highThreatThreshold);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_ThreatThresholdTableParameters(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_ThreatThresholdTableParameters *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_ThreatThresholdTableParameters_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_TimeToCollisionModifications_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_light(stream, data->light, data->light_count);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_steeringWheelAngle(stream, data->steeringWheelAngle, data->steeringWheelAngle_count);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_yawRate(stream, data->yawRate, data->yawRate_count);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_brakePedalPosition(stream, data->brakePedalPosition, data->brakePedalPosition_count);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_numberOfPedestrians(stream, data->numberOfPedestrians, data->numberOfPedestrians_count);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_wiperStatus(stream, data->wiperStatus, data->wiperStatus_count);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_pedestrianSize(stream, data->pedestrianSize, data->pedestrianSize_count);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_TimeToCollisionModifications_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionModifications *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_TimeToCollisionModifications_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_light(stream, data->light, data->light_count);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_steeringWheelAngle(stream, data->steeringWheelAngle, data->steeringWheelAngle_count);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_yawRate(stream, data->yawRate, data->yawRate_count);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_brakePedalPosition(stream, data->brakePedalPosition, data->brakePedalPosition_count);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_numberOfPedestrians(stream, data->numberOfPedestrians, data->numberOfPedestrians_count);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_wiperStatus(stream, data->wiperStatus, data->wiperStatus_count);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionModifications_pedestrianSize(stream, data->pedestrianSize, data->pedestrianSize_count);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_TimeToCollisionModifications(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_TimeToCollisionModifications *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_TimeToCollisionModifications_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_TimeToCollisionModifications_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_CollisionWarning_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_CollisionWarning_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_CollisionWarning_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_predictedDeceleration(stream, &data->predictedDeceleration);
   encode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_reactionTime(stream, &data->reactionTime);
   encode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_disableAdjustments(stream, &data->disableAdjustments);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_CollisionWarning_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_CollisionWarning_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_CollisionWarning_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_CollisionWarning_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_CollisionWarning(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_CollisionWarning *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_CollisionWarning_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_CollisionWarning_predictedDeceleration(stream, &data->predictedDeceleration);
   encode_SystemCore_CollisionAvoidance_CollisionWarning_reactionTime(stream, &data->reactionTime);
   encode_SystemCore_CollisionAvoidance_CollisionWarning_Raw_disableAdjustments(stream, &data->disableAdjustments);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_CollisionWarning(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_CollisionWarning *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_CollisionWarning_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_CollisionWarning_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_FullBrakeParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_FullBrakeParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_negativeAccelerationMaximum(stream, &data->negativeAccelerationMaximum);
   encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_nominalAccelerationFactor(stream, &data->nominalAccelerationFactor);
   encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_previousAccelerationRequestFactor(stream, &data->previousAccelerationRequestFactor);
   encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_previousNominalRequestFactor(stream, &data->previousNominalRequestFactor);
   encode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_threatThreshold(stream, &data->threatThreshold);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_FullBrakeParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_FullBrakeParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_FullBrakeParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_FullBrakeParameters *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_FullBrakeParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_FullBrakeParameters_negativeAccelerationMaximum(stream, &data->negativeAccelerationMaximum);
   encode_SystemCore_CollisionAvoidance_FullBrakeParameters_nominalAccelerationFactor(stream, &data->nominalAccelerationFactor);
   encode_SystemCore_CollisionAvoidance_FullBrakeParameters_previousAccelerationRequestFactor(stream, &data->previousAccelerationRequestFactor);
   encode_SystemCore_CollisionAvoidance_FullBrakeParameters_previousNominalRequestFactor(stream, &data->previousNominalRequestFactor);
   encode_SystemCore_CollisionAvoidance_FullBrakeParameters_threatThreshold(stream, &data->threatThreshold);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_FullBrakeParameters(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_FullBrakeParameters *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_FullBrakeParameters_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_FullBrakeParameters_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_min(stream, &data->min);
   encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_max(stream, &data->max);
   encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_baseline(stream, data->baseline, data->baseline_count);
   encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_modifications(stream, &data->modifications);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_LateralMarginCalibrationTable *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_min(stream, &data->min);
   encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_max(stream, &data->max);
   encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_baseline(stream, data->baseline, data->baseline_count);
   encode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_modifications(stream, &data->modifications);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_LateralMarginCalibrationTable(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_LateralMarginCalibrationTable *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_LateralMarginCalibrationTable_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PreBrakeParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_PreBrakeParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_negativeAccelerationMaximum(stream, &data->negativeAccelerationMaximum);
   encode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_nominalRequestFactor(stream, &data->nominalRequestFactor);
   encode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_negativeJerkMinimum(stream, &data->negativeJerkMinimum);
   encode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_threatThreshold(stream, &data->threatThreshold);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_PreBrakeParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_PreBrakeParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_PreBrakeParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_PreBrakeParameters *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_PreBrakeParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_PreBrakeParameters_negativeAccelerationMaximum(stream, &data->negativeAccelerationMaximum);
   encode_SystemCore_CollisionAvoidance_PreBrakeParameters_nominalRequestFactor(stream, &data->nominalRequestFactor);
   encode_SystemCore_CollisionAvoidance_PreBrakeParameters_negativeJerkMinimum(stream, &data->negativeJerkMinimum);
   encode_SystemCore_CollisionAvoidance_PreBrakeParameters_threatThreshold(stream, &data->threatThreshold);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_PreBrakeParameters(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_PreBrakeParameters *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_PreBrakeParameters_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_PreBrakeParameters_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_min(stream, &data->min);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_max(stream, &data->max);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_baseline(stream, data->baseline, data->baseline_count);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_modifications(stream, &data->modifications);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_min(stream, &data->min);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_max(stream, &data->max);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_baseline(stream, data->baseline, data->baseline_count);
   encode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_modifications(stream, &data->modifications);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_TimeToCollisionCalibrationTable_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_TunableParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TunableParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_TunableParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_fullBrake(stream, &data->fullBrake);
   encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_preBrake(stream, &data->preBrake);
   encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebTiming(stream, &data->aebTiming);
   encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebDeactivation(stream, &data->aebDeactivation);
   encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_ema(stream, &data->ema);
   encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_caLongActivation(stream, &data->caLongActivation);
   encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_longitudinalTaTunable(stream, &data->longitudinalTaTunable);
   encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_aebScenarioActivation(stream, &data->aebScenarioActivation);
   encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_lssDevelopmentOverrideParameters(stream, &data->lssDevelopmentOverrideParameters);
   encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_lssTunableParameters(stream, &data->lssTunableParameters);
   encode_SystemCore_CollisionAvoidance_TunableParameters_Raw_collisionWarning(stream, &data->collisionWarning);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_TunableParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_TunableParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_TunableParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_TunableParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_TunableParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_TunableParameters *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_TunableParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_TunableParameters_fullBrake(stream, &data->fullBrake);
   encode_SystemCore_CollisionAvoidance_TunableParameters_preBrake(stream, &data->preBrake);
   encode_SystemCore_CollisionAvoidance_TunableParameters_aebTiming(stream, &data->aebTiming);
   encode_SystemCore_CollisionAvoidance_TunableParameters_aebDeactivation(stream, &data->aebDeactivation);
   encode_SystemCore_CollisionAvoidance_TunableParameters_ema(stream, &data->ema);
   encode_SystemCore_CollisionAvoidance_TunableParameters_caLongActivation(stream, &data->caLongActivation);
   encode_SystemCore_CollisionAvoidance_TunableParameters_longitudinalTaTunable(stream, &data->longitudinalTaTunable);
   encode_SystemCore_CollisionAvoidance_TunableParameters_aebScenarioActivation(stream, &data->aebScenarioActivation);
   encode_SystemCore_CollisionAvoidance_TunableParameters_lssDevelopmentOverrideParameters(stream, &data->lssDevelopmentOverrideParameters);
   encode_SystemCore_CollisionAvoidance_TunableParameters_lssTunableParameters(stream, &data->lssTunableParameters);
   encode_SystemCore_CollisionAvoidance_TunableParameters_collisionWarning(stream, &data->collisionWarning);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_TunableParameters(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_TunableParameters *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_TunableParameters_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_TunableParameters_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_ZoneCalibration_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw_timeToCollision(stream, &data->timeToCollision);
   encode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw_lateralMargin(stream, &data->lateralMargin);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_ZoneCalibration_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_ZoneCalibration_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_ZoneCalibration_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_ZoneCalibration_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_ZoneCalibration(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_ZoneCalibration *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_ZoneCalibration_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_ZoneCalibration_timeToCollision(stream, &data->timeToCollision);
   encode_SystemCore_CollisionAvoidance_ZoneCalibration_lateralMargin(stream, &data->lateralMargin);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_ZoneCalibration(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_ZoneCalibration *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_ZoneCalibration_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_ZoneCalibration_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_aebSensitivity(stream, &data->aebSensitivity);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableAeb(stream, &data->enableAeb);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableEma(stream, &data->enableEma);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableOsp(stream, &data->enableOsp);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableCw(stream, &data->enableCw);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_tunableParameters(stream, &data->tunableParameters);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableDbs(stream, &data->enableDbs);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_lka(stream, &data->lka);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_ldw(stream, &data->ldw);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaRoadEdge(stream, &data->elkaRoadEdge);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaFrontObjects(stream, &data->elkaFrontObjects);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_elkaRearObjects(stream, &data->elkaRearObjects);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_CollisionAvoidanceSettings *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_aebSensitivity(stream, &data->aebSensitivity);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableAeb(stream, &data->enableAeb);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableEma(stream, &data->enableEma);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableOsp(stream, &data->enableOsp);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableCw(stream, &data->enableCw);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_tunableParameters(stream, &data->tunableParameters);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_Raw_enableDbs(stream, &data->enableDbs);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_lka(stream, &data->lka);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_ldw(stream, &data->ldw);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaRoadEdge(stream, &data->elkaRoadEdge);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaFrontObjects(stream, &data->elkaFrontObjects);
   encode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_elkaRearObjects(stream, &data->elkaRearObjects);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_CollisionAvoidanceSettings(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_CollisionAvoidanceSettings *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_CollisionAvoidanceSettings_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_cib(stream, &data->cib);
   encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_prefill(stream, &data->prefill);
   encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_fca(stream, &data->fca);
   encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_notification(stream, &data->notification);
   encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_speedNodes(stream, data->speedNodes, data->speedNodes_count);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_cib(stream, &data->cib);
   encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_prefill(stream, &data->prefill);
   encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_fca(stream, &data->fca);
   encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_notification(stream, &data->notification);
   encode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_speedNodes(stream, data->speedNodes, data->speedNodes_count);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_VruZoneCalibrationTableParameters_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw_zoneCalibration(stream, &data->zoneCalibration);
   encode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw_decelerationRequest(stream, &data->decelerationRequest);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters(qpb_ostream_t *const stream, const SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_zoneCalibration(stream, &data->zoneCalibration);
   encode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_decelerationRequest(stream, &data->decelerationRequest);
   return true;
}

bool decode_SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters(qpb_istream_t *const stream, SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_CollisionAvoidance_VruCollisionAvoidanceParameters_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

