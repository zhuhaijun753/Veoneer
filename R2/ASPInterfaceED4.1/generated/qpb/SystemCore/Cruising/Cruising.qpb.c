/* Automatically generated qpb constant definitions */
/* Generated by Quick Protocol Buffers - 2 */

#include "SystemCore/Cruising/Cruising.qpb.h"
#include "Tools/QuickProtobuf/qpb_decode.h"
#include "Tools/QuickProtobuf/qpb_encode.h"
#include "Tools/CSupport/ConversionSupport.h"

#if QPB_PROTO_HEADER_VERSION != 2
#error Regenerate this file with the current version of qpb generator.
#endif

#define F_0_005              0.005f
#define F_0_01               0.01f
#define F_0_1                0.1f

static inline void encode_SystemCore_Crusing_CruisingFeatureState_Raw_csaActive(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Crusing_CruisingFeatureState_Raw_csaActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_CruisingFeatureState_Raw_ccActive(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Crusing_CruisingFeatureState_Raw_ccActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_CruisingFeatureState_Raw_accState(qpb_ostream_t *const stream, const SystemCore_Crusing_AccState *const data);
static bool decode_SystemCore_Crusing_CruisingFeatureState_Raw_accState(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_DistanceControllerInput_Raw_timegap(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_Crusing_DistanceControllerInput_Raw_timegap(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_DistanceControllerInput_Raw_currentAccelerationRequestedToActuators(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_SystemCore_Crusing_DistanceControllerInput_Raw_currentAccelerationRequestedToActuators(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_DistanceControllerInput_Raw_usedActuator(qpb_ostream_t *const stream, const SystemCore_Crusing_UsedActuator *const data);
static bool decode_SystemCore_Crusing_DistanceControllerInput_Raw_usedActuator(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_DistanceControllerInput_Raw_laneChangeIndicatedByDriver(qpb_ostream_t *const stream, const SystemCore_Crusing_LateralDirection *const data);
static bool decode_SystemCore_Crusing_DistanceControllerInput_Raw_laneChangeIndicatedByDriver(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_DistanceControllerInput_Raw_overtakeBoostRequestedByDriver(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Crusing_DistanceControllerInput_Raw_overtakeBoostRequestedByDriver(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_DistanceControllerInput_Raw_heavyRain(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Crusing_DistanceControllerInput_Raw_heavyRain(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_DistanceControllerInput_timegap(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_Crusing_DistanceControllerInput_timegap(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_DistanceControllerInput_currentAccelerationRequestedToActuators(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_Crusing_DistanceControllerInput_currentAccelerationRequestedToActuators(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_DistanceControllerInput_usedActuator(qpb_ostream_t *const stream, const SystemCore_Crusing_UsedActuator *const data);
static bool decode_SystemCore_Crusing_DistanceControllerInput_usedActuator(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_DistanceControllerInput_laneChangeIndicatedByDriver(qpb_ostream_t *const stream, const SystemCore_Crusing_LateralDirection *const data);
static bool decode_SystemCore_Crusing_DistanceControllerInput_laneChangeIndicatedByDriver(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_DistanceControllerInput_overtakeBoostRequestedByDriver(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Crusing_DistanceControllerInput_overtakeBoostRequestedByDriver(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_DistanceControllerInput_heavyRain(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Crusing_DistanceControllerInput_heavyRain(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_IndicatedSpeed_Raw_speed(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_SystemCore_Crusing_IndicatedSpeed_Raw_speed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_IndicatedSpeed_Raw_unit(qpb_ostream_t *const stream, const SystemCore_Crusing_SpeedUnit *const data);
static bool decode_SystemCore_Crusing_IndicatedSpeed_Raw_unit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_SetSpeedControllerInput_Raw_setSpeed(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_SystemCore_Crusing_SetSpeedControllerInput_Raw_setSpeed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_SetSpeedControllerInput_Raw_setSpeedChangedBy(qpb_ostream_t *const stream, const SystemCore_Crusing_ChangedBy *const data);
static bool decode_SystemCore_Crusing_SetSpeedControllerInput_Raw_setSpeedChangedBy(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_SetSpeedControllerInput_setSpeed(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_Crusing_SetSpeedControllerInput_setSpeed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_SetSpeedControllerInput_setSpeedChangedBy(qpb_ostream_t *const stream, const SystemCore_Crusing_ChangedBy *const data);
static bool decode_SystemCore_Crusing_SetSpeedControllerInput_setSpeedChangedBy(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_AccCommonInput_Raw_driverOverride(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Crusing_AccCommonInput_Raw_driverOverride(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_AccCommonInput_Raw_driveMode(qpb_ostream_t *const stream, const SystemCore_Crusing_AccDriveMode *const data);
static bool decode_SystemCore_Crusing_AccCommonInput_Raw_driveMode(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_AccCommonInput_Raw_roadInclination(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_SystemCore_Crusing_AccCommonInput_Raw_roadInclination(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_AccCommonInput_Raw_standstillStatus(qpb_ostream_t *const stream, const SystemCore_Crusing_StandstillStatus *const data);
static bool decode_SystemCore_Crusing_AccCommonInput_Raw_standstillStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_AccCommonInput_Raw_indicatedSpeed(qpb_ostream_t *const stream, const SystemCore_Crusing_IndicatedSpeed_Raw *const data);
static bool decode_SystemCore_Crusing_AccCommonInput_Raw_indicatedSpeed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_AccCommonInput_driverOverride(qpb_ostream_t *const stream, const bool *const data);
static bool decode_SystemCore_Crusing_AccCommonInput_driverOverride(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_AccCommonInput_driveMode(qpb_ostream_t *const stream, const SystemCore_Crusing_AccDriveMode *const data);
static bool decode_SystemCore_Crusing_AccCommonInput_driveMode(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_AccCommonInput_roadInclination(qpb_ostream_t *const stream, const float *const data);
static bool decode_SystemCore_Crusing_AccCommonInput_roadInclination(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_AccCommonInput_standstillStatus(qpb_ostream_t *const stream, const SystemCore_Crusing_StandstillStatus *const data);
static bool decode_SystemCore_Crusing_AccCommonInput_standstillStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_Crusing_AccCommonInput_indicatedSpeed(qpb_ostream_t *const stream, const SystemCore_Crusing_IndicatedSpeed *const data);
static bool decode_SystemCore_Crusing_AccCommonInput_indicatedSpeed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);

#define SystemCore_Crusing_CruisingFeatureState_Raw_DECODERS_COUNT 4
const qpb_decoder_entry_t SystemCore_Crusing_CruisingFeatureState_Raw_decoders[SystemCore_Crusing_CruisingFeatureState_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Crusing_CruisingFeatureState_Raw_csaActive },
   { &decode_SystemCore_Crusing_CruisingFeatureState_Raw_ccActive },
   { &decode_SystemCore_Crusing_CruisingFeatureState_Raw_accState }
};

#define SystemCore_Crusing_DistanceControllerInput_Raw_DECODERS_COUNT 7
const qpb_decoder_entry_t SystemCore_Crusing_DistanceControllerInput_Raw_decoders[SystemCore_Crusing_DistanceControllerInput_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Crusing_DistanceControllerInput_Raw_timegap },
   { &decode_SystemCore_Crusing_DistanceControllerInput_Raw_currentAccelerationRequestedToActuators },
   { &decode_SystemCore_Crusing_DistanceControllerInput_Raw_usedActuator },
   { &decode_SystemCore_Crusing_DistanceControllerInput_Raw_laneChangeIndicatedByDriver },
   { &decode_SystemCore_Crusing_DistanceControllerInput_Raw_overtakeBoostRequestedByDriver },
   { &decode_SystemCore_Crusing_DistanceControllerInput_Raw_heavyRain }
};

#define SystemCore_Crusing_DistanceControllerInput_DECODERS_COUNT 7
const qpb_decoder_entry_t SystemCore_Crusing_DistanceControllerInput_decoders[SystemCore_Crusing_DistanceControllerInput_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Crusing_DistanceControllerInput_timegap },
   { &decode_SystemCore_Crusing_DistanceControllerInput_currentAccelerationRequestedToActuators },
   { &decode_SystemCore_Crusing_DistanceControllerInput_usedActuator },
   { &decode_SystemCore_Crusing_DistanceControllerInput_laneChangeIndicatedByDriver },
   { &decode_SystemCore_Crusing_DistanceControllerInput_overtakeBoostRequestedByDriver },
   { &decode_SystemCore_Crusing_DistanceControllerInput_heavyRain }
};

#define SystemCore_Crusing_IndicatedSpeed_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_Crusing_IndicatedSpeed_Raw_decoders[SystemCore_Crusing_IndicatedSpeed_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Crusing_IndicatedSpeed_Raw_speed },
   { &decode_SystemCore_Crusing_IndicatedSpeed_Raw_unit }
};

#define SystemCore_Crusing_SetSpeedControllerInput_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_Crusing_SetSpeedControllerInput_Raw_decoders[SystemCore_Crusing_SetSpeedControllerInput_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Crusing_SetSpeedControllerInput_Raw_setSpeed },
   { &decode_SystemCore_Crusing_SetSpeedControllerInput_Raw_setSpeedChangedBy }
};

#define SystemCore_Crusing_SetSpeedControllerInput_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_Crusing_SetSpeedControllerInput_decoders[SystemCore_Crusing_SetSpeedControllerInput_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Crusing_SetSpeedControllerInput_setSpeed },
   { &decode_SystemCore_Crusing_SetSpeedControllerInput_setSpeedChangedBy }
};

#define SystemCore_Crusing_AccCommonInput_Raw_DECODERS_COUNT 6
const qpb_decoder_entry_t SystemCore_Crusing_AccCommonInput_Raw_decoders[SystemCore_Crusing_AccCommonInput_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Crusing_AccCommonInput_Raw_driverOverride },
   { &decode_SystemCore_Crusing_AccCommonInput_Raw_driveMode },
   { &decode_SystemCore_Crusing_AccCommonInput_Raw_roadInclination },
   { &decode_SystemCore_Crusing_AccCommonInput_Raw_standstillStatus },
   { &decode_SystemCore_Crusing_AccCommonInput_Raw_indicatedSpeed }
};

#define SystemCore_Crusing_AccCommonInput_DECODERS_COUNT 6
const qpb_decoder_entry_t SystemCore_Crusing_AccCommonInput_decoders[SystemCore_Crusing_AccCommonInput_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_Crusing_AccCommonInput_driverOverride },
   { &decode_SystemCore_Crusing_AccCommonInput_driveMode },
   { &decode_SystemCore_Crusing_AccCommonInput_roadInclination },
   { &decode_SystemCore_Crusing_AccCommonInput_standstillStatus },
   { &decode_SystemCore_Crusing_AccCommonInput_indicatedSpeed }
};

static inline void encode_SystemCore_Crusing_CruisingFeatureState_Raw_csaActive(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_CruisingFeatureState_Raw_csaActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_CruisingFeatureState_Raw*)data)->csaActive, sizeof(bool));
}

static inline void encode_SystemCore_Crusing_CruisingFeatureState_Raw_ccActive(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_CruisingFeatureState_Raw_ccActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_CruisingFeatureState_Raw*)data)->ccActive, sizeof(bool));
}

static inline void encode_SystemCore_Crusing_CruisingFeatureState_Raw_accState(qpb_ostream_t *const stream, const SystemCore_Crusing_AccState *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_CruisingFeatureState_Raw_accState(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_CruisingFeatureState_Raw*)data)->accState, qpb_membersize(SystemCore_Crusing_CruisingFeatureState_Raw, accState));
}

static inline void encode_SystemCore_Crusing_DistanceControllerInput_Raw_timegap(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_DistanceControllerInput_Raw_timegap(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_Crusing_DistanceControllerInput_Raw*)data)->timegap, sizeof(uint8_t));
}

static inline void encode_SystemCore_Crusing_DistanceControllerInput_Raw_currentAccelerationRequestedToActuators(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_DistanceControllerInput_Raw_currentAccelerationRequestedToActuators(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_Crusing_DistanceControllerInput_Raw*)data)->currentAccelerationRequestedToActuators, sizeof(int16_t));
}

static inline void encode_SystemCore_Crusing_DistanceControllerInput_Raw_usedActuator(qpb_ostream_t *const stream, const SystemCore_Crusing_UsedActuator *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_DistanceControllerInput_Raw_usedActuator(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_DistanceControllerInput_Raw*)data)->usedActuator, qpb_membersize(SystemCore_Crusing_DistanceControllerInput_Raw, usedActuator));
}

static inline void encode_SystemCore_Crusing_DistanceControllerInput_Raw_laneChangeIndicatedByDriver(qpb_ostream_t *const stream, const SystemCore_Crusing_LateralDirection *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_DistanceControllerInput_Raw_laneChangeIndicatedByDriver(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_DistanceControllerInput_Raw*)data)->laneChangeIndicatedByDriver, qpb_membersize(SystemCore_Crusing_DistanceControllerInput_Raw, laneChangeIndicatedByDriver));
}

static inline void encode_SystemCore_Crusing_DistanceControllerInput_Raw_overtakeBoostRequestedByDriver(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_DistanceControllerInput_Raw_overtakeBoostRequestedByDriver(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_DistanceControllerInput_Raw*)data)->overtakeBoostRequestedByDriver, sizeof(bool));
}

static inline void encode_SystemCore_Crusing_DistanceControllerInput_Raw_heavyRain(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_DistanceControllerInput_Raw_heavyRain(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_DistanceControllerInput_Raw*)data)->heavyRain, sizeof(bool));
}

static inline void encode_SystemCore_Crusing_DistanceControllerInput_timegap(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_DistanceControllerInput_timegap(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_Crusing_DistanceControllerInput*)data)->timegap, sizeof(uint8_t));
}

static inline void encode_SystemCore_Crusing_DistanceControllerInput_currentAccelerationRequestedToActuators(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_SystemCore_Crusing_DistanceControllerInput_Raw_currentAccelerationRequestedToActuators(stream, &value);
}

static bool decode_SystemCore_Crusing_DistanceControllerInput_currentAccelerationRequestedToActuators(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((SystemCore_Crusing_DistanceControllerInput*)data)->currentAccelerationRequestedToActuators = value * F_0_01;
   return result;
}

static inline void encode_SystemCore_Crusing_DistanceControllerInput_usedActuator(qpb_ostream_t *const stream, const SystemCore_Crusing_UsedActuator *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_DistanceControllerInput_usedActuator(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_DistanceControllerInput*)data)->usedActuator, qpb_membersize(SystemCore_Crusing_DistanceControllerInput, usedActuator));
}

static inline void encode_SystemCore_Crusing_DistanceControllerInput_laneChangeIndicatedByDriver(qpb_ostream_t *const stream, const SystemCore_Crusing_LateralDirection *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_DistanceControllerInput_laneChangeIndicatedByDriver(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_DistanceControllerInput*)data)->laneChangeIndicatedByDriver, qpb_membersize(SystemCore_Crusing_DistanceControllerInput, laneChangeIndicatedByDriver));
}

static inline void encode_SystemCore_Crusing_DistanceControllerInput_overtakeBoostRequestedByDriver(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_DistanceControllerInput_overtakeBoostRequestedByDriver(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_DistanceControllerInput*)data)->overtakeBoostRequestedByDriver, sizeof(bool));
}

static inline void encode_SystemCore_Crusing_DistanceControllerInput_heavyRain(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_DistanceControllerInput_heavyRain(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_DistanceControllerInput*)data)->heavyRain, sizeof(bool));
}

static inline void encode_SystemCore_Crusing_IndicatedSpeed_Raw_speed(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_IndicatedSpeed_Raw_speed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_Crusing_IndicatedSpeed_Raw*)data)->speed, sizeof(uint8_t));
}

static inline void encode_SystemCore_Crusing_IndicatedSpeed_Raw_unit(qpb_ostream_t *const stream, const SystemCore_Crusing_SpeedUnit *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_IndicatedSpeed_Raw_unit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_IndicatedSpeed_Raw*)data)->unit, qpb_membersize(SystemCore_Crusing_IndicatedSpeed_Raw, unit));
}

static inline void encode_SystemCore_Crusing_SetSpeedControllerInput_Raw_setSpeed(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_SetSpeedControllerInput_Raw_setSpeed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_Crusing_SetSpeedControllerInput_Raw*)data)->setSpeed, sizeof(uint16_t));
}

static inline void encode_SystemCore_Crusing_SetSpeedControllerInput_Raw_setSpeedChangedBy(qpb_ostream_t *const stream, const SystemCore_Crusing_ChangedBy *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_SetSpeedControllerInput_Raw_setSpeedChangedBy(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_SetSpeedControllerInput_Raw*)data)->setSpeedChangedBy, qpb_membersize(SystemCore_Crusing_SetSpeedControllerInput_Raw, setSpeedChangedBy));
}

static inline void encode_SystemCore_Crusing_SetSpeedControllerInput_setSpeed(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_1, 0, UINT16_MAX);
   encode_SystemCore_Crusing_SetSpeedControllerInput_Raw_setSpeed(stream, &value);
}

static bool decode_SystemCore_Crusing_SetSpeedControllerInput_setSpeed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((SystemCore_Crusing_SetSpeedControllerInput*)data)->setSpeed = value * F_0_1;
   return result;
}

static inline void encode_SystemCore_Crusing_SetSpeedControllerInput_setSpeedChangedBy(qpb_ostream_t *const stream, const SystemCore_Crusing_ChangedBy *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_SetSpeedControllerInput_setSpeedChangedBy(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_SetSpeedControllerInput*)data)->setSpeedChangedBy, qpb_membersize(SystemCore_Crusing_SetSpeedControllerInput, setSpeedChangedBy));
}

static inline void encode_SystemCore_Crusing_AccCommonInput_Raw_driverOverride(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_AccCommonInput_Raw_driverOverride(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_AccCommonInput_Raw*)data)->driverOverride, sizeof(bool));
}

static inline void encode_SystemCore_Crusing_AccCommonInput_Raw_driveMode(qpb_ostream_t *const stream, const SystemCore_Crusing_AccDriveMode *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_AccCommonInput_Raw_driveMode(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_AccCommonInput_Raw*)data)->driveMode, qpb_membersize(SystemCore_Crusing_AccCommonInput_Raw, driveMode));
}

static inline void encode_SystemCore_Crusing_AccCommonInput_Raw_roadInclination(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_AccCommonInput_Raw_roadInclination(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((SystemCore_Crusing_AccCommonInput_Raw*)data)->roadInclination, sizeof(int32_t));
}

static inline void encode_SystemCore_Crusing_AccCommonInput_Raw_standstillStatus(qpb_ostream_t *const stream, const SystemCore_Crusing_StandstillStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_AccCommonInput_Raw_standstillStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_AccCommonInput_Raw*)data)->standstillStatus, qpb_membersize(SystemCore_Crusing_AccCommonInput_Raw, standstillStatus));
}

static inline void encode_SystemCore_Crusing_AccCommonInput_Raw_indicatedSpeed(qpb_ostream_t *const stream, const SystemCore_Crusing_IndicatedSpeed_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 42;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_Crusing_IndicatedSpeed_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_Crusing_AccCommonInput_Raw_indicatedSpeed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_Crusing_IndicatedSpeed_Raw(&substream, &((SystemCore_Crusing_AccCommonInput_Raw*)data)->indicatedSpeed);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_SystemCore_Crusing_AccCommonInput_driverOverride(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_AccCommonInput_driverOverride(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_AccCommonInput*)data)->driverOverride, sizeof(bool));
}

static inline void encode_SystemCore_Crusing_AccCommonInput_driveMode(qpb_ostream_t *const stream, const SystemCore_Crusing_AccDriveMode *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_AccCommonInput_driveMode(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_AccCommonInput*)data)->driveMode, qpb_membersize(SystemCore_Crusing_AccCommonInput, driveMode));
}

static inline void encode_SystemCore_Crusing_AccCommonInput_roadInclination(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_005, INT32_MIN, INT32_MAX);
   encode_SystemCore_Crusing_AccCommonInput_Raw_roadInclination(stream, &value);
}

static bool decode_SystemCore_Crusing_AccCommonInput_roadInclination(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((SystemCore_Crusing_AccCommonInput*)data)->roadInclination = value * F_0_005;
   return result;
}

static inline void encode_SystemCore_Crusing_AccCommonInput_standstillStatus(qpb_ostream_t *const stream, const SystemCore_Crusing_StandstillStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_Crusing_AccCommonInput_standstillStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_Crusing_AccCommonInput*)data)->standstillStatus, qpb_membersize(SystemCore_Crusing_AccCommonInput, standstillStatus));
}

static inline void encode_SystemCore_Crusing_AccCommonInput_indicatedSpeed(qpb_ostream_t *const stream, const SystemCore_Crusing_IndicatedSpeed *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 42;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_SystemCore_Crusing_IndicatedSpeed(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_SystemCore_Crusing_AccCommonInput_indicatedSpeed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_SystemCore_Crusing_IndicatedSpeed(&substream, &((SystemCore_Crusing_AccCommonInput*)data)->indicatedSpeed);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

/* Encoding / decoding functions */
bool encode_SystemCore_Crusing_CruisingFeatureState_Raw(qpb_ostream_t *const stream, const SystemCore_Crusing_CruisingFeatureState_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Crusing_CruisingFeatureState_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Crusing_CruisingFeatureState_Raw_csaActive(stream, &data->csaActive);
   encode_SystemCore_Crusing_CruisingFeatureState_Raw_ccActive(stream, &data->ccActive);
   encode_SystemCore_Crusing_CruisingFeatureState_Raw_accState(stream, &data->accState);
   return true;
}

bool decode_SystemCore_Crusing_CruisingFeatureState_Raw(qpb_istream_t *const stream, SystemCore_Crusing_CruisingFeatureState_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Crusing_CruisingFeatureState_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Crusing_CruisingFeatureState_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_Crusing_DistanceControllerInput_Raw(qpb_ostream_t *const stream, const SystemCore_Crusing_DistanceControllerInput_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Crusing_DistanceControllerInput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Crusing_DistanceControllerInput_Raw_timegap(stream, &data->timegap);
   encode_SystemCore_Crusing_DistanceControllerInput_Raw_currentAccelerationRequestedToActuators(stream, &data->currentAccelerationRequestedToActuators);
   encode_SystemCore_Crusing_DistanceControllerInput_Raw_usedActuator(stream, &data->usedActuator);
   encode_SystemCore_Crusing_DistanceControllerInput_Raw_laneChangeIndicatedByDriver(stream, &data->laneChangeIndicatedByDriver);
   encode_SystemCore_Crusing_DistanceControllerInput_Raw_overtakeBoostRequestedByDriver(stream, &data->overtakeBoostRequestedByDriver);
   encode_SystemCore_Crusing_DistanceControllerInput_Raw_heavyRain(stream, &data->heavyRain);
   return true;
}

bool decode_SystemCore_Crusing_DistanceControllerInput_Raw(qpb_istream_t *const stream, SystemCore_Crusing_DistanceControllerInput_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Crusing_DistanceControllerInput_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Crusing_DistanceControllerInput_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_Crusing_DistanceControllerInput(qpb_ostream_t *const stream, const SystemCore_Crusing_DistanceControllerInput *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Crusing_DistanceControllerInput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Crusing_DistanceControllerInput_Raw_timegap(stream, &data->timegap);
   encode_SystemCore_Crusing_DistanceControllerInput_currentAccelerationRequestedToActuators(stream, &data->currentAccelerationRequestedToActuators);
   encode_SystemCore_Crusing_DistanceControllerInput_Raw_usedActuator(stream, &data->usedActuator);
   encode_SystemCore_Crusing_DistanceControllerInput_Raw_laneChangeIndicatedByDriver(stream, &data->laneChangeIndicatedByDriver);
   encode_SystemCore_Crusing_DistanceControllerInput_Raw_overtakeBoostRequestedByDriver(stream, &data->overtakeBoostRequestedByDriver);
   encode_SystemCore_Crusing_DistanceControllerInput_Raw_heavyRain(stream, &data->heavyRain);
   return true;
}

bool decode_SystemCore_Crusing_DistanceControllerInput(qpb_istream_t *const stream, SystemCore_Crusing_DistanceControllerInput *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Crusing_DistanceControllerInput_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Crusing_DistanceControllerInput_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_Crusing_IndicatedSpeed_Raw(qpb_ostream_t *const stream, const SystemCore_Crusing_IndicatedSpeed_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Crusing_IndicatedSpeed_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Crusing_IndicatedSpeed_Raw_speed(stream, &data->speed);
   encode_SystemCore_Crusing_IndicatedSpeed_Raw_unit(stream, &data->unit);
   return true;
}

bool decode_SystemCore_Crusing_IndicatedSpeed_Raw(qpb_istream_t *const stream, SystemCore_Crusing_IndicatedSpeed_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Crusing_IndicatedSpeed_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Crusing_IndicatedSpeed_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_Crusing_SetSpeedControllerInput_Raw(qpb_ostream_t *const stream, const SystemCore_Crusing_SetSpeedControllerInput_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Crusing_SetSpeedControllerInput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Crusing_SetSpeedControllerInput_Raw_setSpeed(stream, &data->setSpeed);
   encode_SystemCore_Crusing_SetSpeedControllerInput_Raw_setSpeedChangedBy(stream, &data->setSpeedChangedBy);
   return true;
}

bool decode_SystemCore_Crusing_SetSpeedControllerInput_Raw(qpb_istream_t *const stream, SystemCore_Crusing_SetSpeedControllerInput_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Crusing_SetSpeedControllerInput_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Crusing_SetSpeedControllerInput_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_Crusing_SetSpeedControllerInput(qpb_ostream_t *const stream, const SystemCore_Crusing_SetSpeedControllerInput *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Crusing_SetSpeedControllerInput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Crusing_SetSpeedControllerInput_setSpeed(stream, &data->setSpeed);
   encode_SystemCore_Crusing_SetSpeedControllerInput_Raw_setSpeedChangedBy(stream, &data->setSpeedChangedBy);
   return true;
}

bool decode_SystemCore_Crusing_SetSpeedControllerInput(qpb_istream_t *const stream, SystemCore_Crusing_SetSpeedControllerInput *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Crusing_SetSpeedControllerInput_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Crusing_SetSpeedControllerInput_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_Crusing_AccCommonInput_Raw(qpb_ostream_t *const stream, const SystemCore_Crusing_AccCommonInput_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Crusing_AccCommonInput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Crusing_AccCommonInput_Raw_driverOverride(stream, &data->driverOverride);
   encode_SystemCore_Crusing_AccCommonInput_Raw_driveMode(stream, &data->driveMode);
   encode_SystemCore_Crusing_AccCommonInput_Raw_roadInclination(stream, &data->roadInclination);
   encode_SystemCore_Crusing_AccCommonInput_Raw_standstillStatus(stream, &data->standstillStatus);
   encode_SystemCore_Crusing_AccCommonInput_Raw_indicatedSpeed(stream, &data->indicatedSpeed);
   return true;
}

bool decode_SystemCore_Crusing_AccCommonInput_Raw(qpb_istream_t *const stream, SystemCore_Crusing_AccCommonInput_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Crusing_AccCommonInput_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Crusing_AccCommonInput_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_Crusing_AccCommonInput(qpb_ostream_t *const stream, const SystemCore_Crusing_AccCommonInput *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_Crusing_AccCommonInput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_Crusing_AccCommonInput_Raw_driverOverride(stream, &data->driverOverride);
   encode_SystemCore_Crusing_AccCommonInput_Raw_driveMode(stream, &data->driveMode);
   encode_SystemCore_Crusing_AccCommonInput_roadInclination(stream, &data->roadInclination);
   encode_SystemCore_Crusing_AccCommonInput_Raw_standstillStatus(stream, &data->standstillStatus);
   encode_SystemCore_Crusing_AccCommonInput_indicatedSpeed(stream, &data->indicatedSpeed);
   return true;
}

bool decode_SystemCore_Crusing_AccCommonInput(qpb_istream_t *const stream, SystemCore_Crusing_AccCommonInput *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_Crusing_AccCommonInput_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_Crusing_AccCommonInput_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

