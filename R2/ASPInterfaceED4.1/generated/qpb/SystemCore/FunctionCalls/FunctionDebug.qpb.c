/* Automatically generated qpb constant definitions */
/* Generated by Quick Protocol Buffers - 2 */

#include "SystemCore/FunctionCalls/FunctionDebug.qpb.h"
#include "Tools/QuickProtobuf/qpb_decode.h"
#include "Tools/QuickProtobuf/qpb_encode.h"

#if QPB_PROTO_HEADER_VERSION != 2
#error Regenerate this file with the current version of qpb generator.
#endif

static inline void encode_SystemCore_FunctionCalls_FunctionCallLink_Raw_identifier(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_SystemCore_FunctionCalls_FunctionCallLink_Raw_identifier(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_FunctionCalls_FunctionCallLink_Raw_functionCallName(qpb_ostream_t *const stream, const char *const data);
static bool decode_SystemCore_FunctionCalls_FunctionCallLink_Raw_functionCallName(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_FunctionCalls_InputData_Raw_dataSource(qpb_ostream_t *const stream, const DataSource *const data);
static bool decode_SystemCore_FunctionCalls_InputData_Raw_dataSource(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_FunctionCalls_InputData_Raw_dataIdentifier(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_SystemCore_FunctionCalls_InputData_Raw_dataIdentifier(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_FunctionCalls_InputData_Raw_frameNumber(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_SystemCore_FunctionCalls_InputData_Raw_frameNumber(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_FunctionCalls_InputData_Raw_timestamp(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_SystemCore_FunctionCalls_InputData_Raw_timestamp(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_FunctionCalls_FunctionCallLinks_Raw_functionCallLinks(qpb_ostream_t *const stream, const SystemCore_FunctionCalls_FunctionCallLink_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_FunctionCalls_FunctionCallLinks_Raw_functionCallLinks(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_FunctionCalls_FunctionExecution_Raw_functionCallIdentifier(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_SystemCore_FunctionCalls_FunctionExecution_Raw_functionCallIdentifier(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_SystemCore_FunctionCalls_FunctionExecution_Raw_inputData(qpb_ostream_t *const stream, const SystemCore_FunctionCalls_InputData_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_SystemCore_FunctionCalls_FunctionExecution_Raw_inputData(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);

#define SystemCore_FunctionCalls_FunctionCallLink_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t SystemCore_FunctionCalls_FunctionCallLink_Raw_decoders[SystemCore_FunctionCalls_FunctionCallLink_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_FunctionCalls_FunctionCallLink_Raw_identifier },
   { &decode_SystemCore_FunctionCalls_FunctionCallLink_Raw_functionCallName }
};

#define SystemCore_FunctionCalls_InputData_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t SystemCore_FunctionCalls_InputData_Raw_decoders[SystemCore_FunctionCalls_InputData_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_FunctionCalls_InputData_Raw_dataSource },
   { &decode_SystemCore_FunctionCalls_InputData_Raw_dataIdentifier },
   { &decode_SystemCore_FunctionCalls_InputData_Raw_frameNumber },
   { &decode_SystemCore_FunctionCalls_InputData_Raw_timestamp }
};

#define SystemCore_FunctionCalls_FunctionCallLinks_Raw_DECODERS_COUNT 2
const qpb_decoder_entry_t SystemCore_FunctionCalls_FunctionCallLinks_Raw_decoders[SystemCore_FunctionCalls_FunctionCallLinks_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_FunctionCalls_FunctionCallLinks_Raw_functionCallLinks }
};

#define SystemCore_FunctionCalls_FunctionExecution_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t SystemCore_FunctionCalls_FunctionExecution_Raw_decoders[SystemCore_FunctionCalls_FunctionExecution_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_SystemCore_FunctionCalls_FunctionExecution_Raw_functionCallIdentifier },
   { &qpb_skip_field },
   { &qpb_skip_field },
   { &decode_SystemCore_FunctionCalls_FunctionExecution_Raw_inputData }
};

static inline void encode_SystemCore_FunctionCalls_FunctionCallLink_Raw_identifier(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_FunctionCalls_FunctionCallLink_Raw_identifier(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_FunctionCalls_FunctionCallLink_Raw*)data)->identifier, sizeof(uint32_t));
}

static inline void encode_SystemCore_FunctionCalls_FunctionCallLink_Raw_functionCallName(qpb_ostream_t *const stream, const char *const data)
{
   qpb_size_t strSize = strlen(data);
   if (strSize != 0)
   {
      *stream->buffer = 18;
      ++stream->buffer;
      qpb_encode_bytes(stream, (qpb_byte_t*)data, strSize);
   }
}

static bool decode_SystemCore_FunctionCalls_FunctionCallLink_Raw_functionCallName(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_string_static(stream, ((SystemCore_FunctionCalls_FunctionCallLink_Raw*)data)->functionCallName, 49);
}

static inline void encode_SystemCore_FunctionCalls_InputData_Raw_dataSource(qpb_ostream_t *const stream, const DataSource *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_SystemCore_FunctionCalls_InputData_Raw_dataSource(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((SystemCore_FunctionCalls_InputData_Raw*)data)->dataSource, qpb_membersize(SystemCore_FunctionCalls_InputData_Raw, dataSource));
}

static inline void encode_SystemCore_FunctionCalls_InputData_Raw_dataIdentifier(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_FunctionCalls_InputData_Raw_dataIdentifier(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_FunctionCalls_InputData_Raw*)data)->dataIdentifier, sizeof(uint32_t));
}

static inline void encode_SystemCore_FunctionCalls_InputData_Raw_frameNumber(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_FunctionCalls_InputData_Raw_frameNumber(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_FunctionCalls_InputData_Raw*)data)->frameNumber, sizeof(uint32_t));
}

static inline void encode_SystemCore_FunctionCalls_InputData_Raw_timestamp(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_FunctionCalls_InputData_Raw_timestamp(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_FunctionCalls_InputData_Raw*)data)->timestamp, sizeof(uint32_t));
}

static inline void encode_SystemCore_FunctionCalls_FunctionCallLinks_Raw_functionCallLinks(qpb_ostream_t *const stream, const SystemCore_FunctionCalls_FunctionCallLink_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 10;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_FunctionCalls_FunctionCallLink_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_FunctionCalls_FunctionCallLinks_Raw_functionCallLinks(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_FunctionCalls_FunctionCallLinks_Raw*)data)->functionCallLinks_count + 1) > 20)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_FunctionCalls_FunctionCallLink_Raw(&substream, &((SystemCore_FunctionCalls_FunctionCallLinks_Raw*)data)->functionCallLinks[((SystemCore_FunctionCalls_FunctionCallLinks_Raw*)data)->functionCallLinks_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_SystemCore_FunctionCalls_FunctionExecution_Raw_functionCallIdentifier(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_SystemCore_FunctionCalls_FunctionExecution_Raw_functionCallIdentifier(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((SystemCore_FunctionCalls_FunctionExecution_Raw*)data)->functionCallIdentifier, sizeof(uint32_t));
}

static inline void encode_SystemCore_FunctionCalls_FunctionExecution_Raw_inputData(qpb_ostream_t *const stream, const SystemCore_FunctionCalls_InputData_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 34;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_SystemCore_FunctionCalls_InputData_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_SystemCore_FunctionCalls_FunctionExecution_Raw_inputData(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((SystemCore_FunctionCalls_FunctionExecution_Raw*)data)->inputData_count + 1) > 30)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_SystemCore_FunctionCalls_InputData_Raw(&substream, &((SystemCore_FunctionCalls_FunctionExecution_Raw*)data)->inputData[((SystemCore_FunctionCalls_FunctionExecution_Raw*)data)->inputData_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

/* Encoding / decoding functions */
bool encode_SystemCore_FunctionCalls_FunctionCallLink_Raw(qpb_ostream_t *const stream, const SystemCore_FunctionCalls_FunctionCallLink_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_FunctionCalls_FunctionCallLink_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_FunctionCalls_FunctionCallLink_Raw_identifier(stream, &data->identifier);
   encode_SystemCore_FunctionCalls_FunctionCallLink_Raw_functionCallName(stream, data->functionCallName);
   return true;
}

bool decode_SystemCore_FunctionCalls_FunctionCallLink_Raw(qpb_istream_t *const stream, SystemCore_FunctionCalls_FunctionCallLink_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_FunctionCalls_FunctionCallLink_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_FunctionCalls_FunctionCallLink_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_FunctionCalls_InputData_Raw(qpb_ostream_t *const stream, const SystemCore_FunctionCalls_InputData_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_FunctionCalls_InputData_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_FunctionCalls_InputData_Raw_dataSource(stream, &data->dataSource);
   encode_SystemCore_FunctionCalls_InputData_Raw_dataIdentifier(stream, &data->dataIdentifier);
   encode_SystemCore_FunctionCalls_InputData_Raw_frameNumber(stream, &data->frameNumber);
   encode_SystemCore_FunctionCalls_InputData_Raw_timestamp(stream, &data->timestamp);
   return true;
}

bool decode_SystemCore_FunctionCalls_InputData_Raw(qpb_istream_t *const stream, SystemCore_FunctionCalls_InputData_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_FunctionCalls_InputData_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_FunctionCalls_InputData_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_FunctionCalls_FunctionCallLinks_Raw(qpb_ostream_t *const stream, const SystemCore_FunctionCalls_FunctionCallLinks_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_FunctionCalls_FunctionCallLinks_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_FunctionCalls_FunctionCallLinks_Raw_functionCallLinks(stream, data->functionCallLinks, data->functionCallLinks_count);
   return true;
}

bool decode_SystemCore_FunctionCalls_FunctionCallLinks_Raw(qpb_istream_t *const stream, SystemCore_FunctionCalls_FunctionCallLinks_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_FunctionCalls_FunctionCallLinks_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_FunctionCalls_FunctionCallLinks_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_SystemCore_FunctionCalls_FunctionExecution_Raw(qpb_ostream_t *const stream, const SystemCore_FunctionCalls_FunctionExecution_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < SystemCore_FunctionCalls_FunctionExecution_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_SystemCore_FunctionCalls_FunctionExecution_Raw_functionCallIdentifier(stream, &data->functionCallIdentifier);
   encode_SystemCore_FunctionCalls_FunctionExecution_Raw_inputData(stream, data->inputData, data->inputData_count);
   return true;
}

bool decode_SystemCore_FunctionCalls_FunctionExecution_Raw(qpb_istream_t *const stream, SystemCore_FunctionCalls_FunctionExecution_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < SystemCore_FunctionCalls_FunctionExecution_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = SystemCore_FunctionCalls_FunctionExecution_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

