/* Automatically generated qpb constant definitions */
/* Generated by Quick Protocol Buffers - 2 */

#include "VisionCore/TrafficParticipants/ObjectsOutput.qpb.h"
#include "Tools/QuickProtobuf/qpb_decode.h"
#include "Tools/QuickProtobuf/qpb_encode.h"
#include "Tools/CSupport/ConversionSupport.h"

#if QPB_PROTO_HEADER_VERSION != 2
#error Regenerate this file with the current version of qpb generator.
#endif

#define F_0_01               0.01f
#define F_0_02               0.02f
#define F_0_1                0.1f
#define F_0_2                0.2f

static inline void encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeft(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeft(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeftStdDev(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeftStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeftRate(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeftRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRight(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRight(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRightStdDev(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRightStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRightRate(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRightRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneAssignment(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectLaneAssignment *const data);
static bool decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneAssignment(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeft(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeft(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeftStdDev(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeftStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeftRate(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeftRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRight(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRight(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRightStdDev(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRightStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRightRate(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRightRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_LaneProperties_laneAssignment(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectLaneAssignment *const data);
static bool decode_VisionCore_TrafficParticipants_LaneProperties_laneAssignment(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw_xAcceleration(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw_xAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw_xAccelerationStdDev(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw_xAccelerationStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectAcceleration_xAcceleration(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectAcceleration_xAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectAcceleration_xAccelerationStdDev(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectAcceleration_xAccelerationStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_x(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_x(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_xStdDev(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_xStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_y(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_y(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yStdDev(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_xyCorrCoeff(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_xyCorrCoeff(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_z(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_z(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_zStdDev(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_zStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yawAngle(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yawAngle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yawAngleStdDev(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yawAngleStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_x(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_x(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_xStdDev(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_xStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_y(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_y(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_yStdDev(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_yStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_xyCorrCoeff(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_xyCorrCoeff(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_z(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_z(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_zStdDev(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_zStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_yawAngle(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_yawAngle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_yawAngleStdDev(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectPosition_yawAngleStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_classificationConfidence(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_classificationConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_detectionConfidence(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_detectionConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_classificationHistory(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_classificationHistory(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_detectionHistory(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_detectionHistory(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackingStatus(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectTrackingStatus *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackingStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackAge(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackAge(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackDelay(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackDelay(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_objectStatus(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectQualityStatus *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_objectStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectSize_Raw_height(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectSize_Raw_height(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectSize_Raw_heightStdDev(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectSize_Raw_heightStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectSize_Raw_width(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectSize_Raw_width(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectSize_Raw_widthStdDev(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectSize_Raw_widthStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectSize_Raw_length(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectSize_Raw_length(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectSize_Raw_lengthStdDev(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectSize_Raw_lengthStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectSize_height(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectSize_height(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectSize_heightStdDev(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectSize_heightStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectSize_width(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectSize_width(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectSize_widthStdDev(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectSize_widthStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectSize_length(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectSize_length(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectSize_lengthStdDev(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectSize_lengthStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_xVelocity(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_xVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yVelocity(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_xVelocityStdDev(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_xVelocityStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yVelocityStdDev(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yVelocityStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yawRate(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yawRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_xVelocity(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_xVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_yVelocity(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_yVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_xVelocityStdDev(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_xVelocityStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_yVelocityStdDev(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_yVelocityStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_yawRate(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_yawRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectVisibility_Raw_leftEdgeVisibility(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectEdgeVisibility *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectVisibility_Raw_leftEdgeVisibility(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectVisibility_Raw_rightEdgeVisibility(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectEdgeVisibility *const data);
static bool decode_VisionCore_TrafficParticipants_ObjectVisibility_Raw_rightEdgeVisibility(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_Raw_id(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_Object_Raw_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_Raw_objectClass(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectClass *const data);
static bool decode_VisionCore_TrafficParticipants_Object_Raw_objectClass(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_Raw_motionMode(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectMotionMode *const data);
static bool decode_VisionCore_TrafficParticipants_Object_Raw_motionMode(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_Raw_objectPose(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectPose *const data);
static bool decode_VisionCore_TrafficParticipants_Object_Raw_objectPose(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_Raw_positionAclc(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectPosition_Raw *const data);
static bool decode_VisionCore_TrafficParticipants_Object_Raw_positionAclc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_Raw_velocityAclc(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectVelocity_Raw *const data);
static bool decode_VisionCore_TrafficParticipants_Object_Raw_velocityAclc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_Raw_accelerationAclc(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectAcceleration_Raw *const data);
static bool decode_VisionCore_TrafficParticipants_Object_Raw_accelerationAclc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_Raw_size(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectSize_Raw *const data);
static bool decode_VisionCore_TrafficParticipants_Object_Raw_size(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_Raw_laneProperties(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_LaneProperties_Raw *const data);
static bool decode_VisionCore_TrafficParticipants_Object_Raw_laneProperties(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_Raw_quality(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectQuality_Raw *const data);
static bool decode_VisionCore_TrafficParticipants_Object_Raw_quality(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_Raw_visibility(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectVisibility_Raw *const data);
static bool decode_VisionCore_TrafficParticipants_Object_Raw_visibility(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_Raw_existsStereoMeasurement(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_TrafficParticipants_Object_Raw_existsStereoMeasurement(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_Raw_existsClusterMeasurement(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_TrafficParticipants_Object_Raw_existsClusterMeasurement(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_Raw_blockageRegionIds(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_VisionCore_TrafficParticipants_Object_Raw_blockageRegionIds(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_Raw_turnIndicatorStatus(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectTurnIndicatorStatus *const data);
static bool decode_VisionCore_TrafficParticipants_Object_Raw_turnIndicatorStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_Raw_verificationStatus(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_VisionCore_TrafficParticipants_Object_Raw_verificationStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_id(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficParticipants_Object_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_objectClass(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectClass *const data);
static bool decode_VisionCore_TrafficParticipants_Object_objectClass(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_motionMode(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectMotionMode *const data);
static bool decode_VisionCore_TrafficParticipants_Object_motionMode(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_objectPose(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectPose *const data);
static bool decode_VisionCore_TrafficParticipants_Object_objectPose(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_positionAclc(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectPosition *const data);
static bool decode_VisionCore_TrafficParticipants_Object_positionAclc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_velocityAclc(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectVelocity *const data);
static bool decode_VisionCore_TrafficParticipants_Object_velocityAclc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_accelerationAclc(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectAcceleration *const data);
static bool decode_VisionCore_TrafficParticipants_Object_accelerationAclc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_size(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectSize *const data);
static bool decode_VisionCore_TrafficParticipants_Object_size(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_laneProperties(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_LaneProperties *const data);
static bool decode_VisionCore_TrafficParticipants_Object_laneProperties(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_quality(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectQuality *const data);
static bool decode_VisionCore_TrafficParticipants_Object_quality(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_visibility(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectVisibility *const data);
static bool decode_VisionCore_TrafficParticipants_Object_visibility(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_existsStereoMeasurement(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_TrafficParticipants_Object_existsStereoMeasurement(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_existsClusterMeasurement(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_TrafficParticipants_Object_existsClusterMeasurement(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_blockageRegionIds(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_VisionCore_TrafficParticipants_Object_blockageRegionIds(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_turnIndicatorStatus(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectTurnIndicatorStatus *const data);
static bool decode_VisionCore_TrafficParticipants_Object_turnIndicatorStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_Object_verificationStatus(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_VisionCore_TrafficParticipants_Object_verificationStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectsOutput_Raw_objects(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_Object_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_VisionCore_TrafficParticipants_ObjectsOutput_Raw_objects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficParticipants_ObjectsOutput_objects(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_Object arrayData[], const qpb_size_t arraySize);
static bool decode_VisionCore_TrafficParticipants_ObjectsOutput_objects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);

#define VisionCore_TrafficParticipants_LaneProperties_Raw_DECODERS_COUNT 8
const qpb_decoder_entry_t VisionCore_TrafficParticipants_LaneProperties_Raw_decoders[VisionCore_TrafficParticipants_LaneProperties_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeft },
   { &decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeftStdDev },
   { &decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeftRate },
   { &decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRight },
   { &decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRightStdDev },
   { &decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRightRate },
   { &decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneAssignment }
};

#define VisionCore_TrafficParticipants_LaneProperties_DECODERS_COUNT 8
const qpb_decoder_entry_t VisionCore_TrafficParticipants_LaneProperties_decoders[VisionCore_TrafficParticipants_LaneProperties_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeft },
   { &decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeftStdDev },
   { &decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeftRate },
   { &decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRight },
   { &decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRightStdDev },
   { &decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRightRate },
   { &decode_VisionCore_TrafficParticipants_LaneProperties_laneAssignment }
};

#define VisionCore_TrafficParticipants_ObjectAcceleration_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t VisionCore_TrafficParticipants_ObjectAcceleration_Raw_decoders[VisionCore_TrafficParticipants_ObjectAcceleration_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw_xAcceleration },
   { &decode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw_xAccelerationStdDev }
};

#define VisionCore_TrafficParticipants_ObjectAcceleration_DECODERS_COUNT 3
const qpb_decoder_entry_t VisionCore_TrafficParticipants_ObjectAcceleration_decoders[VisionCore_TrafficParticipants_ObjectAcceleration_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficParticipants_ObjectAcceleration_xAcceleration },
   { &decode_VisionCore_TrafficParticipants_ObjectAcceleration_xAccelerationStdDev }
};

#define VisionCore_TrafficParticipants_ObjectPosition_Raw_DECODERS_COUNT 10
const qpb_decoder_entry_t VisionCore_TrafficParticipants_ObjectPosition_Raw_decoders[VisionCore_TrafficParticipants_ObjectPosition_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_x },
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_xStdDev },
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_y },
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yStdDev },
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_xyCorrCoeff },
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_z },
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_zStdDev },
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yawAngle },
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yawAngleStdDev }
};

#define VisionCore_TrafficParticipants_ObjectPosition_DECODERS_COUNT 10
const qpb_decoder_entry_t VisionCore_TrafficParticipants_ObjectPosition_decoders[VisionCore_TrafficParticipants_ObjectPosition_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_x },
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_xStdDev },
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_y },
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_yStdDev },
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_xyCorrCoeff },
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_z },
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_zStdDev },
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_yawAngle },
   { &decode_VisionCore_TrafficParticipants_ObjectPosition_yawAngleStdDev }
};

#define VisionCore_TrafficParticipants_ObjectQuality_Raw_DECODERS_COUNT 9
const qpb_decoder_entry_t VisionCore_TrafficParticipants_ObjectQuality_Raw_decoders[VisionCore_TrafficParticipants_ObjectQuality_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_classificationConfidence },
   { &decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_detectionConfidence },
   { &decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_classificationHistory },
   { &decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_detectionHistory },
   { &decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackingStatus },
   { &decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackAge },
   { &decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackDelay },
   { &decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_objectStatus }
};

#define VisionCore_TrafficParticipants_ObjectSize_Raw_DECODERS_COUNT 7
const qpb_decoder_entry_t VisionCore_TrafficParticipants_ObjectSize_Raw_decoders[VisionCore_TrafficParticipants_ObjectSize_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficParticipants_ObjectSize_Raw_height },
   { &decode_VisionCore_TrafficParticipants_ObjectSize_Raw_heightStdDev },
   { &decode_VisionCore_TrafficParticipants_ObjectSize_Raw_width },
   { &decode_VisionCore_TrafficParticipants_ObjectSize_Raw_widthStdDev },
   { &decode_VisionCore_TrafficParticipants_ObjectSize_Raw_length },
   { &decode_VisionCore_TrafficParticipants_ObjectSize_Raw_lengthStdDev }
};

#define VisionCore_TrafficParticipants_ObjectSize_DECODERS_COUNT 7
const qpb_decoder_entry_t VisionCore_TrafficParticipants_ObjectSize_decoders[VisionCore_TrafficParticipants_ObjectSize_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficParticipants_ObjectSize_height },
   { &decode_VisionCore_TrafficParticipants_ObjectSize_heightStdDev },
   { &decode_VisionCore_TrafficParticipants_ObjectSize_width },
   { &decode_VisionCore_TrafficParticipants_ObjectSize_widthStdDev },
   { &decode_VisionCore_TrafficParticipants_ObjectSize_length },
   { &decode_VisionCore_TrafficParticipants_ObjectSize_lengthStdDev }
};

#define VisionCore_TrafficParticipants_ObjectVelocity_Raw_DECODERS_COUNT 6
const qpb_decoder_entry_t VisionCore_TrafficParticipants_ObjectVelocity_Raw_decoders[VisionCore_TrafficParticipants_ObjectVelocity_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_xVelocity },
   { &decode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yVelocity },
   { &decode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_xVelocityStdDev },
   { &decode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yVelocityStdDev },
   { &decode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yawRate }
};

#define VisionCore_TrafficParticipants_ObjectVelocity_DECODERS_COUNT 6
const qpb_decoder_entry_t VisionCore_TrafficParticipants_ObjectVelocity_decoders[VisionCore_TrafficParticipants_ObjectVelocity_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficParticipants_ObjectVelocity_xVelocity },
   { &decode_VisionCore_TrafficParticipants_ObjectVelocity_yVelocity },
   { &decode_VisionCore_TrafficParticipants_ObjectVelocity_xVelocityStdDev },
   { &decode_VisionCore_TrafficParticipants_ObjectVelocity_yVelocityStdDev },
   { &decode_VisionCore_TrafficParticipants_ObjectVelocity_yawRate }
};

#define VisionCore_TrafficParticipants_ObjectVisibility_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t VisionCore_TrafficParticipants_ObjectVisibility_Raw_decoders[VisionCore_TrafficParticipants_ObjectVisibility_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficParticipants_ObjectVisibility_Raw_leftEdgeVisibility },
   { &decode_VisionCore_TrafficParticipants_ObjectVisibility_Raw_rightEdgeVisibility }
};

#define VisionCore_TrafficParticipants_Object_Raw_DECODERS_COUNT 17
const qpb_decoder_entry_t VisionCore_TrafficParticipants_Object_Raw_decoders[VisionCore_TrafficParticipants_Object_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficParticipants_Object_Raw_id },
   { &decode_VisionCore_TrafficParticipants_Object_Raw_objectClass },
   { &decode_VisionCore_TrafficParticipants_Object_Raw_motionMode },
   { &decode_VisionCore_TrafficParticipants_Object_Raw_objectPose },
   { &decode_VisionCore_TrafficParticipants_Object_Raw_positionAclc },
   { &decode_VisionCore_TrafficParticipants_Object_Raw_velocityAclc },
   { &decode_VisionCore_TrafficParticipants_Object_Raw_accelerationAclc },
   { &decode_VisionCore_TrafficParticipants_Object_Raw_size },
   { &decode_VisionCore_TrafficParticipants_Object_Raw_laneProperties },
   { &decode_VisionCore_TrafficParticipants_Object_Raw_quality },
   { &decode_VisionCore_TrafficParticipants_Object_Raw_visibility },
   { &decode_VisionCore_TrafficParticipants_Object_Raw_existsStereoMeasurement },
   { &decode_VisionCore_TrafficParticipants_Object_Raw_existsClusterMeasurement },
   { &decode_VisionCore_TrafficParticipants_Object_Raw_blockageRegionIds },
   { &decode_VisionCore_TrafficParticipants_Object_Raw_turnIndicatorStatus },
   { &decode_VisionCore_TrafficParticipants_Object_Raw_verificationStatus }
};

#define VisionCore_TrafficParticipants_Object_DECODERS_COUNT 17
const qpb_decoder_entry_t VisionCore_TrafficParticipants_Object_decoders[VisionCore_TrafficParticipants_Object_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficParticipants_Object_id },
   { &decode_VisionCore_TrafficParticipants_Object_objectClass },
   { &decode_VisionCore_TrafficParticipants_Object_motionMode },
   { &decode_VisionCore_TrafficParticipants_Object_objectPose },
   { &decode_VisionCore_TrafficParticipants_Object_positionAclc },
   { &decode_VisionCore_TrafficParticipants_Object_velocityAclc },
   { &decode_VisionCore_TrafficParticipants_Object_accelerationAclc },
   { &decode_VisionCore_TrafficParticipants_Object_size },
   { &decode_VisionCore_TrafficParticipants_Object_laneProperties },
   { &decode_VisionCore_TrafficParticipants_Object_quality },
   { &decode_VisionCore_TrafficParticipants_Object_visibility },
   { &decode_VisionCore_TrafficParticipants_Object_existsStereoMeasurement },
   { &decode_VisionCore_TrafficParticipants_Object_existsClusterMeasurement },
   { &decode_VisionCore_TrafficParticipants_Object_blockageRegionIds },
   { &decode_VisionCore_TrafficParticipants_Object_turnIndicatorStatus },
   { &decode_VisionCore_TrafficParticipants_Object_verificationStatus }
};

#define VisionCore_TrafficParticipants_ObjectsOutput_Raw_DECODERS_COUNT 2
const qpb_decoder_entry_t VisionCore_TrafficParticipants_ObjectsOutput_Raw_decoders[VisionCore_TrafficParticipants_ObjectsOutput_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficParticipants_ObjectsOutput_Raw_objects }
};

#define VisionCore_TrafficParticipants_ObjectsOutput_DECODERS_COUNT 2
const qpb_decoder_entry_t VisionCore_TrafficParticipants_ObjectsOutput_decoders[VisionCore_TrafficParticipants_ObjectsOutput_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficParticipants_ObjectsOutput_objects }
};

static inline void encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeft(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeft(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_TrafficParticipants_LaneProperties_Raw*)data)->laneOffsetLeft, sizeof(int16_t));
}

static inline void encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeftStdDev(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeftStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_LaneProperties_Raw*)data)->laneOffsetLeftStdDev, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeftRate(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeftRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_TrafficParticipants_LaneProperties_Raw*)data)->laneOffsetLeftRate, sizeof(int16_t));
}

static inline void encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRight(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRight(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_TrafficParticipants_LaneProperties_Raw*)data)->laneOffsetRight, sizeof(int16_t));
}

static inline void encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRightStdDev(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRightStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_LaneProperties_Raw*)data)->laneOffsetRightStdDev, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRightRate(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRightRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_TrafficParticipants_LaneProperties_Raw*)data)->laneOffsetRightRate, sizeof(int16_t));
}

static inline void encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneAssignment(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectLaneAssignment *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneAssignment(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_LaneProperties_Raw*)data)->laneAssignment, qpb_membersize(VisionCore_TrafficParticipants_LaneProperties_Raw, laneAssignment));
}

static inline void encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeft(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeft(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeft(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_TrafficParticipants_LaneProperties*)data)->laneOffsetLeft = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeftStdDev(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_1, 0, UINT8_MAX);
   encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeftStdDev(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeftStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_TrafficParticipants_LaneProperties*)data)->laneOffsetLeftStdDev = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeftRate(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeftRate(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeftRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_TrafficParticipants_LaneProperties*)data)->laneOffsetLeftRate = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRight(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRight(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRight(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_TrafficParticipants_LaneProperties*)data)->laneOffsetRight = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRightStdDev(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_1, 0, UINT8_MAX);
   encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRightStdDev(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRightStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_TrafficParticipants_LaneProperties*)data)->laneOffsetRightStdDev = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRightRate(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRightRate(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRightRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_TrafficParticipants_LaneProperties*)data)->laneOffsetRightRate = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_LaneProperties_laneAssignment(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectLaneAssignment *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_LaneProperties_laneAssignment(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_LaneProperties*)data)->laneAssignment, qpb_membersize(VisionCore_TrafficParticipants_LaneProperties, laneAssignment));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw_xAcceleration(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw_xAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectAcceleration_Raw*)data)->xAcceleration, sizeof(int16_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw_xAccelerationStdDev(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw_xAccelerationStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectAcceleration_Raw*)data)->xAccelerationStdDev, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectAcceleration_xAcceleration(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_1, INT16_MIN, INT16_MAX);
   encode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw_xAcceleration(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectAcceleration_xAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_TrafficParticipants_ObjectAcceleration*)data)->xAcceleration = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectAcceleration_xAccelerationStdDev(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_1, 0, UINT8_MAX);
   encode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw_xAccelerationStdDev(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectAcceleration_xAccelerationStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_TrafficParticipants_ObjectAcceleration*)data)->xAccelerationStdDev = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_x(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_x(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectPosition_Raw*)data)->x, sizeof(uint16_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_xStdDev(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_xStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectPosition_Raw*)data)->xStdDev, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_y(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_y(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectPosition_Raw*)data)->y, sizeof(int16_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yStdDev(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectPosition_Raw*)data)->yStdDev, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_xyCorrCoeff(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_xyCorrCoeff(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectPosition_Raw*)data)->xyCorrCoeff, sizeof(int16_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_z(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_z(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectPosition_Raw*)data)->z, sizeof(int16_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_zStdDev(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_zStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectPosition_Raw*)data)->zStdDev, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yawAngle(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yawAngle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectPosition_Raw*)data)->yawAngle, sizeof(int16_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yawAngleStdDev(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 72;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yawAngleStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectPosition_Raw*)data)->yawAngleStdDev, sizeof(uint16_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_x(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_x(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_x(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((VisionCore_TrafficParticipants_ObjectPosition*)data)->x = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_xStdDev(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_1, 0, UINT8_MAX);
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_xStdDev(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_xStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_TrafficParticipants_ObjectPosition*)data)->xStdDev = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_y(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_y(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_y(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_TrafficParticipants_ObjectPosition*)data)->y = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_yStdDev(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_02, 0, UINT8_MAX);
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yStdDev(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_yStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_TrafficParticipants_ObjectPosition*)data)->yStdDev = value * F_0_02;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_xyCorrCoeff(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_xyCorrCoeff(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_xyCorrCoeff(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_TrafficParticipants_ObjectPosition*)data)->xyCorrCoeff = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_z(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_1, INT16_MIN, INT16_MAX);
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_z(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_z(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_TrafficParticipants_ObjectPosition*)data)->z = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_zStdDev(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_1, 0, UINT8_MAX);
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_zStdDev(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_zStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_TrafficParticipants_ObjectPosition*)data)->zStdDev = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_yawAngle(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yawAngle(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_yawAngle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_TrafficParticipants_ObjectPosition*)data)->yawAngle = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectPosition_yawAngleStdDev(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yawAngleStdDev(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectPosition_yawAngleStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((VisionCore_TrafficParticipants_ObjectPosition*)data)->yawAngleStdDev = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_classificationConfidence(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_classificationConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectQuality_Raw*)data)->classificationConfidence, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_detectionConfidence(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_detectionConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectQuality_Raw*)data)->detectionConfidence, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_classificationHistory(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_classificationHistory(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectQuality_Raw*)data)->classificationHistory, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_detectionHistory(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_detectionHistory(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectQuality_Raw*)data)->detectionHistory, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackingStatus(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectTrackingStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackingStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectQuality_Raw*)data)->trackingStatus, qpb_membersize(VisionCore_TrafficParticipants_ObjectQuality_Raw, trackingStatus));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackAge(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackAge(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectQuality_Raw*)data)->trackAge, sizeof(uint16_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackDelay(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackDelay(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectQuality_Raw*)data)->trackDelay, sizeof(uint16_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_objectStatus(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectQualityStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectQuality_Raw_objectStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectQuality_Raw*)data)->objectStatus, qpb_membersize(VisionCore_TrafficParticipants_ObjectQuality_Raw, objectStatus));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectSize_Raw_height(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectSize_Raw_height(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectSize_Raw*)data)->height, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectSize_Raw_heightStdDev(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectSize_Raw_heightStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectSize_Raw*)data)->heightStdDev, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectSize_Raw_width(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectSize_Raw_width(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectSize_Raw*)data)->width, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectSize_Raw_widthStdDev(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectSize_Raw_widthStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectSize_Raw*)data)->widthStdDev, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectSize_Raw_length(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectSize_Raw_length(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectSize_Raw*)data)->length, sizeof(uint16_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectSize_Raw_lengthStdDev(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectSize_Raw_lengthStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectSize_Raw*)data)->lengthStdDev, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectSize_height(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_1, 0, UINT8_MAX);
   encode_VisionCore_TrafficParticipants_ObjectSize_Raw_height(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectSize_height(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_TrafficParticipants_ObjectSize*)data)->height = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectSize_heightStdDev(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_1, 0, UINT8_MAX);
   encode_VisionCore_TrafficParticipants_ObjectSize_Raw_heightStdDev(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectSize_heightStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_TrafficParticipants_ObjectSize*)data)->heightStdDev = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectSize_width(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_1, 0, UINT8_MAX);
   encode_VisionCore_TrafficParticipants_ObjectSize_Raw_width(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectSize_width(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_TrafficParticipants_ObjectSize*)data)->width = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectSize_widthStdDev(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_02, 0, UINT8_MAX);
   encode_VisionCore_TrafficParticipants_ObjectSize_Raw_widthStdDev(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectSize_widthStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_TrafficParticipants_ObjectSize*)data)->widthStdDev = value * F_0_02;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectSize_length(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_1, 0, UINT16_MAX);
   encode_VisionCore_TrafficParticipants_ObjectSize_Raw_length(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectSize_length(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((VisionCore_TrafficParticipants_ObjectSize*)data)->length = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectSize_lengthStdDev(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_2, 0, UINT8_MAX);
   encode_VisionCore_TrafficParticipants_ObjectSize_Raw_lengthStdDev(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectSize_lengthStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_TrafficParticipants_ObjectSize*)data)->lengthStdDev = value * F_0_2;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_xVelocity(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_xVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectVelocity_Raw*)data)->xVelocity, sizeof(int16_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yVelocity(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectVelocity_Raw*)data)->yVelocity, sizeof(int16_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_xVelocityStdDev(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_xVelocityStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectVelocity_Raw*)data)->xVelocityStdDev, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yVelocityStdDev(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yVelocityStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectVelocity_Raw*)data)->yVelocityStdDev, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yawRate(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yawRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectVelocity_Raw*)data)->yawRate, sizeof(int16_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_xVelocity(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_1, INT16_MIN, INT16_MAX);
   encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_xVelocity(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_xVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_TrafficParticipants_ObjectVelocity*)data)->xVelocity = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_yVelocity(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_1, INT16_MIN, INT16_MAX);
   encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yVelocity(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_yVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_TrafficParticipants_ObjectVelocity*)data)->yVelocity = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_xVelocityStdDev(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_1, 0, UINT8_MAX);
   encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_xVelocityStdDev(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_xVelocityStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_TrafficParticipants_ObjectVelocity*)data)->xVelocityStdDev = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_yVelocityStdDev(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_1, 0, UINT8_MAX);
   encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yVelocityStdDev(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_yVelocityStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_TrafficParticipants_ObjectVelocity*)data)->yVelocityStdDev = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectVelocity_yawRate(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yawRate(stream, &value);
}

static bool decode_VisionCore_TrafficParticipants_ObjectVelocity_yawRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_TrafficParticipants_ObjectVelocity*)data)->yawRate = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectVisibility_Raw_leftEdgeVisibility(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectEdgeVisibility *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectVisibility_Raw_leftEdgeVisibility(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectVisibility_Raw*)data)->leftEdgeVisibility, qpb_membersize(VisionCore_TrafficParticipants_ObjectVisibility_Raw, leftEdgeVisibility));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectVisibility_Raw_rightEdgeVisibility(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectEdgeVisibility *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectVisibility_Raw_rightEdgeVisibility(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_ObjectVisibility_Raw*)data)->rightEdgeVisibility, qpb_membersize(VisionCore_TrafficParticipants_ObjectVisibility_Raw, rightEdgeVisibility));
}

static inline void encode_VisionCore_TrafficParticipants_Object_Raw_id(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_Raw_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_Object_Raw*)data)->id, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_Object_Raw_objectClass(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectClass *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_Raw_objectClass(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_Object_Raw*)data)->objectClass, qpb_membersize(VisionCore_TrafficParticipants_Object_Raw, objectClass));
}

static inline void encode_VisionCore_TrafficParticipants_Object_Raw_motionMode(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectMotionMode *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_Raw_motionMode(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_Object_Raw*)data)->motionMode, qpb_membersize(VisionCore_TrafficParticipants_Object_Raw, motionMode));
}

static inline void encode_VisionCore_TrafficParticipants_Object_Raw_objectPose(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectPose *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_Raw_objectPose(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_Object_Raw*)data)->objectPose, qpb_membersize(VisionCore_TrafficParticipants_Object_Raw, objectPose));
}

static inline void encode_VisionCore_TrafficParticipants_Object_Raw_positionAclc(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectPosition_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 42;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_Raw_positionAclc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficParticipants_ObjectPosition_Raw(&substream, &((VisionCore_TrafficParticipants_Object_Raw*)data)->positionAclc);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_Object_Raw_velocityAclc(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectVelocity_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 50;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_Raw_velocityAclc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficParticipants_ObjectVelocity_Raw(&substream, &((VisionCore_TrafficParticipants_Object_Raw*)data)->velocityAclc);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_Object_Raw_accelerationAclc(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectAcceleration_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 58;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_Raw_accelerationAclc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw(&substream, &((VisionCore_TrafficParticipants_Object_Raw*)data)->accelerationAclc);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_Object_Raw_size(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectSize_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 66;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficParticipants_ObjectSize_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_Raw_size(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficParticipants_ObjectSize_Raw(&substream, &((VisionCore_TrafficParticipants_Object_Raw*)data)->size);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_Object_Raw_laneProperties(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_LaneProperties_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 74;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficParticipants_LaneProperties_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_Raw_laneProperties(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficParticipants_LaneProperties_Raw(&substream, &((VisionCore_TrafficParticipants_Object_Raw*)data)->laneProperties);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_Object_Raw_quality(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectQuality_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 82;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficParticipants_ObjectQuality_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_Raw_quality(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficParticipants_ObjectQuality_Raw(&substream, &((VisionCore_TrafficParticipants_Object_Raw*)data)->quality);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_Object_Raw_visibility(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectVisibility_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 90;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficParticipants_ObjectVisibility_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_Raw_visibility(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficParticipants_ObjectVisibility_Raw(&substream, &((VisionCore_TrafficParticipants_Object_Raw*)data)->visibility);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_Object_Raw_existsStereoMeasurement(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 96;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_Raw_existsStereoMeasurement(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_Object_Raw*)data)->existsStereoMeasurement, sizeof(bool));
}

static inline void encode_VisionCore_TrafficParticipants_Object_Raw_existsClusterMeasurement(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 104;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_Raw_existsClusterMeasurement(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_Object_Raw*)data)->existsClusterMeasurement, sizeof(bool));
}

static inline void encode_VisionCore_TrafficParticipants_Object_Raw_blockageRegionIds(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 112;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_Raw_blockageRegionIds(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_Object_Raw*)data)->blockageRegionIds, sizeof(uint16_t));
}

static inline void encode_VisionCore_TrafficParticipants_Object_Raw_turnIndicatorStatus(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectTurnIndicatorStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 120;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_Raw_turnIndicatorStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_Object_Raw*)data)->turnIndicatorStatus, qpb_membersize(VisionCore_TrafficParticipants_Object_Raw, turnIndicatorStatus));
}

static inline void encode_VisionCore_TrafficParticipants_Object_Raw_verificationStatus(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 128);
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_Raw_verificationStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_Object_Raw*)data)->verificationStatus, sizeof(uint32_t));
}

static inline void encode_VisionCore_TrafficParticipants_Object_id(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_Object*)data)->id, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficParticipants_Object_objectClass(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectClass *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_objectClass(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_Object*)data)->objectClass, qpb_membersize(VisionCore_TrafficParticipants_Object, objectClass));
}

static inline void encode_VisionCore_TrafficParticipants_Object_motionMode(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectMotionMode *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_motionMode(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_Object*)data)->motionMode, qpb_membersize(VisionCore_TrafficParticipants_Object, motionMode));
}

static inline void encode_VisionCore_TrafficParticipants_Object_objectPose(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectPose *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_objectPose(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_Object*)data)->objectPose, qpb_membersize(VisionCore_TrafficParticipants_Object, objectPose));
}

static inline void encode_VisionCore_TrafficParticipants_Object_positionAclc(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectPosition *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 42;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficParticipants_ObjectPosition(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_positionAclc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficParticipants_ObjectPosition(&substream, &((VisionCore_TrafficParticipants_Object*)data)->positionAclc);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_Object_velocityAclc(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectVelocity *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 50;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficParticipants_ObjectVelocity(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_velocityAclc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficParticipants_ObjectVelocity(&substream, &((VisionCore_TrafficParticipants_Object*)data)->velocityAclc);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_Object_accelerationAclc(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectAcceleration *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 58;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficParticipants_ObjectAcceleration(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_accelerationAclc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficParticipants_ObjectAcceleration(&substream, &((VisionCore_TrafficParticipants_Object*)data)->accelerationAclc);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_Object_size(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectSize *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 66;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficParticipants_ObjectSize(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_size(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficParticipants_ObjectSize(&substream, &((VisionCore_TrafficParticipants_Object*)data)->size);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_Object_laneProperties(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_LaneProperties *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 74;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficParticipants_LaneProperties(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_laneProperties(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficParticipants_LaneProperties(&substream, &((VisionCore_TrafficParticipants_Object*)data)->laneProperties);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_Object_quality(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectQuality *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 82;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficParticipants_ObjectQuality(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_quality(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficParticipants_ObjectQuality(&substream, &((VisionCore_TrafficParticipants_Object*)data)->quality);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_Object_visibility(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectVisibility *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 90;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficParticipants_ObjectVisibility(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_visibility(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficParticipants_ObjectVisibility(&substream, &((VisionCore_TrafficParticipants_Object*)data)->visibility);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficParticipants_Object_existsStereoMeasurement(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 96;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_existsStereoMeasurement(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_Object*)data)->existsStereoMeasurement, sizeof(bool));
}

static inline void encode_VisionCore_TrafficParticipants_Object_existsClusterMeasurement(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 104;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_existsClusterMeasurement(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_Object*)data)->existsClusterMeasurement, sizeof(bool));
}

static inline void encode_VisionCore_TrafficParticipants_Object_blockageRegionIds(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 112;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_blockageRegionIds(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_Object*)data)->blockageRegionIds, sizeof(uint16_t));
}

static inline void encode_VisionCore_TrafficParticipants_Object_turnIndicatorStatus(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectTurnIndicatorStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 120;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_turnIndicatorStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficParticipants_Object*)data)->turnIndicatorStatus, qpb_membersize(VisionCore_TrafficParticipants_Object, turnIndicatorStatus));
}

static inline void encode_VisionCore_TrafficParticipants_Object_verificationStatus(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 128);
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficParticipants_Object_verificationStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficParticipants_Object*)data)->verificationStatus, sizeof(uint32_t));
}

static inline void encode_VisionCore_TrafficParticipants_ObjectsOutput_Raw_objects(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_Object_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 10;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_VisionCore_TrafficParticipants_Object_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectsOutput_Raw_objects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((VisionCore_TrafficParticipants_ObjectsOutput_Raw*)data)->objects_count + 1) > 25)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_VisionCore_TrafficParticipants_Object_Raw(&substream, &((VisionCore_TrafficParticipants_ObjectsOutput_Raw*)data)->objects[((VisionCore_TrafficParticipants_ObjectsOutput_Raw*)data)->objects_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_VisionCore_TrafficParticipants_ObjectsOutput_objects(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_Object arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 10;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_VisionCore_TrafficParticipants_Object(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_VisionCore_TrafficParticipants_ObjectsOutput_objects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((VisionCore_TrafficParticipants_ObjectsOutput*)data)->objects_count + 1) > 25)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_VisionCore_TrafficParticipants_Object(&substream, &((VisionCore_TrafficParticipants_ObjectsOutput*)data)->objects[((VisionCore_TrafficParticipants_ObjectsOutput*)data)->objects_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

/* Encoding / decoding functions */
bool encode_VisionCore_TrafficParticipants_LaneProperties_Raw(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_LaneProperties_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficParticipants_LaneProperties_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeft(stream, &data->laneOffsetLeft);
   encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeftStdDev(stream, &data->laneOffsetLeftStdDev);
   encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetLeftRate(stream, &data->laneOffsetLeftRate);
   encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRight(stream, &data->laneOffsetRight);
   encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRightStdDev(stream, &data->laneOffsetRightStdDev);
   encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneOffsetRightRate(stream, &data->laneOffsetRightRate);
   encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneAssignment(stream, &data->laneAssignment);
   return true;
}

bool decode_VisionCore_TrafficParticipants_LaneProperties_Raw(qpb_istream_t *const stream, VisionCore_TrafficParticipants_LaneProperties_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficParticipants_LaneProperties_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficParticipants_LaneProperties_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficParticipants_LaneProperties(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_LaneProperties *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficParticipants_LaneProperties_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeft(stream, &data->laneOffsetLeft);
   encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeftStdDev(stream, &data->laneOffsetLeftStdDev);
   encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetLeftRate(stream, &data->laneOffsetLeftRate);
   encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRight(stream, &data->laneOffsetRight);
   encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRightStdDev(stream, &data->laneOffsetRightStdDev);
   encode_VisionCore_TrafficParticipants_LaneProperties_laneOffsetRightRate(stream, &data->laneOffsetRightRate);
   encode_VisionCore_TrafficParticipants_LaneProperties_Raw_laneAssignment(stream, &data->laneAssignment);
   return true;
}

bool decode_VisionCore_TrafficParticipants_LaneProperties(qpb_istream_t *const stream, VisionCore_TrafficParticipants_LaneProperties *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficParticipants_LaneProperties_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficParticipants_LaneProperties_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectAcceleration_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficParticipants_ObjectAcceleration_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw_xAcceleration(stream, &data->xAcceleration);
   encode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw_xAccelerationStdDev(stream, &data->xAccelerationStdDev);
   return true;
}

bool decode_VisionCore_TrafficParticipants_ObjectAcceleration_Raw(qpb_istream_t *const stream, VisionCore_TrafficParticipants_ObjectAcceleration_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficParticipants_ObjectAcceleration_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficParticipants_ObjectAcceleration_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficParticipants_ObjectAcceleration(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectAcceleration *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficParticipants_ObjectAcceleration_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficParticipants_ObjectAcceleration_xAcceleration(stream, &data->xAcceleration);
   encode_VisionCore_TrafficParticipants_ObjectAcceleration_xAccelerationStdDev(stream, &data->xAccelerationStdDev);
   return true;
}

bool decode_VisionCore_TrafficParticipants_ObjectAcceleration(qpb_istream_t *const stream, VisionCore_TrafficParticipants_ObjectAcceleration *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficParticipants_ObjectAcceleration_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficParticipants_ObjectAcceleration_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficParticipants_ObjectPosition_Raw(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectPosition_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficParticipants_ObjectPosition_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_x(stream, &data->x);
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_xStdDev(stream, &data->xStdDev);
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_y(stream, &data->y);
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yStdDev(stream, &data->yStdDev);
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_xyCorrCoeff(stream, &data->xyCorrCoeff);
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_z(stream, &data->z);
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_zStdDev(stream, &data->zStdDev);
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yawAngle(stream, &data->yawAngle);
   encode_VisionCore_TrafficParticipants_ObjectPosition_Raw_yawAngleStdDev(stream, &data->yawAngleStdDev);
   return true;
}

bool decode_VisionCore_TrafficParticipants_ObjectPosition_Raw(qpb_istream_t *const stream, VisionCore_TrafficParticipants_ObjectPosition_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficParticipants_ObjectPosition_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficParticipants_ObjectPosition_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficParticipants_ObjectPosition(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectPosition *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficParticipants_ObjectPosition_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficParticipants_ObjectPosition_x(stream, &data->x);
   encode_VisionCore_TrafficParticipants_ObjectPosition_xStdDev(stream, &data->xStdDev);
   encode_VisionCore_TrafficParticipants_ObjectPosition_y(stream, &data->y);
   encode_VisionCore_TrafficParticipants_ObjectPosition_yStdDev(stream, &data->yStdDev);
   encode_VisionCore_TrafficParticipants_ObjectPosition_xyCorrCoeff(stream, &data->xyCorrCoeff);
   encode_VisionCore_TrafficParticipants_ObjectPosition_z(stream, &data->z);
   encode_VisionCore_TrafficParticipants_ObjectPosition_zStdDev(stream, &data->zStdDev);
   encode_VisionCore_TrafficParticipants_ObjectPosition_yawAngle(stream, &data->yawAngle);
   encode_VisionCore_TrafficParticipants_ObjectPosition_yawAngleStdDev(stream, &data->yawAngleStdDev);
   return true;
}

bool decode_VisionCore_TrafficParticipants_ObjectPosition(qpb_istream_t *const stream, VisionCore_TrafficParticipants_ObjectPosition *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficParticipants_ObjectPosition_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficParticipants_ObjectPosition_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficParticipants_ObjectQuality_Raw(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectQuality_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficParticipants_ObjectQuality_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_classificationConfidence(stream, &data->classificationConfidence);
   encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_detectionConfidence(stream, &data->detectionConfidence);
   encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_classificationHistory(stream, &data->classificationHistory);
   encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_detectionHistory(stream, &data->detectionHistory);
   encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackingStatus(stream, &data->trackingStatus);
   encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackAge(stream, &data->trackAge);
   encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_trackDelay(stream, &data->trackDelay);
   encode_VisionCore_TrafficParticipants_ObjectQuality_Raw_objectStatus(stream, &data->objectStatus);
   return true;
}

bool decode_VisionCore_TrafficParticipants_ObjectQuality_Raw(qpb_istream_t *const stream, VisionCore_TrafficParticipants_ObjectQuality_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficParticipants_ObjectQuality_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficParticipants_ObjectQuality_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficParticipants_ObjectSize_Raw(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectSize_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficParticipants_ObjectSize_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficParticipants_ObjectSize_Raw_height(stream, &data->height);
   encode_VisionCore_TrafficParticipants_ObjectSize_Raw_heightStdDev(stream, &data->heightStdDev);
   encode_VisionCore_TrafficParticipants_ObjectSize_Raw_width(stream, &data->width);
   encode_VisionCore_TrafficParticipants_ObjectSize_Raw_widthStdDev(stream, &data->widthStdDev);
   encode_VisionCore_TrafficParticipants_ObjectSize_Raw_length(stream, &data->length);
   encode_VisionCore_TrafficParticipants_ObjectSize_Raw_lengthStdDev(stream, &data->lengthStdDev);
   return true;
}

bool decode_VisionCore_TrafficParticipants_ObjectSize_Raw(qpb_istream_t *const stream, VisionCore_TrafficParticipants_ObjectSize_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficParticipants_ObjectSize_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficParticipants_ObjectSize_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficParticipants_ObjectSize(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectSize *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficParticipants_ObjectSize_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficParticipants_ObjectSize_height(stream, &data->height);
   encode_VisionCore_TrafficParticipants_ObjectSize_heightStdDev(stream, &data->heightStdDev);
   encode_VisionCore_TrafficParticipants_ObjectSize_width(stream, &data->width);
   encode_VisionCore_TrafficParticipants_ObjectSize_widthStdDev(stream, &data->widthStdDev);
   encode_VisionCore_TrafficParticipants_ObjectSize_length(stream, &data->length);
   encode_VisionCore_TrafficParticipants_ObjectSize_lengthStdDev(stream, &data->lengthStdDev);
   return true;
}

bool decode_VisionCore_TrafficParticipants_ObjectSize(qpb_istream_t *const stream, VisionCore_TrafficParticipants_ObjectSize *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficParticipants_ObjectSize_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficParticipants_ObjectSize_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectVelocity_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficParticipants_ObjectVelocity_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_xVelocity(stream, &data->xVelocity);
   encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yVelocity(stream, &data->yVelocity);
   encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_xVelocityStdDev(stream, &data->xVelocityStdDev);
   encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yVelocityStdDev(stream, &data->yVelocityStdDev);
   encode_VisionCore_TrafficParticipants_ObjectVelocity_Raw_yawRate(stream, &data->yawRate);
   return true;
}

bool decode_VisionCore_TrafficParticipants_ObjectVelocity_Raw(qpb_istream_t *const stream, VisionCore_TrafficParticipants_ObjectVelocity_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficParticipants_ObjectVelocity_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficParticipants_ObjectVelocity_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficParticipants_ObjectVelocity(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectVelocity *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficParticipants_ObjectVelocity_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficParticipants_ObjectVelocity_xVelocity(stream, &data->xVelocity);
   encode_VisionCore_TrafficParticipants_ObjectVelocity_yVelocity(stream, &data->yVelocity);
   encode_VisionCore_TrafficParticipants_ObjectVelocity_xVelocityStdDev(stream, &data->xVelocityStdDev);
   encode_VisionCore_TrafficParticipants_ObjectVelocity_yVelocityStdDev(stream, &data->yVelocityStdDev);
   encode_VisionCore_TrafficParticipants_ObjectVelocity_yawRate(stream, &data->yawRate);
   return true;
}

bool decode_VisionCore_TrafficParticipants_ObjectVelocity(qpb_istream_t *const stream, VisionCore_TrafficParticipants_ObjectVelocity *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficParticipants_ObjectVelocity_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficParticipants_ObjectVelocity_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficParticipants_ObjectVisibility_Raw(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectVisibility_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficParticipants_ObjectVisibility_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficParticipants_ObjectVisibility_Raw_leftEdgeVisibility(stream, &data->leftEdgeVisibility);
   encode_VisionCore_TrafficParticipants_ObjectVisibility_Raw_rightEdgeVisibility(stream, &data->rightEdgeVisibility);
   return true;
}

bool decode_VisionCore_TrafficParticipants_ObjectVisibility_Raw(qpb_istream_t *const stream, VisionCore_TrafficParticipants_ObjectVisibility_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficParticipants_ObjectVisibility_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficParticipants_ObjectVisibility_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficParticipants_Object_Raw(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_Object_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficParticipants_Object_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficParticipants_Object_Raw_id(stream, &data->id);
   encode_VisionCore_TrafficParticipants_Object_Raw_objectClass(stream, &data->objectClass);
   encode_VisionCore_TrafficParticipants_Object_Raw_motionMode(stream, &data->motionMode);
   encode_VisionCore_TrafficParticipants_Object_Raw_objectPose(stream, &data->objectPose);
   encode_VisionCore_TrafficParticipants_Object_Raw_positionAclc(stream, &data->positionAclc);
   encode_VisionCore_TrafficParticipants_Object_Raw_velocityAclc(stream, &data->velocityAclc);
   encode_VisionCore_TrafficParticipants_Object_Raw_accelerationAclc(stream, &data->accelerationAclc);
   encode_VisionCore_TrafficParticipants_Object_Raw_size(stream, &data->size);
   encode_VisionCore_TrafficParticipants_Object_Raw_laneProperties(stream, &data->laneProperties);
   encode_VisionCore_TrafficParticipants_Object_Raw_quality(stream, &data->quality);
   encode_VisionCore_TrafficParticipants_Object_Raw_visibility(stream, &data->visibility);
   encode_VisionCore_TrafficParticipants_Object_Raw_existsStereoMeasurement(stream, &data->existsStereoMeasurement);
   encode_VisionCore_TrafficParticipants_Object_Raw_existsClusterMeasurement(stream, &data->existsClusterMeasurement);
   encode_VisionCore_TrafficParticipants_Object_Raw_blockageRegionIds(stream, &data->blockageRegionIds);
   encode_VisionCore_TrafficParticipants_Object_Raw_turnIndicatorStatus(stream, &data->turnIndicatorStatus);
   encode_VisionCore_TrafficParticipants_Object_Raw_verificationStatus(stream, &data->verificationStatus);
   return true;
}

bool decode_VisionCore_TrafficParticipants_Object_Raw(qpb_istream_t *const stream, VisionCore_TrafficParticipants_Object_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficParticipants_Object_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficParticipants_Object_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficParticipants_Object(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_Object *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficParticipants_Object_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficParticipants_Object_Raw_id(stream, &data->id);
   encode_VisionCore_TrafficParticipants_Object_Raw_objectClass(stream, &data->objectClass);
   encode_VisionCore_TrafficParticipants_Object_Raw_motionMode(stream, &data->motionMode);
   encode_VisionCore_TrafficParticipants_Object_Raw_objectPose(stream, &data->objectPose);
   encode_VisionCore_TrafficParticipants_Object_positionAclc(stream, &data->positionAclc);
   encode_VisionCore_TrafficParticipants_Object_velocityAclc(stream, &data->velocityAclc);
   encode_VisionCore_TrafficParticipants_Object_accelerationAclc(stream, &data->accelerationAclc);
   encode_VisionCore_TrafficParticipants_Object_size(stream, &data->size);
   encode_VisionCore_TrafficParticipants_Object_laneProperties(stream, &data->laneProperties);
   encode_VisionCore_TrafficParticipants_Object_quality(stream, &data->quality);
   encode_VisionCore_TrafficParticipants_Object_visibility(stream, &data->visibility);
   encode_VisionCore_TrafficParticipants_Object_Raw_existsStereoMeasurement(stream, &data->existsStereoMeasurement);
   encode_VisionCore_TrafficParticipants_Object_Raw_existsClusterMeasurement(stream, &data->existsClusterMeasurement);
   encode_VisionCore_TrafficParticipants_Object_Raw_blockageRegionIds(stream, &data->blockageRegionIds);
   encode_VisionCore_TrafficParticipants_Object_Raw_turnIndicatorStatus(stream, &data->turnIndicatorStatus);
   encode_VisionCore_TrafficParticipants_Object_Raw_verificationStatus(stream, &data->verificationStatus);
   return true;
}

bool decode_VisionCore_TrafficParticipants_Object(qpb_istream_t *const stream, VisionCore_TrafficParticipants_Object *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficParticipants_Object_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficParticipants_Object_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficParticipants_ObjectsOutput_Raw(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectsOutput_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficParticipants_ObjectsOutput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficParticipants_ObjectsOutput_Raw_objects(stream, data->objects, data->objects_count);
   return true;
}

bool decode_VisionCore_TrafficParticipants_ObjectsOutput_Raw(qpb_istream_t *const stream, VisionCore_TrafficParticipants_ObjectsOutput_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficParticipants_ObjectsOutput_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficParticipants_ObjectsOutput_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficParticipants_ObjectsOutput(qpb_ostream_t *const stream, const VisionCore_TrafficParticipants_ObjectsOutput *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficParticipants_ObjectsOutput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficParticipants_ObjectsOutput_objects(stream, data->objects, data->objects_count);
   return true;
}

bool decode_VisionCore_TrafficParticipants_ObjectsOutput(qpb_istream_t *const stream, VisionCore_TrafficParticipants_ObjectsOutput *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficParticipants_ObjectsOutput_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficParticipants_ObjectsOutput_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

