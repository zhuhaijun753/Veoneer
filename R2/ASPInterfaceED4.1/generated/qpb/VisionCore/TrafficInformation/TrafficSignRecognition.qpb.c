/* Automatically generated qpb constant definitions */
/* Generated by Quick Protocol Buffers - 2 */

#include "VisionCore/TrafficInformation/TrafficSignRecognition.qpb.h"
#include "Tools/QuickProtobuf/qpb_decode.h"
#include "Tools/QuickProtobuf/qpb_encode.h"
#include "Tools/CSupport/ConversionSupport.h"

#if QPB_PROTO_HEADER_VERSION != 2
#error Regenerate this file with the current version of qpb generator.
#endif

static inline void encode_VisionCore_TrafficInformation_AddOnSign_Raw_type(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_RestrictionSign *const data);
static bool decode_VisionCore_TrafficInformation_AddOnSign_Raw_type(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_AddOnSign_Raw_confidence(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficInformation_AddOnSign_Raw_confidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_Sign_Raw_category(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignCategory *const data);
static bool decode_VisionCore_TrafficInformation_Sign_Raw_category(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_Sign_Raw_speedLimit(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficInformation_Sign_Raw_speedLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_Sign_Raw_speedLimitUnit(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SpeedLimitUnit *const data);
static bool decode_VisionCore_TrafficInformation_Sign_Raw_speedLimitUnit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_Sign_Raw_bindingOfSpeed(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_BindingOfSpeed *const data);
static bool decode_VisionCore_TrafficInformation_Sign_Raw_bindingOfSpeed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_Sign_Raw_clearing(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignClearing *const data);
static bool decode_VisionCore_TrafficInformation_Sign_Raw_clearing(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_Sign_Raw_warning(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignWarning *const data);
static bool decode_VisionCore_TrafficInformation_Sign_Raw_warning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_Sign_Raw_noEntry(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignNoEntry *const data);
static bool decode_VisionCore_TrafficInformation_Sign_Raw_noEntry(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_Sign_Raw_arrow(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignArrow *const data);
static bool decode_VisionCore_TrafficInformation_Sign_Raw_arrow(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_Sign_Raw_roadType(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignRoadType *const data);
static bool decode_VisionCore_TrafficInformation_Sign_Raw_roadType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_Sign_Raw_chicane(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignChicane *const data);
static bool decode_VisionCore_TrafficInformation_Sign_Raw_chicane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_Sign_Raw_laneClosure(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignLaneClosure *const data);
static bool decode_VisionCore_TrafficInformation_Sign_Raw_laneClosure(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_Sign_Raw_attention(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignAttention *const data);
static bool decode_VisionCore_TrafficInformation_Sign_Raw_attention(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_Sign_Raw_confidence(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_TrafficInformation_Sign_Raw_confidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_StateInfo_Raw_availability(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_TsrAvailability *const data);
static bool decode_VisionCore_TrafficInformation_StateInfo_Raw_availability(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_StateInfo_Raw_inputError(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_TsrInputError *const data);
static bool decode_VisionCore_TrafficInformation_StateInfo_Raw_inputError(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSign_Raw_id(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_VisionCore_TrafficInformation_ValidatedSign_Raw_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSign_Raw_mainSign(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_Sign_Raw *const data);
static bool decode_VisionCore_TrafficInformation_ValidatedSign_Raw_mainSign(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSign_Raw_addons(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_AddOnSign_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_VisionCore_TrafficInformation_ValidatedSign_Raw_addons(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSign_Raw_constructionType(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_PhysicalSignType *const data);
static bool decode_VisionCore_TrafficInformation_ValidatedSign_Raw_constructionType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSign_Raw_position(qpb_ostream_t *const stream, const VisionCore_Common_Coord3_m_0_01_Raw *const data);
static bool decode_VisionCore_TrafficInformation_ValidatedSign_Raw_position(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSign_Raw_size(qpb_ostream_t *const stream, const VisionCore_Common_Size2_m_0_01_Raw *const data);
static bool decode_VisionCore_TrafficInformation_ValidatedSign_Raw_size(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSign_Raw_valid(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_TrafficInformation_ValidatedSign_Raw_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSign_id(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_VisionCore_TrafficInformation_ValidatedSign_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSign_mainSign(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_Sign *const data);
static bool decode_VisionCore_TrafficInformation_ValidatedSign_mainSign(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSign_addons(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_AddOnSign arrayData[], const qpb_size_t arraySize);
static bool decode_VisionCore_TrafficInformation_ValidatedSign_addons(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSign_constructionType(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_PhysicalSignType *const data);
static bool decode_VisionCore_TrafficInformation_ValidatedSign_constructionType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSign_position(qpb_ostream_t *const stream, const VisionCore_Common_Coord3_m_0_01 *const data);
static bool decode_VisionCore_TrafficInformation_ValidatedSign_position(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSign_size(qpb_ostream_t *const stream, const VisionCore_Common_Size2_m_0_01 *const data);
static bool decode_VisionCore_TrafficInformation_ValidatedSign_size(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSign_valid(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_TrafficInformation_ValidatedSign_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSignList_Raw_status(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_StateInfo_Raw *const data);
static bool decode_VisionCore_TrafficInformation_ValidatedSignList_Raw_status(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSignList_Raw_signs(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_ValidatedSign_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_VisionCore_TrafficInformation_ValidatedSignList_Raw_signs(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSignList_status(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_StateInfo *const data);
static bool decode_VisionCore_TrafficInformation_ValidatedSignList_status(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_TrafficInformation_ValidatedSignList_signs(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_ValidatedSign arrayData[], const qpb_size_t arraySize);
static bool decode_VisionCore_TrafficInformation_ValidatedSignList_signs(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);

#define VisionCore_TrafficInformation_AddOnSign_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t VisionCore_TrafficInformation_AddOnSign_Raw_decoders[VisionCore_TrafficInformation_AddOnSign_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficInformation_AddOnSign_Raw_type },
   { &decode_VisionCore_TrafficInformation_AddOnSign_Raw_confidence }
};

#define VisionCore_TrafficInformation_Sign_Raw_DECODERS_COUNT 14
const qpb_decoder_entry_t VisionCore_TrafficInformation_Sign_Raw_decoders[VisionCore_TrafficInformation_Sign_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficInformation_Sign_Raw_category },
   { &decode_VisionCore_TrafficInformation_Sign_Raw_speedLimit },
   { &decode_VisionCore_TrafficInformation_Sign_Raw_speedLimitUnit },
   { &decode_VisionCore_TrafficInformation_Sign_Raw_bindingOfSpeed },
   { &decode_VisionCore_TrafficInformation_Sign_Raw_clearing },
   { &decode_VisionCore_TrafficInformation_Sign_Raw_warning },
   { &decode_VisionCore_TrafficInformation_Sign_Raw_noEntry },
   { &decode_VisionCore_TrafficInformation_Sign_Raw_arrow },
   { &decode_VisionCore_TrafficInformation_Sign_Raw_roadType },
   { &decode_VisionCore_TrafficInformation_Sign_Raw_chicane },
   { &decode_VisionCore_TrafficInformation_Sign_Raw_laneClosure },
   { &decode_VisionCore_TrafficInformation_Sign_Raw_attention },
   { &decode_VisionCore_TrafficInformation_Sign_Raw_confidence }
};

#define VisionCore_TrafficInformation_StateInfo_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t VisionCore_TrafficInformation_StateInfo_Raw_decoders[VisionCore_TrafficInformation_StateInfo_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficInformation_StateInfo_Raw_availability },
   { &decode_VisionCore_TrafficInformation_StateInfo_Raw_inputError }
};

#define VisionCore_TrafficInformation_ValidatedSign_Raw_DECODERS_COUNT 8
const qpb_decoder_entry_t VisionCore_TrafficInformation_ValidatedSign_Raw_decoders[VisionCore_TrafficInformation_ValidatedSign_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficInformation_ValidatedSign_Raw_id },
   { &decode_VisionCore_TrafficInformation_ValidatedSign_Raw_mainSign },
   { &decode_VisionCore_TrafficInformation_ValidatedSign_Raw_addons },
   { &decode_VisionCore_TrafficInformation_ValidatedSign_Raw_constructionType },
   { &decode_VisionCore_TrafficInformation_ValidatedSign_Raw_position },
   { &decode_VisionCore_TrafficInformation_ValidatedSign_Raw_size },
   { &decode_VisionCore_TrafficInformation_ValidatedSign_Raw_valid }
};

#define VisionCore_TrafficInformation_ValidatedSign_DECODERS_COUNT 8
const qpb_decoder_entry_t VisionCore_TrafficInformation_ValidatedSign_decoders[VisionCore_TrafficInformation_ValidatedSign_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficInformation_ValidatedSign_id },
   { &decode_VisionCore_TrafficInformation_ValidatedSign_mainSign },
   { &decode_VisionCore_TrafficInformation_ValidatedSign_addons },
   { &decode_VisionCore_TrafficInformation_ValidatedSign_constructionType },
   { &decode_VisionCore_TrafficInformation_ValidatedSign_position },
   { &decode_VisionCore_TrafficInformation_ValidatedSign_size },
   { &decode_VisionCore_TrafficInformation_ValidatedSign_valid }
};

#define VisionCore_TrafficInformation_ValidatedSignList_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t VisionCore_TrafficInformation_ValidatedSignList_Raw_decoders[VisionCore_TrafficInformation_ValidatedSignList_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficInformation_ValidatedSignList_Raw_status },
   { &decode_VisionCore_TrafficInformation_ValidatedSignList_Raw_signs }
};

#define VisionCore_TrafficInformation_ValidatedSignList_DECODERS_COUNT 3
const qpb_decoder_entry_t VisionCore_TrafficInformation_ValidatedSignList_decoders[VisionCore_TrafficInformation_ValidatedSignList_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_TrafficInformation_ValidatedSignList_status },
   { &decode_VisionCore_TrafficInformation_ValidatedSignList_signs }
};

static inline void encode_VisionCore_TrafficInformation_AddOnSign_Raw_type(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_RestrictionSign *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_AddOnSign_Raw_type(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_AddOnSign_Raw*)data)->type, qpb_membersize(VisionCore_TrafficInformation_AddOnSign_Raw, type));
}

static inline void encode_VisionCore_TrafficInformation_AddOnSign_Raw_confidence(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_AddOnSign_Raw_confidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficInformation_AddOnSign_Raw*)data)->confidence, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficInformation_Sign_Raw_category(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignCategory *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_Sign_Raw_category(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_Sign_Raw*)data)->category, qpb_membersize(VisionCore_TrafficInformation_Sign_Raw, category));
}

static inline void encode_VisionCore_TrafficInformation_Sign_Raw_speedLimit(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_Sign_Raw_speedLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficInformation_Sign_Raw*)data)->speedLimit, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficInformation_Sign_Raw_speedLimitUnit(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SpeedLimitUnit *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_Sign_Raw_speedLimitUnit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_Sign_Raw*)data)->speedLimitUnit, qpb_membersize(VisionCore_TrafficInformation_Sign_Raw, speedLimitUnit));
}

static inline void encode_VisionCore_TrafficInformation_Sign_Raw_bindingOfSpeed(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_BindingOfSpeed *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_Sign_Raw_bindingOfSpeed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_Sign_Raw*)data)->bindingOfSpeed, qpb_membersize(VisionCore_TrafficInformation_Sign_Raw, bindingOfSpeed));
}

static inline void encode_VisionCore_TrafficInformation_Sign_Raw_clearing(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignClearing *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_Sign_Raw_clearing(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_Sign_Raw*)data)->clearing, qpb_membersize(VisionCore_TrafficInformation_Sign_Raw, clearing));
}

static inline void encode_VisionCore_TrafficInformation_Sign_Raw_warning(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignWarning *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_Sign_Raw_warning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_Sign_Raw*)data)->warning, qpb_membersize(VisionCore_TrafficInformation_Sign_Raw, warning));
}

static inline void encode_VisionCore_TrafficInformation_Sign_Raw_noEntry(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignNoEntry *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_Sign_Raw_noEntry(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_Sign_Raw*)data)->noEntry, qpb_membersize(VisionCore_TrafficInformation_Sign_Raw, noEntry));
}

static inline void encode_VisionCore_TrafficInformation_Sign_Raw_arrow(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignArrow *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_Sign_Raw_arrow(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_Sign_Raw*)data)->arrow, qpb_membersize(VisionCore_TrafficInformation_Sign_Raw, arrow));
}

static inline void encode_VisionCore_TrafficInformation_Sign_Raw_roadType(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignRoadType *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 72;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_Sign_Raw_roadType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_Sign_Raw*)data)->roadType, qpb_membersize(VisionCore_TrafficInformation_Sign_Raw, roadType));
}

static inline void encode_VisionCore_TrafficInformation_Sign_Raw_chicane(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignChicane *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 80;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_Sign_Raw_chicane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_Sign_Raw*)data)->chicane, qpb_membersize(VisionCore_TrafficInformation_Sign_Raw, chicane));
}

static inline void encode_VisionCore_TrafficInformation_Sign_Raw_laneClosure(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignLaneClosure *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 88;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_Sign_Raw_laneClosure(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_Sign_Raw*)data)->laneClosure, qpb_membersize(VisionCore_TrafficInformation_Sign_Raw, laneClosure));
}

static inline void encode_VisionCore_TrafficInformation_Sign_Raw_attention(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_SignAttention *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 96;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_Sign_Raw_attention(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_Sign_Raw*)data)->attention, qpb_membersize(VisionCore_TrafficInformation_Sign_Raw, attention));
}

static inline void encode_VisionCore_TrafficInformation_Sign_Raw_confidence(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 104;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_Sign_Raw_confidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficInformation_Sign_Raw*)data)->confidence, sizeof(uint8_t));
}

static inline void encode_VisionCore_TrafficInformation_StateInfo_Raw_availability(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_TsrAvailability *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_StateInfo_Raw_availability(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_StateInfo_Raw*)data)->availability, qpb_membersize(VisionCore_TrafficInformation_StateInfo_Raw, availability));
}

static inline void encode_VisionCore_TrafficInformation_StateInfo_Raw_inputError(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_TsrInputError *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_StateInfo_Raw_inputError(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_StateInfo_Raw*)data)->inputError, qpb_membersize(VisionCore_TrafficInformation_StateInfo_Raw, inputError));
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSign_Raw_id(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSign_Raw_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficInformation_ValidatedSign_Raw*)data)->id, sizeof(uint32_t));
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSign_Raw_mainSign(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_Sign_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficInformation_Sign_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSign_Raw_mainSign(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficInformation_Sign_Raw(&substream, &((VisionCore_TrafficInformation_ValidatedSign_Raw*)data)->mainSign);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSign_Raw_addons(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_AddOnSign_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 26;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_VisionCore_TrafficInformation_AddOnSign_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSign_Raw_addons(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((VisionCore_TrafficInformation_ValidatedSign_Raw*)data)->addons_count + 1) > 2)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_VisionCore_TrafficInformation_AddOnSign_Raw(&substream, &((VisionCore_TrafficInformation_ValidatedSign_Raw*)data)->addons[((VisionCore_TrafficInformation_ValidatedSign_Raw*)data)->addons_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSign_Raw_constructionType(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_PhysicalSignType *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSign_Raw_constructionType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_ValidatedSign_Raw*)data)->constructionType, qpb_membersize(VisionCore_TrafficInformation_ValidatedSign_Raw, constructionType));
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSign_Raw_position(qpb_ostream_t *const stream, const VisionCore_Common_Coord3_m_0_01_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 42;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Common_Coord3_m_0_01_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSign_Raw_position(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Common_Coord3_m_0_01_Raw(&substream, &((VisionCore_TrafficInformation_ValidatedSign_Raw*)data)->position);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSign_Raw_size(qpb_ostream_t *const stream, const VisionCore_Common_Size2_m_0_01_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 50;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Common_Size2_m_0_01_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSign_Raw_size(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Common_Size2_m_0_01_Raw(&substream, &((VisionCore_TrafficInformation_ValidatedSign_Raw*)data)->size);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSign_Raw_valid(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSign_Raw_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_ValidatedSign_Raw*)data)->valid, sizeof(bool));
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSign_id(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSign_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_TrafficInformation_ValidatedSign*)data)->id, sizeof(uint32_t));
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSign_mainSign(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_Sign *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficInformation_Sign(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSign_mainSign(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficInformation_Sign(&substream, &((VisionCore_TrafficInformation_ValidatedSign*)data)->mainSign);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSign_addons(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_AddOnSign arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 26;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_VisionCore_TrafficInformation_AddOnSign(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSign_addons(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((VisionCore_TrafficInformation_ValidatedSign*)data)->addons_count + 1) > 2)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_VisionCore_TrafficInformation_AddOnSign(&substream, &((VisionCore_TrafficInformation_ValidatedSign*)data)->addons[((VisionCore_TrafficInformation_ValidatedSign*)data)->addons_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSign_constructionType(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_PhysicalSignType *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSign_constructionType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_ValidatedSign*)data)->constructionType, qpb_membersize(VisionCore_TrafficInformation_ValidatedSign, constructionType));
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSign_position(qpb_ostream_t *const stream, const VisionCore_Common_Coord3_m_0_01 *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 42;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Common_Coord3_m_0_01(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSign_position(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Common_Coord3_m_0_01(&substream, &((VisionCore_TrafficInformation_ValidatedSign*)data)->position);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSign_size(qpb_ostream_t *const stream, const VisionCore_Common_Size2_m_0_01 *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 50;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Common_Size2_m_0_01(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSign_size(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Common_Size2_m_0_01(&substream, &((VisionCore_TrafficInformation_ValidatedSign*)data)->size);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSign_valid(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSign_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_TrafficInformation_ValidatedSign*)data)->valid, sizeof(bool));
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSignList_Raw_status(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_StateInfo_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficInformation_StateInfo_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSignList_Raw_status(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficInformation_StateInfo_Raw(&substream, &((VisionCore_TrafficInformation_ValidatedSignList_Raw*)data)->status);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSignList_Raw_signs(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_ValidatedSign_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 18;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_VisionCore_TrafficInformation_ValidatedSign_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSignList_Raw_signs(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((VisionCore_TrafficInformation_ValidatedSignList_Raw*)data)->signs_count + 1) > 16)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_VisionCore_TrafficInformation_ValidatedSign_Raw(&substream, &((VisionCore_TrafficInformation_ValidatedSignList_Raw*)data)->signs[((VisionCore_TrafficInformation_ValidatedSignList_Raw*)data)->signs_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSignList_status(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_StateInfo *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_TrafficInformation_StateInfo(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSignList_status(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_TrafficInformation_StateInfo(&substream, &((VisionCore_TrafficInformation_ValidatedSignList*)data)->status);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_TrafficInformation_ValidatedSignList_signs(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_ValidatedSign arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 18;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_VisionCore_TrafficInformation_ValidatedSign(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_VisionCore_TrafficInformation_ValidatedSignList_signs(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((VisionCore_TrafficInformation_ValidatedSignList*)data)->signs_count + 1) > 16)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_VisionCore_TrafficInformation_ValidatedSign(&substream, &((VisionCore_TrafficInformation_ValidatedSignList*)data)->signs[((VisionCore_TrafficInformation_ValidatedSignList*)data)->signs_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

/* Encoding / decoding functions */
bool encode_VisionCore_TrafficInformation_AddOnSign_Raw(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_AddOnSign_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficInformation_AddOnSign_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficInformation_AddOnSign_Raw_type(stream, &data->type);
   encode_VisionCore_TrafficInformation_AddOnSign_Raw_confidence(stream, &data->confidence);
   return true;
}

bool decode_VisionCore_TrafficInformation_AddOnSign_Raw(qpb_istream_t *const stream, VisionCore_TrafficInformation_AddOnSign_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficInformation_AddOnSign_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficInformation_AddOnSign_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficInformation_Sign_Raw(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_Sign_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficInformation_Sign_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficInformation_Sign_Raw_category(stream, &data->category);
   encode_VisionCore_TrafficInformation_Sign_Raw_speedLimit(stream, &data->speedLimit);
   encode_VisionCore_TrafficInformation_Sign_Raw_speedLimitUnit(stream, &data->speedLimitUnit);
   encode_VisionCore_TrafficInformation_Sign_Raw_bindingOfSpeed(stream, &data->bindingOfSpeed);
   encode_VisionCore_TrafficInformation_Sign_Raw_clearing(stream, &data->clearing);
   encode_VisionCore_TrafficInformation_Sign_Raw_warning(stream, &data->warning);
   encode_VisionCore_TrafficInformation_Sign_Raw_noEntry(stream, &data->noEntry);
   encode_VisionCore_TrafficInformation_Sign_Raw_arrow(stream, &data->arrow);
   encode_VisionCore_TrafficInformation_Sign_Raw_roadType(stream, &data->roadType);
   encode_VisionCore_TrafficInformation_Sign_Raw_chicane(stream, &data->chicane);
   encode_VisionCore_TrafficInformation_Sign_Raw_laneClosure(stream, &data->laneClosure);
   encode_VisionCore_TrafficInformation_Sign_Raw_attention(stream, &data->attention);
   encode_VisionCore_TrafficInformation_Sign_Raw_confidence(stream, &data->confidence);
   return true;
}

bool decode_VisionCore_TrafficInformation_Sign_Raw(qpb_istream_t *const stream, VisionCore_TrafficInformation_Sign_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficInformation_Sign_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficInformation_Sign_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficInformation_StateInfo_Raw(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_StateInfo_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficInformation_StateInfo_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficInformation_StateInfo_Raw_availability(stream, &data->availability);
   encode_VisionCore_TrafficInformation_StateInfo_Raw_inputError(stream, &data->inputError);
   return true;
}

bool decode_VisionCore_TrafficInformation_StateInfo_Raw(qpb_istream_t *const stream, VisionCore_TrafficInformation_StateInfo_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficInformation_StateInfo_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficInformation_StateInfo_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficInformation_ValidatedSign_Raw(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_ValidatedSign_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficInformation_ValidatedSign_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficInformation_ValidatedSign_Raw_id(stream, &data->id);
   encode_VisionCore_TrafficInformation_ValidatedSign_Raw_mainSign(stream, &data->mainSign);
   encode_VisionCore_TrafficInformation_ValidatedSign_Raw_addons(stream, data->addons, data->addons_count);
   encode_VisionCore_TrafficInformation_ValidatedSign_Raw_constructionType(stream, &data->constructionType);
   encode_VisionCore_TrafficInformation_ValidatedSign_Raw_position(stream, &data->position);
   encode_VisionCore_TrafficInformation_ValidatedSign_Raw_size(stream, &data->size);
   encode_VisionCore_TrafficInformation_ValidatedSign_Raw_valid(stream, &data->valid);
   return true;
}

bool decode_VisionCore_TrafficInformation_ValidatedSign_Raw(qpb_istream_t *const stream, VisionCore_TrafficInformation_ValidatedSign_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficInformation_ValidatedSign_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficInformation_ValidatedSign_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficInformation_ValidatedSign(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_ValidatedSign *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficInformation_ValidatedSign_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficInformation_ValidatedSign_Raw_id(stream, &data->id);
   encode_VisionCore_TrafficInformation_ValidatedSign_mainSign(stream, &data->mainSign);
   encode_VisionCore_TrafficInformation_ValidatedSign_addons(stream, data->addons, data->addons_count);
   encode_VisionCore_TrafficInformation_ValidatedSign_Raw_constructionType(stream, &data->constructionType);
   encode_VisionCore_TrafficInformation_ValidatedSign_position(stream, &data->position);
   encode_VisionCore_TrafficInformation_ValidatedSign_size(stream, &data->size);
   encode_VisionCore_TrafficInformation_ValidatedSign_Raw_valid(stream, &data->valid);
   return true;
}

bool decode_VisionCore_TrafficInformation_ValidatedSign(qpb_istream_t *const stream, VisionCore_TrafficInformation_ValidatedSign *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficInformation_ValidatedSign_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficInformation_ValidatedSign_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficInformation_ValidatedSignList_Raw(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_ValidatedSignList_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficInformation_ValidatedSignList_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficInformation_ValidatedSignList_Raw_status(stream, &data->status);
   encode_VisionCore_TrafficInformation_ValidatedSignList_Raw_signs(stream, data->signs, data->signs_count);
   return true;
}

bool decode_VisionCore_TrafficInformation_ValidatedSignList_Raw(qpb_istream_t *const stream, VisionCore_TrafficInformation_ValidatedSignList_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficInformation_ValidatedSignList_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficInformation_ValidatedSignList_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_TrafficInformation_ValidatedSignList(qpb_ostream_t *const stream, const VisionCore_TrafficInformation_ValidatedSignList *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_TrafficInformation_ValidatedSignList_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_TrafficInformation_ValidatedSignList_status(stream, &data->status);
   encode_VisionCore_TrafficInformation_ValidatedSignList_signs(stream, data->signs, data->signs_count);
   return true;
}

bool decode_VisionCore_TrafficInformation_ValidatedSignList(qpb_istream_t *const stream, VisionCore_TrafficInformation_ValidatedSignList *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_TrafficInformation_ValidatedSignList_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_TrafficInformation_ValidatedSignList_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

