/* Automatically generated qpb constant definitions */
/* Generated by Quick Protocol Buffers - 2 */

#include "VisionCore/Road/RoadBoundary.qpb.h"
#include "Tools/QuickProtobuf/qpb_decode.h"
#include "Tools/QuickProtobuf/qpb_encode.h"
#include "Tools/CSupport/ConversionSupport.h"

#if QPB_PROTO_HEADER_VERSION != 2
#error Regenerate this file with the current version of qpb generator.
#endif

#define F_0_000001           0.000001f
#define F_0_0000025          0.0000025f
#define F_0_000025           0.000025f
#define F_0_01               0.01f
#define F_0_1                0.1f

static inline void encode_VisionCore_Road_RoadBoundaryClothoid_Raw_lateralDistance(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_RoadBoundaryClothoid_Raw_lateralDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryClothoid_Raw_heading(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_RoadBoundaryClothoid_Raw_heading(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryClothoid_Raw_curvature(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_RoadBoundaryClothoid_Raw_curvature(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryClothoid_Raw_curvatureRate(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_RoadBoundaryClothoid_Raw_curvatureRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryClothoid_lateralDistance(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_RoadBoundaryClothoid_lateralDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryClothoid_heading(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_RoadBoundaryClothoid_heading(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryClothoid_curvature(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_RoadBoundaryClothoid_curvature(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryClothoid_curvatureRate(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_RoadBoundaryClothoid_curvatureRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_lateralDistanceVariance(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_lateralDistanceVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_headingVariance(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_headingVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_curvatureVariance(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_curvatureVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_curvatureRateVariance(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_curvatureRateVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryClothoidVariance_lateralDistanceVariance(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_RoadBoundaryClothoidVariance_lateralDistanceVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryClothoidVariance_headingVariance(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_RoadBoundaryClothoidVariance_headingVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryClothoidVariance_curvatureVariance(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_RoadBoundaryClothoidVariance_curvatureVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryClothoidVariance_curvatureRateVariance(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_RoadBoundaryClothoidVariance_curvatureRateVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_valid(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_id(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_detectionDistance(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_detectionDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_trackingStatus(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrackingStatus *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_trackingStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_modelError(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_modelError(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_measurementQuality(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_measurementQuality(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_clothoid(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryClothoid_Raw *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_clothoid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_isSafe(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_isSafe(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_clothoidVariance(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryClothoidVariance_Raw *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_clothoidVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_valid(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_id(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_detectionDistance(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_detectionDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_trackingStatus(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrackingStatus *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_trackingStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_modelError(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_modelError(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_measurementQuality(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_measurementQuality(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_clothoid(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryClothoid *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_clothoid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_isSafe(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_isSafe(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundaryTrack_clothoidVariance(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryClothoidVariance *const data);
static bool decode_VisionCore_Road_RoadBoundaryTrack_clothoidVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundary_Raw_leftTraversableRoadBoundary(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack_Raw *const data);
static bool decode_VisionCore_Road_RoadBoundary_Raw_leftTraversableRoadBoundary(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundary_Raw_rightTraversableRoadBoundary(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack_Raw *const data);
static bool decode_VisionCore_Road_RoadBoundary_Raw_rightTraversableRoadBoundary(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundary_Raw_leftNonTraversableRoadBoundary(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack_Raw *const data);
static bool decode_VisionCore_Road_RoadBoundary_Raw_leftNonTraversableRoadBoundary(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundary_Raw_rightNonTraversableRoadBoundary(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack_Raw *const data);
static bool decode_VisionCore_Road_RoadBoundary_Raw_rightNonTraversableRoadBoundary(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundary_leftTraversableRoadBoundary(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack *const data);
static bool decode_VisionCore_Road_RoadBoundary_leftTraversableRoadBoundary(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundary_rightTraversableRoadBoundary(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack *const data);
static bool decode_VisionCore_Road_RoadBoundary_rightTraversableRoadBoundary(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundary_leftNonTraversableRoadBoundary(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack *const data);
static bool decode_VisionCore_Road_RoadBoundary_leftNonTraversableRoadBoundary(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_RoadBoundary_rightNonTraversableRoadBoundary(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack *const data);
static bool decode_VisionCore_Road_RoadBoundary_rightNonTraversableRoadBoundary(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);

#define VisionCore_Road_RoadBoundaryClothoid_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t VisionCore_Road_RoadBoundaryClothoid_Raw_decoders[VisionCore_Road_RoadBoundaryClothoid_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_RoadBoundaryClothoid_Raw_lateralDistance },
   { &decode_VisionCore_Road_RoadBoundaryClothoid_Raw_heading },
   { &decode_VisionCore_Road_RoadBoundaryClothoid_Raw_curvature },
   { &decode_VisionCore_Road_RoadBoundaryClothoid_Raw_curvatureRate }
};

#define VisionCore_Road_RoadBoundaryClothoid_DECODERS_COUNT 5
const qpb_decoder_entry_t VisionCore_Road_RoadBoundaryClothoid_decoders[VisionCore_Road_RoadBoundaryClothoid_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_RoadBoundaryClothoid_lateralDistance },
   { &decode_VisionCore_Road_RoadBoundaryClothoid_heading },
   { &decode_VisionCore_Road_RoadBoundaryClothoid_curvature },
   { &decode_VisionCore_Road_RoadBoundaryClothoid_curvatureRate }
};

#define VisionCore_Road_RoadBoundaryClothoidVariance_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t VisionCore_Road_RoadBoundaryClothoidVariance_Raw_decoders[VisionCore_Road_RoadBoundaryClothoidVariance_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_lateralDistanceVariance },
   { &decode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_headingVariance },
   { &decode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_curvatureVariance },
   { &decode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_curvatureRateVariance }
};

#define VisionCore_Road_RoadBoundaryClothoidVariance_DECODERS_COUNT 5
const qpb_decoder_entry_t VisionCore_Road_RoadBoundaryClothoidVariance_decoders[VisionCore_Road_RoadBoundaryClothoidVariance_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_RoadBoundaryClothoidVariance_lateralDistanceVariance },
   { &decode_VisionCore_Road_RoadBoundaryClothoidVariance_headingVariance },
   { &decode_VisionCore_Road_RoadBoundaryClothoidVariance_curvatureVariance },
   { &decode_VisionCore_Road_RoadBoundaryClothoidVariance_curvatureRateVariance }
};

#define VisionCore_Road_RoadBoundaryTrack_Raw_DECODERS_COUNT 10
const qpb_decoder_entry_t VisionCore_Road_RoadBoundaryTrack_Raw_decoders[VisionCore_Road_RoadBoundaryTrack_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_RoadBoundaryTrack_Raw_valid },
   { &decode_VisionCore_Road_RoadBoundaryTrack_Raw_id },
   { &decode_VisionCore_Road_RoadBoundaryTrack_Raw_detectionDistance },
   { &decode_VisionCore_Road_RoadBoundaryTrack_Raw_trackingStatus },
   { &decode_VisionCore_Road_RoadBoundaryTrack_Raw_modelError },
   { &decode_VisionCore_Road_RoadBoundaryTrack_Raw_measurementQuality },
   { &decode_VisionCore_Road_RoadBoundaryTrack_Raw_clothoid },
   { &decode_VisionCore_Road_RoadBoundaryTrack_Raw_isSafe },
   { &decode_VisionCore_Road_RoadBoundaryTrack_Raw_clothoidVariance }
};

#define VisionCore_Road_RoadBoundaryTrack_DECODERS_COUNT 10
const qpb_decoder_entry_t VisionCore_Road_RoadBoundaryTrack_decoders[VisionCore_Road_RoadBoundaryTrack_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_RoadBoundaryTrack_valid },
   { &decode_VisionCore_Road_RoadBoundaryTrack_id },
   { &decode_VisionCore_Road_RoadBoundaryTrack_detectionDistance },
   { &decode_VisionCore_Road_RoadBoundaryTrack_trackingStatus },
   { &decode_VisionCore_Road_RoadBoundaryTrack_modelError },
   { &decode_VisionCore_Road_RoadBoundaryTrack_measurementQuality },
   { &decode_VisionCore_Road_RoadBoundaryTrack_clothoid },
   { &decode_VisionCore_Road_RoadBoundaryTrack_isSafe },
   { &decode_VisionCore_Road_RoadBoundaryTrack_clothoidVariance }
};

#define VisionCore_Road_RoadBoundary_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t VisionCore_Road_RoadBoundary_Raw_decoders[VisionCore_Road_RoadBoundary_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_RoadBoundary_Raw_leftTraversableRoadBoundary },
   { &decode_VisionCore_Road_RoadBoundary_Raw_rightTraversableRoadBoundary },
   { &decode_VisionCore_Road_RoadBoundary_Raw_leftNonTraversableRoadBoundary },
   { &decode_VisionCore_Road_RoadBoundary_Raw_rightNonTraversableRoadBoundary }
};

#define VisionCore_Road_RoadBoundary_DECODERS_COUNT 5
const qpb_decoder_entry_t VisionCore_Road_RoadBoundary_decoders[VisionCore_Road_RoadBoundary_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_RoadBoundary_leftTraversableRoadBoundary },
   { &decode_VisionCore_Road_RoadBoundary_rightTraversableRoadBoundary },
   { &decode_VisionCore_Road_RoadBoundary_leftNonTraversableRoadBoundary },
   { &decode_VisionCore_Road_RoadBoundary_rightNonTraversableRoadBoundary }
};

static inline void encode_VisionCore_Road_RoadBoundaryClothoid_Raw_lateralDistance(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryClothoid_Raw_lateralDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_RoadBoundaryClothoid_Raw*)data)->lateralDistance, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_RoadBoundaryClothoid_Raw_heading(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryClothoid_Raw_heading(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_RoadBoundaryClothoid_Raw*)data)->heading, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_RoadBoundaryClothoid_Raw_curvature(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryClothoid_Raw_curvature(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_RoadBoundaryClothoid_Raw*)data)->curvature, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_RoadBoundaryClothoid_Raw_curvatureRate(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryClothoid_Raw_curvatureRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_RoadBoundaryClothoid_Raw*)data)->curvatureRate, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_RoadBoundaryClothoid_lateralDistance(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_RoadBoundaryClothoid_Raw_lateralDistance(stream, &value);
}

static bool decode_VisionCore_Road_RoadBoundaryClothoid_lateralDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_RoadBoundaryClothoid*)data)->lateralDistance = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundaryClothoid_heading(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_000025, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_RoadBoundaryClothoid_Raw_heading(stream, &value);
}

static bool decode_VisionCore_Road_RoadBoundaryClothoid_heading(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_RoadBoundaryClothoid*)data)->heading = value * F_0_000025;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundaryClothoid_curvature(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_0000025, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_RoadBoundaryClothoid_Raw_curvature(stream, &value);
}

static bool decode_VisionCore_Road_RoadBoundaryClothoid_curvature(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_RoadBoundaryClothoid*)data)->curvature = value * F_0_0000025;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundaryClothoid_curvatureRate(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_000001, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_RoadBoundaryClothoid_Raw_curvatureRate(stream, &value);
}

static bool decode_VisionCore_Road_RoadBoundaryClothoid_curvatureRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_RoadBoundaryClothoid*)data)->curvatureRate = value * F_0_000001;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_lateralDistanceVariance(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_lateralDistanceVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_RoadBoundaryClothoidVariance_Raw*)data)->lateralDistanceVariance, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_headingVariance(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_headingVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_RoadBoundaryClothoidVariance_Raw*)data)->headingVariance, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_curvatureVariance(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_curvatureVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_RoadBoundaryClothoidVariance_Raw*)data)->curvatureVariance, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_curvatureRateVariance(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_curvatureRateVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_RoadBoundaryClothoidVariance_Raw*)data)->curvatureRateVariance, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_RoadBoundaryClothoidVariance_lateralDistanceVariance(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_lateralDistanceVariance(stream, &value);
}

static bool decode_VisionCore_Road_RoadBoundaryClothoidVariance_lateralDistanceVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_RoadBoundaryClothoidVariance*)data)->lateralDistanceVariance = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundaryClothoidVariance_headingVariance(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_000025, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_headingVariance(stream, &value);
}

static bool decode_VisionCore_Road_RoadBoundaryClothoidVariance_headingVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_RoadBoundaryClothoidVariance*)data)->headingVariance = value * F_0_000025;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundaryClothoidVariance_curvatureVariance(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_0000025, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_curvatureVariance(stream, &value);
}

static bool decode_VisionCore_Road_RoadBoundaryClothoidVariance_curvatureVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_RoadBoundaryClothoidVariance*)data)->curvatureVariance = value * F_0_0000025;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundaryClothoidVariance_curvatureRateVariance(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_000001, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_curvatureRateVariance(stream, &value);
}

static bool decode_VisionCore_Road_RoadBoundaryClothoidVariance_curvatureRateVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_RoadBoundaryClothoidVariance*)data)->curvatureRateVariance = value * F_0_000001;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_valid(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_RoadBoundaryTrack_Raw*)data)->valid, sizeof(bool));
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_id(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_RoadBoundaryTrack_Raw*)data)->id, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_detectionDistance(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_detectionDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_RoadBoundaryTrack_Raw*)data)->detectionDistance, sizeof(uint16_t));
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_trackingStatus(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrackingStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_trackingStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_RoadBoundaryTrack_Raw*)data)->trackingStatus, qpb_membersize(VisionCore_Road_RoadBoundaryTrack_Raw, trackingStatus));
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_modelError(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_modelError(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_RoadBoundaryTrack_Raw*)data)->modelError, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_measurementQuality(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_measurementQuality(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_RoadBoundaryTrack_Raw*)data)->measurementQuality, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_clothoid(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryClothoid_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 58;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_RoadBoundaryClothoid_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_clothoid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_RoadBoundaryClothoid_Raw(&substream, &((VisionCore_Road_RoadBoundaryTrack_Raw*)data)->clothoid);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_isSafe(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_isSafe(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_RoadBoundaryTrack_Raw*)data)->isSafe, sizeof(bool));
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_Raw_clothoidVariance(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryClothoidVariance_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 74;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_Raw_clothoidVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw(&substream, &((VisionCore_Road_RoadBoundaryTrack_Raw*)data)->clothoidVariance);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_valid(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_RoadBoundaryTrack*)data)->valid, sizeof(bool));
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_id(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_RoadBoundaryTrack*)data)->id, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_detectionDistance(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_1, 0, UINT16_MAX);
   encode_VisionCore_Road_RoadBoundaryTrack_Raw_detectionDistance(stream, &value);
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_detectionDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((VisionCore_Road_RoadBoundaryTrack*)data)->detectionDistance = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_trackingStatus(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrackingStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_trackingStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_RoadBoundaryTrack*)data)->trackingStatus, qpb_membersize(VisionCore_Road_RoadBoundaryTrack, trackingStatus));
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_modelError(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_01, 0, UINT8_MAX);
   encode_VisionCore_Road_RoadBoundaryTrack_Raw_modelError(stream, &value);
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_modelError(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_Road_RoadBoundaryTrack*)data)->modelError = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_measurementQuality(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_measurementQuality(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_RoadBoundaryTrack*)data)->measurementQuality, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_clothoid(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryClothoid *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 58;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_RoadBoundaryClothoid(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_clothoid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_RoadBoundaryClothoid(&substream, &((VisionCore_Road_RoadBoundaryTrack*)data)->clothoid);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_isSafe(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_isSafe(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_RoadBoundaryTrack*)data)->isSafe, sizeof(bool));
}

static inline void encode_VisionCore_Road_RoadBoundaryTrack_clothoidVariance(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryClothoidVariance *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 74;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_RoadBoundaryClothoidVariance(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_RoadBoundaryTrack_clothoidVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_RoadBoundaryClothoidVariance(&substream, &((VisionCore_Road_RoadBoundaryTrack*)data)->clothoidVariance);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundary_Raw_leftTraversableRoadBoundary(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_RoadBoundaryTrack_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_RoadBoundary_Raw_leftTraversableRoadBoundary(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_RoadBoundaryTrack_Raw(&substream, &((VisionCore_Road_RoadBoundary_Raw*)data)->leftTraversableRoadBoundary);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundary_Raw_rightTraversableRoadBoundary(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_RoadBoundaryTrack_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_RoadBoundary_Raw_rightTraversableRoadBoundary(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_RoadBoundaryTrack_Raw(&substream, &((VisionCore_Road_RoadBoundary_Raw*)data)->rightTraversableRoadBoundary);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundary_Raw_leftNonTraversableRoadBoundary(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_RoadBoundaryTrack_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_RoadBoundary_Raw_leftNonTraversableRoadBoundary(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_RoadBoundaryTrack_Raw(&substream, &((VisionCore_Road_RoadBoundary_Raw*)data)->leftNonTraversableRoadBoundary);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundary_Raw_rightNonTraversableRoadBoundary(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_RoadBoundaryTrack_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_RoadBoundary_Raw_rightNonTraversableRoadBoundary(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_RoadBoundaryTrack_Raw(&substream, &((VisionCore_Road_RoadBoundary_Raw*)data)->rightNonTraversableRoadBoundary);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundary_leftTraversableRoadBoundary(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_RoadBoundaryTrack(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_RoadBoundary_leftTraversableRoadBoundary(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_RoadBoundaryTrack(&substream, &((VisionCore_Road_RoadBoundary*)data)->leftTraversableRoadBoundary);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundary_rightTraversableRoadBoundary(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_RoadBoundaryTrack(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_RoadBoundary_rightTraversableRoadBoundary(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_RoadBoundaryTrack(&substream, &((VisionCore_Road_RoadBoundary*)data)->rightTraversableRoadBoundary);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundary_leftNonTraversableRoadBoundary(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_RoadBoundaryTrack(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_RoadBoundary_leftNonTraversableRoadBoundary(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_RoadBoundaryTrack(&substream, &((VisionCore_Road_RoadBoundary*)data)->leftNonTraversableRoadBoundary);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_RoadBoundary_rightNonTraversableRoadBoundary(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_RoadBoundaryTrack(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_RoadBoundary_rightNonTraversableRoadBoundary(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_RoadBoundaryTrack(&substream, &((VisionCore_Road_RoadBoundary*)data)->rightNonTraversableRoadBoundary);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

/* Encoding / decoding functions */
bool encode_VisionCore_Road_RoadBoundaryClothoid_Raw(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryClothoid_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_RoadBoundaryClothoid_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_RoadBoundaryClothoid_Raw_lateralDistance(stream, &data->lateralDistance);
   encode_VisionCore_Road_RoadBoundaryClothoid_Raw_heading(stream, &data->heading);
   encode_VisionCore_Road_RoadBoundaryClothoid_Raw_curvature(stream, &data->curvature);
   encode_VisionCore_Road_RoadBoundaryClothoid_Raw_curvatureRate(stream, &data->curvatureRate);
   return true;
}

bool decode_VisionCore_Road_RoadBoundaryClothoid_Raw(qpb_istream_t *const stream, VisionCore_Road_RoadBoundaryClothoid_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_RoadBoundaryClothoid_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_RoadBoundaryClothoid_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_RoadBoundaryClothoid(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryClothoid *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_RoadBoundaryClothoid_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_RoadBoundaryClothoid_lateralDistance(stream, &data->lateralDistance);
   encode_VisionCore_Road_RoadBoundaryClothoid_heading(stream, &data->heading);
   encode_VisionCore_Road_RoadBoundaryClothoid_curvature(stream, &data->curvature);
   encode_VisionCore_Road_RoadBoundaryClothoid_curvatureRate(stream, &data->curvatureRate);
   return true;
}

bool decode_VisionCore_Road_RoadBoundaryClothoid(qpb_istream_t *const stream, VisionCore_Road_RoadBoundaryClothoid *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_RoadBoundaryClothoid_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_RoadBoundaryClothoid_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryClothoidVariance_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_RoadBoundaryClothoidVariance_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_lateralDistanceVariance(stream, &data->lateralDistanceVariance);
   encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_headingVariance(stream, &data->headingVariance);
   encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_curvatureVariance(stream, &data->curvatureVariance);
   encode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw_curvatureRateVariance(stream, &data->curvatureRateVariance);
   return true;
}

bool decode_VisionCore_Road_RoadBoundaryClothoidVariance_Raw(qpb_istream_t *const stream, VisionCore_Road_RoadBoundaryClothoidVariance_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_RoadBoundaryClothoidVariance_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_RoadBoundaryClothoidVariance_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_RoadBoundaryClothoidVariance(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryClothoidVariance *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_RoadBoundaryClothoidVariance_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_RoadBoundaryClothoidVariance_lateralDistanceVariance(stream, &data->lateralDistanceVariance);
   encode_VisionCore_Road_RoadBoundaryClothoidVariance_headingVariance(stream, &data->headingVariance);
   encode_VisionCore_Road_RoadBoundaryClothoidVariance_curvatureVariance(stream, &data->curvatureVariance);
   encode_VisionCore_Road_RoadBoundaryClothoidVariance_curvatureRateVariance(stream, &data->curvatureRateVariance);
   return true;
}

bool decode_VisionCore_Road_RoadBoundaryClothoidVariance(qpb_istream_t *const stream, VisionCore_Road_RoadBoundaryClothoidVariance *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_RoadBoundaryClothoidVariance_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_RoadBoundaryClothoidVariance_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_RoadBoundaryTrack_Raw(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_RoadBoundaryTrack_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_RoadBoundaryTrack_Raw_valid(stream, &data->valid);
   encode_VisionCore_Road_RoadBoundaryTrack_Raw_id(stream, &data->id);
   encode_VisionCore_Road_RoadBoundaryTrack_Raw_detectionDistance(stream, &data->detectionDistance);
   encode_VisionCore_Road_RoadBoundaryTrack_Raw_trackingStatus(stream, &data->trackingStatus);
   encode_VisionCore_Road_RoadBoundaryTrack_Raw_modelError(stream, &data->modelError);
   encode_VisionCore_Road_RoadBoundaryTrack_Raw_measurementQuality(stream, &data->measurementQuality);
   encode_VisionCore_Road_RoadBoundaryTrack_Raw_clothoid(stream, &data->clothoid);
   encode_VisionCore_Road_RoadBoundaryTrack_Raw_isSafe(stream, &data->isSafe);
   encode_VisionCore_Road_RoadBoundaryTrack_Raw_clothoidVariance(stream, &data->clothoidVariance);
   return true;
}

bool decode_VisionCore_Road_RoadBoundaryTrack_Raw(qpb_istream_t *const stream, VisionCore_Road_RoadBoundaryTrack_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_RoadBoundaryTrack_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_RoadBoundaryTrack_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_RoadBoundaryTrack(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundaryTrack *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_RoadBoundaryTrack_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_RoadBoundaryTrack_Raw_valid(stream, &data->valid);
   encode_VisionCore_Road_RoadBoundaryTrack_Raw_id(stream, &data->id);
   encode_VisionCore_Road_RoadBoundaryTrack_detectionDistance(stream, &data->detectionDistance);
   encode_VisionCore_Road_RoadBoundaryTrack_Raw_trackingStatus(stream, &data->trackingStatus);
   encode_VisionCore_Road_RoadBoundaryTrack_modelError(stream, &data->modelError);
   encode_VisionCore_Road_RoadBoundaryTrack_Raw_measurementQuality(stream, &data->measurementQuality);
   encode_VisionCore_Road_RoadBoundaryTrack_clothoid(stream, &data->clothoid);
   encode_VisionCore_Road_RoadBoundaryTrack_Raw_isSafe(stream, &data->isSafe);
   encode_VisionCore_Road_RoadBoundaryTrack_clothoidVariance(stream, &data->clothoidVariance);
   return true;
}

bool decode_VisionCore_Road_RoadBoundaryTrack(qpb_istream_t *const stream, VisionCore_Road_RoadBoundaryTrack *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_RoadBoundaryTrack_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_RoadBoundaryTrack_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_RoadBoundary_Raw(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundary_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_RoadBoundary_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_RoadBoundary_Raw_leftTraversableRoadBoundary(stream, &data->leftTraversableRoadBoundary);
   encode_VisionCore_Road_RoadBoundary_Raw_rightTraversableRoadBoundary(stream, &data->rightTraversableRoadBoundary);
   encode_VisionCore_Road_RoadBoundary_Raw_leftNonTraversableRoadBoundary(stream, &data->leftNonTraversableRoadBoundary);
   encode_VisionCore_Road_RoadBoundary_Raw_rightNonTraversableRoadBoundary(stream, &data->rightNonTraversableRoadBoundary);
   return true;
}

bool decode_VisionCore_Road_RoadBoundary_Raw(qpb_istream_t *const stream, VisionCore_Road_RoadBoundary_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_RoadBoundary_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_RoadBoundary_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_RoadBoundary(qpb_ostream_t *const stream, const VisionCore_Road_RoadBoundary *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_RoadBoundary_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_RoadBoundary_leftTraversableRoadBoundary(stream, &data->leftTraversableRoadBoundary);
   encode_VisionCore_Road_RoadBoundary_rightTraversableRoadBoundary(stream, &data->rightTraversableRoadBoundary);
   encode_VisionCore_Road_RoadBoundary_leftNonTraversableRoadBoundary(stream, &data->leftNonTraversableRoadBoundary);
   encode_VisionCore_Road_RoadBoundary_rightNonTraversableRoadBoundary(stream, &data->rightNonTraversableRoadBoundary);
   return true;
}

bool decode_VisionCore_Road_RoadBoundary(qpb_istream_t *const stream, VisionCore_Road_RoadBoundary *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_RoadBoundary_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_RoadBoundary_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

