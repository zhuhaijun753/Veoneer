/* Automatically generated qpb constant definitions */
/* Generated by Quick Protocol Buffers - 2 */

#include "VisionCore/Road/LaneOutput.qpb.h"
#include "Tools/QuickProtobuf/qpb_decode.h"
#include "Tools/QuickProtobuf/qpb_encode.h"
#include "Tools/CSupport/ConversionSupport.h"

#if QPB_PROTO_HEADER_VERSION != 2
#error Regenerate this file with the current version of qpb generator.
#endif

#define F_0_000001           0.000001f
#define F_0_0000025          0.0000025f
#define F_0_000025           0.000025f
#define F_0_01               0.01f
#define F_0_05               0.05f
#define F_0_1                0.1f

static inline void encode_VisionCore_Road_Clothoid_Raw_lateralDistance(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_Clothoid_Raw_lateralDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_Clothoid_Raw_heading(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_Clothoid_Raw_heading(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_Clothoid_Raw_curvature(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_Clothoid_Raw_curvature(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_Clothoid_Raw_curvatureRate(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_Clothoid_Raw_curvatureRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_Clothoid_Raw_transitionDistance(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_VisionCore_Road_Clothoid_Raw_transitionDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_Clothoid_Raw_curvatureRateSecondClothoid(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_Clothoid_Raw_curvatureRateSecondClothoid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_Clothoid_Raw_secondClothoidActive(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Road_Clothoid_Raw_secondClothoidActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_Clothoid_lateralDistance(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_Clothoid_lateralDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_Clothoid_heading(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_Clothoid_heading(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_Clothoid_curvature(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_Clothoid_curvature(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_Clothoid_curvatureRate(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_Clothoid_curvatureRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_Clothoid_transitionDistance(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_Clothoid_transitionDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_Clothoid_curvatureRateSecondClothoid(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_Clothoid_curvatureRateSecondClothoid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_Clothoid_secondClothoidActive(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Road_Clothoid_secondClothoidActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_ClothoidVariance_Raw_lateralDistanceVariance(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_ClothoidVariance_Raw_lateralDistanceVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_ClothoidVariance_Raw_headingVariance(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_ClothoidVariance_Raw_headingVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_ClothoidVariance_Raw_curvatureVariance(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_ClothoidVariance_Raw_curvatureVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_ClothoidVariance_Raw_curvatureRateVariance(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_ClothoidVariance_Raw_curvatureRateVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_ClothoidVariance_Raw_curvatureRateSecondClothoidVariance(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Road_ClothoidVariance_Raw_curvatureRateSecondClothoidVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_ClothoidVariance_lateralDistanceVariance(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_ClothoidVariance_lateralDistanceVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_ClothoidVariance_headingVariance(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_ClothoidVariance_headingVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_ClothoidVariance_curvatureVariance(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_ClothoidVariance_curvatureVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_ClothoidVariance_curvatureRateVariance(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_ClothoidVariance_curvatureRateVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_ClothoidVariance_curvatureRateSecondClothoidVariance(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_ClothoidVariance_curvatureRateSecondClothoidVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneEvent_Raw_id(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneEvent_Raw_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneEvent_Raw_laneTrackId(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneEvent_Raw_laneTrackId(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneEvent_Raw_distance(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_VisionCore_Road_LaneEvent_Raw_distance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneEvent_Raw_eventType(qpb_ostream_t *const stream, const VisionCore_Road_LaneEventType *const data);
static bool decode_VisionCore_Road_LaneEvent_Raw_eventType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneEvent_Raw_side(qpb_ostream_t *const stream, const VisionCore_Road_LaneEventSide *const data);
static bool decode_VisionCore_Road_LaneEvent_Raw_side(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneEvent_id(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneEvent_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneEvent_laneTrackId(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneEvent_laneTrackId(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneEvent_distance(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_LaneEvent_distance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneEvent_eventType(qpb_ostream_t *const stream, const VisionCore_Road_LaneEventType *const data);
static bool decode_VisionCore_Road_LaneEvent_eventType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneEvent_side(qpb_ostream_t *const stream, const VisionCore_Road_LaneEventSide *const data);
static bool decode_VisionCore_Road_LaneEvent_side(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_TemporaryMarkings_Raw_type(qpb_ostream_t *const stream, const VisionCore_Road_TemporaryMarkingType *const data);
static bool decode_VisionCore_Road_TemporaryMarkings_Raw_type(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_TemporaryMarkings_Raw_longitudinalDistance(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_VisionCore_Road_TemporaryMarkings_Raw_longitudinalDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_TemporaryMarkings_type(qpb_ostream_t *const stream, const VisionCore_Road_TemporaryMarkingType *const data);
static bool decode_VisionCore_Road_TemporaryMarkings_type(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_TemporaryMarkings_longitudinalDistance(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_TemporaryMarkings_longitudinalDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_valid(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_id(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_detectionDistance(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_detectionDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_markingType(qpb_ostream_t *const stream, const VisionCore_Road_MarkingType *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_markingType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_markingLength(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_markingLength(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_gapLength(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_gapLength(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_secondMarkingType(qpb_ostream_t *const stream, const VisionCore_Road_SecondMarkingType *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_secondMarkingType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_markingStructure(qpb_ostream_t *const stream, const VisionCore_Road_MarkingStructure *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_markingStructure(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_trackingStatus(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrackingStatus *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_trackingStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_markingWidth(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_markingWidth(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_totalMarkingWidth(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_totalMarkingWidth(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_color(qpb_ostream_t *const stream, const VisionCore_Road_LaneMarkingColor *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_color(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_modelError(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_modelError(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_measurementQuality(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_measurementQuality(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_selectionConfidence(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_selectionConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_distanceFirstToSecondMarking(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_distanceFirstToSecondMarking(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_clothoid(qpb_ostream_t *const stream, const VisionCore_Road_Clothoid_Raw *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_clothoid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_isSafe(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_isSafe(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_unsafeReason(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_unsafeReason(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_Raw_clothoidVariance(qpb_ostream_t *const stream, const VisionCore_Road_ClothoidVariance_Raw *const data);
static bool decode_VisionCore_Road_LaneTrack_Raw_clothoidVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_valid(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Road_LaneTrack_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_id(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneTrack_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_detectionDistance(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_LaneTrack_detectionDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_markingType(qpb_ostream_t *const stream, const VisionCore_Road_MarkingType *const data);
static bool decode_VisionCore_Road_LaneTrack_markingType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_markingLength(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_LaneTrack_markingLength(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_gapLength(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_LaneTrack_gapLength(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_secondMarkingType(qpb_ostream_t *const stream, const VisionCore_Road_SecondMarkingType *const data);
static bool decode_VisionCore_Road_LaneTrack_secondMarkingType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_markingStructure(qpb_ostream_t *const stream, const VisionCore_Road_MarkingStructure *const data);
static bool decode_VisionCore_Road_LaneTrack_markingStructure(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_trackingStatus(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrackingStatus *const data);
static bool decode_VisionCore_Road_LaneTrack_trackingStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_markingWidth(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_LaneTrack_markingWidth(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_totalMarkingWidth(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_LaneTrack_totalMarkingWidth(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_color(qpb_ostream_t *const stream, const VisionCore_Road_LaneMarkingColor *const data);
static bool decode_VisionCore_Road_LaneTrack_color(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_modelError(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_LaneTrack_modelError(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_measurementQuality(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneTrack_measurementQuality(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_selectionConfidence(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneTrack_selectionConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_distanceFirstToSecondMarking(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_LaneTrack_distanceFirstToSecondMarking(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_clothoid(qpb_ostream_t *const stream, const VisionCore_Road_Clothoid *const data);
static bool decode_VisionCore_Road_LaneTrack_clothoid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_isSafe(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Road_LaneTrack_isSafe(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_unsafeReason(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_VisionCore_Road_LaneTrack_unsafeReason(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneTrack_clothoidVariance(qpb_ostream_t *const stream, const VisionCore_Road_ClothoidVariance *const data);
static bool decode_VisionCore_Road_LaneTrack_clothoidVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_EgoLane_Raw_left(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack_Raw *const data);
static bool decode_VisionCore_Road_EgoLane_Raw_left(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_EgoLane_Raw_right(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack_Raw *const data);
static bool decode_VisionCore_Road_EgoLane_Raw_right(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_EgoLane_Raw_parallelDistance(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_VisionCore_Road_EgoLane_Raw_parallelDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_EgoLane_left(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack *const data);
static bool decode_VisionCore_Road_EgoLane_left(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_EgoLane_right(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack *const data);
static bool decode_VisionCore_Road_EgoLane_right(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_EgoLane_parallelDistance(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Road_EgoLane_parallelDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_Raw_egoLane(qpb_ostream_t *const stream, const VisionCore_Road_EgoLane_Raw *const data);
static bool decode_VisionCore_Road_LaneOutput_Raw_egoLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_Raw_coupledEgoLane(qpb_ostream_t *const stream, const VisionCore_Road_EgoLane_Raw *const data);
static bool decode_VisionCore_Road_LaneOutput_Raw_coupledEgoLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_Raw_neighborLeft(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack_Raw *const data);
static bool decode_VisionCore_Road_LaneOutput_Raw_neighborLeft(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_Raw_neighborRight(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack_Raw *const data);
static bool decode_VisionCore_Road_LaneOutput_Raw_neighborRight(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_Raw_events(qpb_ostream_t *const stream, const VisionCore_Road_LaneEvent_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_VisionCore_Road_LaneOutput_Raw_events(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_Raw_temporaryMarkings(qpb_ostream_t *const stream, const VisionCore_Road_TemporaryMarkings_Raw *const data);
static bool decode_VisionCore_Road_LaneOutput_Raw_temporaryMarkings(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_Raw_sideSuggestion(qpb_ostream_t *const stream, const VisionCore_Road_SideSuggestion *const data);
static bool decode_VisionCore_Road_LaneOutput_Raw_sideSuggestion(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_Raw_laneChange(qpb_ostream_t *const stream, const VisionCore_Road_LaneChange *const data);
static bool decode_VisionCore_Road_LaneOutput_Raw_laneChange(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_Raw_frameDrop(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Road_LaneOutput_Raw_frameDrop(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_Raw_blockageDuration(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_VisionCore_Road_LaneOutput_Raw_blockageDuration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_Raw_selfAssessmentFailed(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Road_LaneOutput_Raw_selfAssessmentFailed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_Raw_attentionMarkers(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Road_LaneOutput_Raw_attentionMarkers(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_Raw_operationMode(qpb_ostream_t *const stream, const VisionCore_Road_LaneOperationMode *const data);
static bool decode_VisionCore_Road_LaneOutput_Raw_operationMode(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_egoLane(qpb_ostream_t *const stream, const VisionCore_Road_EgoLane *const data);
static bool decode_VisionCore_Road_LaneOutput_egoLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_coupledEgoLane(qpb_ostream_t *const stream, const VisionCore_Road_EgoLane *const data);
static bool decode_VisionCore_Road_LaneOutput_coupledEgoLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_neighborLeft(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack *const data);
static bool decode_VisionCore_Road_LaneOutput_neighborLeft(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_neighborRight(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack *const data);
static bool decode_VisionCore_Road_LaneOutput_neighborRight(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_events(qpb_ostream_t *const stream, const VisionCore_Road_LaneEvent arrayData[], const qpb_size_t arraySize);
static bool decode_VisionCore_Road_LaneOutput_events(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_temporaryMarkings(qpb_ostream_t *const stream, const VisionCore_Road_TemporaryMarkings *const data);
static bool decode_VisionCore_Road_LaneOutput_temporaryMarkings(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_sideSuggestion(qpb_ostream_t *const stream, const VisionCore_Road_SideSuggestion *const data);
static bool decode_VisionCore_Road_LaneOutput_sideSuggestion(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_laneChange(qpb_ostream_t *const stream, const VisionCore_Road_LaneChange *const data);
static bool decode_VisionCore_Road_LaneOutput_laneChange(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_frameDrop(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Road_LaneOutput_frameDrop(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_blockageDuration(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_VisionCore_Road_LaneOutput_blockageDuration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_selfAssessmentFailed(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Road_LaneOutput_selfAssessmentFailed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_attentionMarkers(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Road_LaneOutput_attentionMarkers(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Road_LaneOutput_operationMode(qpb_ostream_t *const stream, const VisionCore_Road_LaneOperationMode *const data);
static bool decode_VisionCore_Road_LaneOutput_operationMode(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);

#define VisionCore_Road_Clothoid_Raw_DECODERS_COUNT 8
const qpb_decoder_entry_t VisionCore_Road_Clothoid_Raw_decoders[VisionCore_Road_Clothoid_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_Clothoid_Raw_lateralDistance },
   { &decode_VisionCore_Road_Clothoid_Raw_heading },
   { &decode_VisionCore_Road_Clothoid_Raw_curvature },
   { &decode_VisionCore_Road_Clothoid_Raw_curvatureRate },
   { &decode_VisionCore_Road_Clothoid_Raw_transitionDistance },
   { &decode_VisionCore_Road_Clothoid_Raw_curvatureRateSecondClothoid },
   { &decode_VisionCore_Road_Clothoid_Raw_secondClothoidActive }
};

#define VisionCore_Road_Clothoid_DECODERS_COUNT 8
const qpb_decoder_entry_t VisionCore_Road_Clothoid_decoders[VisionCore_Road_Clothoid_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_Clothoid_lateralDistance },
   { &decode_VisionCore_Road_Clothoid_heading },
   { &decode_VisionCore_Road_Clothoid_curvature },
   { &decode_VisionCore_Road_Clothoid_curvatureRate },
   { &decode_VisionCore_Road_Clothoid_transitionDistance },
   { &decode_VisionCore_Road_Clothoid_curvatureRateSecondClothoid },
   { &decode_VisionCore_Road_Clothoid_secondClothoidActive }
};

#define VisionCore_Road_ClothoidVariance_Raw_DECODERS_COUNT 6
const qpb_decoder_entry_t VisionCore_Road_ClothoidVariance_Raw_decoders[VisionCore_Road_ClothoidVariance_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_ClothoidVariance_Raw_lateralDistanceVariance },
   { &decode_VisionCore_Road_ClothoidVariance_Raw_headingVariance },
   { &decode_VisionCore_Road_ClothoidVariance_Raw_curvatureVariance },
   { &decode_VisionCore_Road_ClothoidVariance_Raw_curvatureRateVariance },
   { &decode_VisionCore_Road_ClothoidVariance_Raw_curvatureRateSecondClothoidVariance }
};

#define VisionCore_Road_ClothoidVariance_DECODERS_COUNT 6
const qpb_decoder_entry_t VisionCore_Road_ClothoidVariance_decoders[VisionCore_Road_ClothoidVariance_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_ClothoidVariance_lateralDistanceVariance },
   { &decode_VisionCore_Road_ClothoidVariance_headingVariance },
   { &decode_VisionCore_Road_ClothoidVariance_curvatureVariance },
   { &decode_VisionCore_Road_ClothoidVariance_curvatureRateVariance },
   { &decode_VisionCore_Road_ClothoidVariance_curvatureRateSecondClothoidVariance }
};

#define VisionCore_Road_LaneEvent_Raw_DECODERS_COUNT 6
const qpb_decoder_entry_t VisionCore_Road_LaneEvent_Raw_decoders[VisionCore_Road_LaneEvent_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_LaneEvent_Raw_id },
   { &decode_VisionCore_Road_LaneEvent_Raw_laneTrackId },
   { &decode_VisionCore_Road_LaneEvent_Raw_distance },
   { &decode_VisionCore_Road_LaneEvent_Raw_eventType },
   { &decode_VisionCore_Road_LaneEvent_Raw_side }
};

#define VisionCore_Road_LaneEvent_DECODERS_COUNT 6
const qpb_decoder_entry_t VisionCore_Road_LaneEvent_decoders[VisionCore_Road_LaneEvent_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_LaneEvent_id },
   { &decode_VisionCore_Road_LaneEvent_laneTrackId },
   { &decode_VisionCore_Road_LaneEvent_distance },
   { &decode_VisionCore_Road_LaneEvent_eventType },
   { &decode_VisionCore_Road_LaneEvent_side }
};

#define VisionCore_Road_TemporaryMarkings_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t VisionCore_Road_TemporaryMarkings_Raw_decoders[VisionCore_Road_TemporaryMarkings_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_TemporaryMarkings_Raw_type },
   { &decode_VisionCore_Road_TemporaryMarkings_Raw_longitudinalDistance }
};

#define VisionCore_Road_TemporaryMarkings_DECODERS_COUNT 3
const qpb_decoder_entry_t VisionCore_Road_TemporaryMarkings_decoders[VisionCore_Road_TemporaryMarkings_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_TemporaryMarkings_type },
   { &decode_VisionCore_Road_TemporaryMarkings_longitudinalDistance }
};

#define VisionCore_Road_LaneTrack_Raw_DECODERS_COUNT 21
const qpb_decoder_entry_t VisionCore_Road_LaneTrack_Raw_decoders[VisionCore_Road_LaneTrack_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_LaneTrack_Raw_valid },
   { &decode_VisionCore_Road_LaneTrack_Raw_id },
   { &decode_VisionCore_Road_LaneTrack_Raw_detectionDistance },
   { &decode_VisionCore_Road_LaneTrack_Raw_markingType },
   { &decode_VisionCore_Road_LaneTrack_Raw_markingLength },
   { &decode_VisionCore_Road_LaneTrack_Raw_gapLength },
   { &decode_VisionCore_Road_LaneTrack_Raw_secondMarkingType },
   { &decode_VisionCore_Road_LaneTrack_Raw_markingStructure },
   { &decode_VisionCore_Road_LaneTrack_Raw_trackingStatus },
   { &decode_VisionCore_Road_LaneTrack_Raw_markingWidth },
   { &decode_VisionCore_Road_LaneTrack_Raw_totalMarkingWidth },
   { &decode_VisionCore_Road_LaneTrack_Raw_color },
   { &decode_VisionCore_Road_LaneTrack_Raw_modelError },
   { &decode_VisionCore_Road_LaneTrack_Raw_measurementQuality },
   { &decode_VisionCore_Road_LaneTrack_Raw_selectionConfidence },
   { &decode_VisionCore_Road_LaneTrack_Raw_distanceFirstToSecondMarking },
   { &decode_VisionCore_Road_LaneTrack_Raw_clothoid },
   { &decode_VisionCore_Road_LaneTrack_Raw_isSafe },
   { &decode_VisionCore_Road_LaneTrack_Raw_unsafeReason },
   { &decode_VisionCore_Road_LaneTrack_Raw_clothoidVariance }
};

#define VisionCore_Road_LaneTrack_DECODERS_COUNT 21
const qpb_decoder_entry_t VisionCore_Road_LaneTrack_decoders[VisionCore_Road_LaneTrack_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_LaneTrack_valid },
   { &decode_VisionCore_Road_LaneTrack_id },
   { &decode_VisionCore_Road_LaneTrack_detectionDistance },
   { &decode_VisionCore_Road_LaneTrack_markingType },
   { &decode_VisionCore_Road_LaneTrack_markingLength },
   { &decode_VisionCore_Road_LaneTrack_gapLength },
   { &decode_VisionCore_Road_LaneTrack_secondMarkingType },
   { &decode_VisionCore_Road_LaneTrack_markingStructure },
   { &decode_VisionCore_Road_LaneTrack_trackingStatus },
   { &decode_VisionCore_Road_LaneTrack_markingWidth },
   { &decode_VisionCore_Road_LaneTrack_totalMarkingWidth },
   { &decode_VisionCore_Road_LaneTrack_color },
   { &decode_VisionCore_Road_LaneTrack_modelError },
   { &decode_VisionCore_Road_LaneTrack_measurementQuality },
   { &decode_VisionCore_Road_LaneTrack_selectionConfidence },
   { &decode_VisionCore_Road_LaneTrack_distanceFirstToSecondMarking },
   { &decode_VisionCore_Road_LaneTrack_clothoid },
   { &decode_VisionCore_Road_LaneTrack_isSafe },
   { &decode_VisionCore_Road_LaneTrack_unsafeReason },
   { &decode_VisionCore_Road_LaneTrack_clothoidVariance }
};

#define VisionCore_Road_EgoLane_Raw_DECODERS_COUNT 4
const qpb_decoder_entry_t VisionCore_Road_EgoLane_Raw_decoders[VisionCore_Road_EgoLane_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_EgoLane_Raw_left },
   { &decode_VisionCore_Road_EgoLane_Raw_right },
   { &decode_VisionCore_Road_EgoLane_Raw_parallelDistance }
};

#define VisionCore_Road_EgoLane_DECODERS_COUNT 4
const qpb_decoder_entry_t VisionCore_Road_EgoLane_decoders[VisionCore_Road_EgoLane_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_EgoLane_left },
   { &decode_VisionCore_Road_EgoLane_right },
   { &decode_VisionCore_Road_EgoLane_parallelDistance }
};

#define VisionCore_Road_LaneOutput_Raw_DECODERS_COUNT 14
const qpb_decoder_entry_t VisionCore_Road_LaneOutput_Raw_decoders[VisionCore_Road_LaneOutput_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_LaneOutput_Raw_egoLane },
   { &decode_VisionCore_Road_LaneOutput_Raw_coupledEgoLane },
   { &decode_VisionCore_Road_LaneOutput_Raw_neighborLeft },
   { &decode_VisionCore_Road_LaneOutput_Raw_neighborRight },
   { &decode_VisionCore_Road_LaneOutput_Raw_events },
   { &decode_VisionCore_Road_LaneOutput_Raw_temporaryMarkings },
   { &decode_VisionCore_Road_LaneOutput_Raw_sideSuggestion },
   { &decode_VisionCore_Road_LaneOutput_Raw_laneChange },
   { &decode_VisionCore_Road_LaneOutput_Raw_frameDrop },
   { &decode_VisionCore_Road_LaneOutput_Raw_blockageDuration },
   { &decode_VisionCore_Road_LaneOutput_Raw_selfAssessmentFailed },
   { &decode_VisionCore_Road_LaneOutput_Raw_attentionMarkers },
   { &decode_VisionCore_Road_LaneOutput_Raw_operationMode }
};

#define VisionCore_Road_LaneOutput_DECODERS_COUNT 14
const qpb_decoder_entry_t VisionCore_Road_LaneOutput_decoders[VisionCore_Road_LaneOutput_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Road_LaneOutput_egoLane },
   { &decode_VisionCore_Road_LaneOutput_coupledEgoLane },
   { &decode_VisionCore_Road_LaneOutput_neighborLeft },
   { &decode_VisionCore_Road_LaneOutput_neighborRight },
   { &decode_VisionCore_Road_LaneOutput_events },
   { &decode_VisionCore_Road_LaneOutput_temporaryMarkings },
   { &decode_VisionCore_Road_LaneOutput_sideSuggestion },
   { &decode_VisionCore_Road_LaneOutput_laneChange },
   { &decode_VisionCore_Road_LaneOutput_frameDrop },
   { &decode_VisionCore_Road_LaneOutput_blockageDuration },
   { &decode_VisionCore_Road_LaneOutput_selfAssessmentFailed },
   { &decode_VisionCore_Road_LaneOutput_attentionMarkers },
   { &decode_VisionCore_Road_LaneOutput_operationMode }
};

static inline void encode_VisionCore_Road_Clothoid_Raw_lateralDistance(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_Clothoid_Raw_lateralDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_Clothoid_Raw*)data)->lateralDistance, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_Clothoid_Raw_heading(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_Clothoid_Raw_heading(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_Clothoid_Raw*)data)->heading, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_Clothoid_Raw_curvature(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_Clothoid_Raw_curvature(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_Clothoid_Raw*)data)->curvature, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_Clothoid_Raw_curvatureRate(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_Clothoid_Raw_curvatureRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_Clothoid_Raw*)data)->curvatureRate, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_Clothoid_Raw_transitionDistance(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_Clothoid_Raw_transitionDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_Clothoid_Raw*)data)->transitionDistance, sizeof(uint16_t));
}

static inline void encode_VisionCore_Road_Clothoid_Raw_curvatureRateSecondClothoid(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_Clothoid_Raw_curvatureRateSecondClothoid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_Clothoid_Raw*)data)->curvatureRateSecondClothoid, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_Clothoid_Raw_secondClothoidActive(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_Clothoid_Raw_secondClothoidActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_Clothoid_Raw*)data)->secondClothoidActive, sizeof(bool));
}

static inline void encode_VisionCore_Road_Clothoid_lateralDistance(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_Clothoid_Raw_lateralDistance(stream, &value);
}

static bool decode_VisionCore_Road_Clothoid_lateralDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_Clothoid*)data)->lateralDistance = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_Road_Clothoid_heading(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_000025, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_Clothoid_Raw_heading(stream, &value);
}

static bool decode_VisionCore_Road_Clothoid_heading(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_Clothoid*)data)->heading = value * F_0_000025;
   return result;
}

static inline void encode_VisionCore_Road_Clothoid_curvature(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_0000025, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_Clothoid_Raw_curvature(stream, &value);
}

static bool decode_VisionCore_Road_Clothoid_curvature(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_Clothoid*)data)->curvature = value * F_0_0000025;
   return result;
}

static inline void encode_VisionCore_Road_Clothoid_curvatureRate(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_000001, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_Clothoid_Raw_curvatureRate(stream, &value);
}

static bool decode_VisionCore_Road_Clothoid_curvatureRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_Clothoid*)data)->curvatureRate = value * F_0_000001;
   return result;
}

static inline void encode_VisionCore_Road_Clothoid_transitionDistance(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_VisionCore_Road_Clothoid_Raw_transitionDistance(stream, &value);
}

static bool decode_VisionCore_Road_Clothoid_transitionDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((VisionCore_Road_Clothoid*)data)->transitionDistance = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_Road_Clothoid_curvatureRateSecondClothoid(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_000001, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_Clothoid_Raw_curvatureRateSecondClothoid(stream, &value);
}

static bool decode_VisionCore_Road_Clothoid_curvatureRateSecondClothoid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_Clothoid*)data)->curvatureRateSecondClothoid = value * F_0_000001;
   return result;
}

static inline void encode_VisionCore_Road_Clothoid_secondClothoidActive(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_Clothoid_secondClothoidActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_Clothoid*)data)->secondClothoidActive, sizeof(bool));
}

static inline void encode_VisionCore_Road_ClothoidVariance_Raw_lateralDistanceVariance(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_ClothoidVariance_Raw_lateralDistanceVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_ClothoidVariance_Raw*)data)->lateralDistanceVariance, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_ClothoidVariance_Raw_headingVariance(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_ClothoidVariance_Raw_headingVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_ClothoidVariance_Raw*)data)->headingVariance, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_ClothoidVariance_Raw_curvatureVariance(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_ClothoidVariance_Raw_curvatureVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_ClothoidVariance_Raw*)data)->curvatureVariance, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_ClothoidVariance_Raw_curvatureRateVariance(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_ClothoidVariance_Raw_curvatureRateVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_ClothoidVariance_Raw*)data)->curvatureRateVariance, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_ClothoidVariance_Raw_curvatureRateSecondClothoidVariance(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_ClothoidVariance_Raw_curvatureRateSecondClothoidVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Road_ClothoidVariance_Raw*)data)->curvatureRateSecondClothoidVariance, sizeof(int16_t));
}

static inline void encode_VisionCore_Road_ClothoidVariance_lateralDistanceVariance(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_ClothoidVariance_Raw_lateralDistanceVariance(stream, &value);
}

static bool decode_VisionCore_Road_ClothoidVariance_lateralDistanceVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_ClothoidVariance*)data)->lateralDistanceVariance = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_Road_ClothoidVariance_headingVariance(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_000025, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_ClothoidVariance_Raw_headingVariance(stream, &value);
}

static bool decode_VisionCore_Road_ClothoidVariance_headingVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_ClothoidVariance*)data)->headingVariance = value * F_0_000025;
   return result;
}

static inline void encode_VisionCore_Road_ClothoidVariance_curvatureVariance(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_0000025, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_ClothoidVariance_Raw_curvatureVariance(stream, &value);
}

static bool decode_VisionCore_Road_ClothoidVariance_curvatureVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_ClothoidVariance*)data)->curvatureVariance = value * F_0_0000025;
   return result;
}

static inline void encode_VisionCore_Road_ClothoidVariance_curvatureRateVariance(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_000001, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_ClothoidVariance_Raw_curvatureRateVariance(stream, &value);
}

static bool decode_VisionCore_Road_ClothoidVariance_curvatureRateVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_ClothoidVariance*)data)->curvatureRateVariance = value * F_0_000001;
   return result;
}

static inline void encode_VisionCore_Road_ClothoidVariance_curvatureRateSecondClothoidVariance(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_000001, INT16_MIN, INT16_MAX);
   encode_VisionCore_Road_ClothoidVariance_Raw_curvatureRateSecondClothoidVariance(stream, &value);
}

static bool decode_VisionCore_Road_ClothoidVariance_curvatureRateSecondClothoidVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Road_ClothoidVariance*)data)->curvatureRateSecondClothoidVariance = value * F_0_000001;
   return result;
}

static inline void encode_VisionCore_Road_LaneEvent_Raw_id(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneEvent_Raw_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneEvent_Raw*)data)->id, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneEvent_Raw_laneTrackId(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneEvent_Raw_laneTrackId(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneEvent_Raw*)data)->laneTrackId, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneEvent_Raw_distance(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneEvent_Raw_distance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneEvent_Raw*)data)->distance, sizeof(uint16_t));
}

static inline void encode_VisionCore_Road_LaneEvent_Raw_eventType(qpb_ostream_t *const stream, const VisionCore_Road_LaneEventType *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneEvent_Raw_eventType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneEvent_Raw*)data)->eventType, qpb_membersize(VisionCore_Road_LaneEvent_Raw, eventType));
}

static inline void encode_VisionCore_Road_LaneEvent_Raw_side(qpb_ostream_t *const stream, const VisionCore_Road_LaneEventSide *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneEvent_Raw_side(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneEvent_Raw*)data)->side, qpb_membersize(VisionCore_Road_LaneEvent_Raw, side));
}

static inline void encode_VisionCore_Road_LaneEvent_id(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneEvent_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneEvent*)data)->id, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneEvent_laneTrackId(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneEvent_laneTrackId(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneEvent*)data)->laneTrackId, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneEvent_distance(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_1, 0, UINT16_MAX);
   encode_VisionCore_Road_LaneEvent_Raw_distance(stream, &value);
}

static bool decode_VisionCore_Road_LaneEvent_distance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((VisionCore_Road_LaneEvent*)data)->distance = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_Road_LaneEvent_eventType(qpb_ostream_t *const stream, const VisionCore_Road_LaneEventType *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneEvent_eventType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneEvent*)data)->eventType, qpb_membersize(VisionCore_Road_LaneEvent, eventType));
}

static inline void encode_VisionCore_Road_LaneEvent_side(qpb_ostream_t *const stream, const VisionCore_Road_LaneEventSide *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneEvent_side(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneEvent*)data)->side, qpb_membersize(VisionCore_Road_LaneEvent, side));
}

static inline void encode_VisionCore_Road_TemporaryMarkings_Raw_type(qpb_ostream_t *const stream, const VisionCore_Road_TemporaryMarkingType *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_TemporaryMarkings_Raw_type(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_TemporaryMarkings_Raw*)data)->type, qpb_membersize(VisionCore_Road_TemporaryMarkings_Raw, type));
}

static inline void encode_VisionCore_Road_TemporaryMarkings_Raw_longitudinalDistance(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_TemporaryMarkings_Raw_longitudinalDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_TemporaryMarkings_Raw*)data)->longitudinalDistance, sizeof(uint16_t));
}

static inline void encode_VisionCore_Road_TemporaryMarkings_type(qpb_ostream_t *const stream, const VisionCore_Road_TemporaryMarkingType *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_TemporaryMarkings_type(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_TemporaryMarkings*)data)->type, qpb_membersize(VisionCore_Road_TemporaryMarkings, type));
}

static inline void encode_VisionCore_Road_TemporaryMarkings_longitudinalDistance(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_1, 0, UINT16_MAX);
   encode_VisionCore_Road_TemporaryMarkings_Raw_longitudinalDistance(stream, &value);
}

static bool decode_VisionCore_Road_TemporaryMarkings_longitudinalDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((VisionCore_Road_TemporaryMarkings*)data)->longitudinalDistance = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_valid(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->valid, sizeof(bool));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_id(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->id, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_detectionDistance(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_detectionDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->detectionDistance, sizeof(uint16_t));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_markingType(qpb_ostream_t *const stream, const VisionCore_Road_MarkingType *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_markingType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->markingType, qpb_membersize(VisionCore_Road_LaneTrack_Raw, markingType));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_markingLength(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_markingLength(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->markingLength, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_gapLength(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_gapLength(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->gapLength, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_secondMarkingType(qpb_ostream_t *const stream, const VisionCore_Road_SecondMarkingType *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_secondMarkingType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->secondMarkingType, qpb_membersize(VisionCore_Road_LaneTrack_Raw, secondMarkingType));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_markingStructure(qpb_ostream_t *const stream, const VisionCore_Road_MarkingStructure *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_markingStructure(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->markingStructure, qpb_membersize(VisionCore_Road_LaneTrack_Raw, markingStructure));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_trackingStatus(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrackingStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 72;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_trackingStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->trackingStatus, qpb_membersize(VisionCore_Road_LaneTrack_Raw, trackingStatus));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_markingWidth(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 80;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_markingWidth(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->markingWidth, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_totalMarkingWidth(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 88;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_totalMarkingWidth(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->totalMarkingWidth, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_color(qpb_ostream_t *const stream, const VisionCore_Road_LaneMarkingColor *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 96;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_color(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->color, qpb_membersize(VisionCore_Road_LaneTrack_Raw, color));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_modelError(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 104;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_modelError(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->modelError, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_measurementQuality(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 112;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_measurementQuality(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->measurementQuality, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_selectionConfidence(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 120;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_selectionConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->selectionConfidence, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_distanceFirstToSecondMarking(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 128);
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_distanceFirstToSecondMarking(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->distanceFirstToSecondMarking, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_clothoid(qpb_ostream_t *const stream, const VisionCore_Road_Clothoid_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   qpb_encode_varint(stream, 138);
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_Clothoid_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 2;
      memset(stream->buffer, 0, 2);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_clothoid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_Clothoid_Raw(&substream, &((VisionCore_Road_LaneTrack_Raw*)data)->clothoid);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_isSafe(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 144);
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_isSafe(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->isSafe, sizeof(bool));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_unsafeReason(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 152);
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_unsafeReason(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneTrack_Raw*)data)->unsafeReason, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneTrack_Raw_clothoidVariance(qpb_ostream_t *const stream, const VisionCore_Road_ClothoidVariance_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   qpb_encode_varint(stream, 162);
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_ClothoidVariance_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 2;
      memset(stream->buffer, 0, 2);
   }
}

static bool decode_VisionCore_Road_LaneTrack_Raw_clothoidVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_ClothoidVariance_Raw(&substream, &((VisionCore_Road_LaneTrack_Raw*)data)->clothoidVariance);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_LaneTrack_valid(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_valid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneTrack*)data)->valid, sizeof(bool));
}

static inline void encode_VisionCore_Road_LaneTrack_id(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneTrack*)data)->id, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneTrack_detectionDistance(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_1, 0, UINT16_MAX);
   encode_VisionCore_Road_LaneTrack_Raw_detectionDistance(stream, &value);
}

static bool decode_VisionCore_Road_LaneTrack_detectionDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((VisionCore_Road_LaneTrack*)data)->detectionDistance = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_Road_LaneTrack_markingType(qpb_ostream_t *const stream, const VisionCore_Road_MarkingType *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_markingType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneTrack*)data)->markingType, qpb_membersize(VisionCore_Road_LaneTrack, markingType));
}

static inline void encode_VisionCore_Road_LaneTrack_markingLength(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_05, 0, UINT8_MAX);
   encode_VisionCore_Road_LaneTrack_Raw_markingLength(stream, &value);
}

static bool decode_VisionCore_Road_LaneTrack_markingLength(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_Road_LaneTrack*)data)->markingLength = value * F_0_05;
   return result;
}

static inline void encode_VisionCore_Road_LaneTrack_gapLength(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_1, 0, UINT8_MAX);
   encode_VisionCore_Road_LaneTrack_Raw_gapLength(stream, &value);
}

static bool decode_VisionCore_Road_LaneTrack_gapLength(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_Road_LaneTrack*)data)->gapLength = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_Road_LaneTrack_secondMarkingType(qpb_ostream_t *const stream, const VisionCore_Road_SecondMarkingType *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_secondMarkingType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneTrack*)data)->secondMarkingType, qpb_membersize(VisionCore_Road_LaneTrack, secondMarkingType));
}

static inline void encode_VisionCore_Road_LaneTrack_markingStructure(qpb_ostream_t *const stream, const VisionCore_Road_MarkingStructure *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_markingStructure(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneTrack*)data)->markingStructure, qpb_membersize(VisionCore_Road_LaneTrack, markingStructure));
}

static inline void encode_VisionCore_Road_LaneTrack_trackingStatus(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrackingStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 72;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_trackingStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneTrack*)data)->trackingStatus, qpb_membersize(VisionCore_Road_LaneTrack, trackingStatus));
}

static inline void encode_VisionCore_Road_LaneTrack_markingWidth(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_01, 0, UINT8_MAX);
   encode_VisionCore_Road_LaneTrack_Raw_markingWidth(stream, &value);
}

static bool decode_VisionCore_Road_LaneTrack_markingWidth(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_Road_LaneTrack*)data)->markingWidth = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_Road_LaneTrack_totalMarkingWidth(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_01, 0, UINT8_MAX);
   encode_VisionCore_Road_LaneTrack_Raw_totalMarkingWidth(stream, &value);
}

static bool decode_VisionCore_Road_LaneTrack_totalMarkingWidth(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_Road_LaneTrack*)data)->totalMarkingWidth = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_Road_LaneTrack_color(qpb_ostream_t *const stream, const VisionCore_Road_LaneMarkingColor *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 96;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_color(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneTrack*)data)->color, qpb_membersize(VisionCore_Road_LaneTrack, color));
}

static inline void encode_VisionCore_Road_LaneTrack_modelError(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_01, 0, UINT8_MAX);
   encode_VisionCore_Road_LaneTrack_Raw_modelError(stream, &value);
}

static bool decode_VisionCore_Road_LaneTrack_modelError(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_Road_LaneTrack*)data)->modelError = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_Road_LaneTrack_measurementQuality(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 112;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_measurementQuality(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneTrack*)data)->measurementQuality, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneTrack_selectionConfidence(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 120;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_selectionConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneTrack*)data)->selectionConfidence, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneTrack_distanceFirstToSecondMarking(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_0_01, 0, UINT8_MAX);
   encode_VisionCore_Road_LaneTrack_Raw_distanceFirstToSecondMarking(stream, &value);
}

static bool decode_VisionCore_Road_LaneTrack_distanceFirstToSecondMarking(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((VisionCore_Road_LaneTrack*)data)->distanceFirstToSecondMarking = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_Road_LaneTrack_clothoid(qpb_ostream_t *const stream, const VisionCore_Road_Clothoid *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   qpb_encode_varint(stream, 138);
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_Clothoid(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 2;
      memset(stream->buffer, 0, 2);
   }
}

static bool decode_VisionCore_Road_LaneTrack_clothoid(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_Clothoid(&substream, &((VisionCore_Road_LaneTrack*)data)->clothoid);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_LaneTrack_isSafe(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 144);
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_isSafe(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneTrack*)data)->isSafe, sizeof(bool));
}

static inline void encode_VisionCore_Road_LaneTrack_unsafeReason(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 152);
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneTrack_unsafeReason(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneTrack*)data)->unsafeReason, sizeof(uint8_t));
}

static inline void encode_VisionCore_Road_LaneTrack_clothoidVariance(qpb_ostream_t *const stream, const VisionCore_Road_ClothoidVariance *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   qpb_encode_varint(stream, 162);
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_ClothoidVariance(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 2;
      memset(stream->buffer, 0, 2);
   }
}

static bool decode_VisionCore_Road_LaneTrack_clothoidVariance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_ClothoidVariance(&substream, &((VisionCore_Road_LaneTrack*)data)->clothoidVariance);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_EgoLane_Raw_left(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_LaneTrack_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_EgoLane_Raw_left(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_LaneTrack_Raw(&substream, &((VisionCore_Road_EgoLane_Raw*)data)->left);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_EgoLane_Raw_right(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_LaneTrack_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_EgoLane_Raw_right(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_LaneTrack_Raw(&substream, &((VisionCore_Road_EgoLane_Raw*)data)->right);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_EgoLane_Raw_parallelDistance(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_EgoLane_Raw_parallelDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_EgoLane_Raw*)data)->parallelDistance, sizeof(uint16_t));
}

static inline void encode_VisionCore_Road_EgoLane_left(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_LaneTrack(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_EgoLane_left(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_LaneTrack(&substream, &((VisionCore_Road_EgoLane*)data)->left);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_EgoLane_right(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_LaneTrack(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_EgoLane_right(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_LaneTrack(&substream, &((VisionCore_Road_EgoLane*)data)->right);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_EgoLane_parallelDistance(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_1, 0, UINT16_MAX);
   encode_VisionCore_Road_EgoLane_Raw_parallelDistance(stream, &value);
}

static bool decode_VisionCore_Road_EgoLane_parallelDistance(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((VisionCore_Road_EgoLane*)data)->parallelDistance = value * F_0_1;
   return result;
}

static inline void encode_VisionCore_Road_LaneOutput_Raw_egoLane(qpb_ostream_t *const stream, const VisionCore_Road_EgoLane_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_EgoLane_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_LaneOutput_Raw_egoLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_EgoLane_Raw(&substream, &((VisionCore_Road_LaneOutput_Raw*)data)->egoLane);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_LaneOutput_Raw_coupledEgoLane(qpb_ostream_t *const stream, const VisionCore_Road_EgoLane_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_EgoLane_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_LaneOutput_Raw_coupledEgoLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_EgoLane_Raw(&substream, &((VisionCore_Road_LaneOutput_Raw*)data)->coupledEgoLane);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_LaneOutput_Raw_neighborLeft(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_LaneTrack_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_LaneOutput_Raw_neighborLeft(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_LaneTrack_Raw(&substream, &((VisionCore_Road_LaneOutput_Raw*)data)->neighborLeft);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_LaneOutput_Raw_neighborRight(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_LaneTrack_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_LaneOutput_Raw_neighborRight(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_LaneTrack_Raw(&substream, &((VisionCore_Road_LaneOutput_Raw*)data)->neighborRight);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_LaneOutput_Raw_events(qpb_ostream_t *const stream, const VisionCore_Road_LaneEvent_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 42;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_VisionCore_Road_LaneEvent_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_VisionCore_Road_LaneOutput_Raw_events(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((VisionCore_Road_LaneOutput_Raw*)data)->events_count + 1) > 4)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_VisionCore_Road_LaneEvent_Raw(&substream, &((VisionCore_Road_LaneOutput_Raw*)data)->events[((VisionCore_Road_LaneOutput_Raw*)data)->events_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_VisionCore_Road_LaneOutput_Raw_temporaryMarkings(qpb_ostream_t *const stream, const VisionCore_Road_TemporaryMarkings_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 50;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_TemporaryMarkings_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_LaneOutput_Raw_temporaryMarkings(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_TemporaryMarkings_Raw(&substream, &((VisionCore_Road_LaneOutput_Raw*)data)->temporaryMarkings);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_LaneOutput_Raw_sideSuggestion(qpb_ostream_t *const stream, const VisionCore_Road_SideSuggestion *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneOutput_Raw_sideSuggestion(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneOutput_Raw*)data)->sideSuggestion, qpb_membersize(VisionCore_Road_LaneOutput_Raw, sideSuggestion));
}

static inline void encode_VisionCore_Road_LaneOutput_Raw_laneChange(qpb_ostream_t *const stream, const VisionCore_Road_LaneChange *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneOutput_Raw_laneChange(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneOutput_Raw*)data)->laneChange, qpb_membersize(VisionCore_Road_LaneOutput_Raw, laneChange));
}

static inline void encode_VisionCore_Road_LaneOutput_Raw_frameDrop(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 72;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneOutput_Raw_frameDrop(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneOutput_Raw*)data)->frameDrop, sizeof(bool));
}

static inline void encode_VisionCore_Road_LaneOutput_Raw_blockageDuration(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 80;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneOutput_Raw_blockageDuration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneOutput_Raw*)data)->blockageDuration, sizeof(uint16_t));
}

static inline void encode_VisionCore_Road_LaneOutput_Raw_selfAssessmentFailed(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 88;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneOutput_Raw_selfAssessmentFailed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneOutput_Raw*)data)->selfAssessmentFailed, sizeof(bool));
}

static inline void encode_VisionCore_Road_LaneOutput_Raw_attentionMarkers(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 96;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneOutput_Raw_attentionMarkers(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneOutput_Raw*)data)->attentionMarkers, sizeof(bool));
}

static inline void encode_VisionCore_Road_LaneOutput_Raw_operationMode(qpb_ostream_t *const stream, const VisionCore_Road_LaneOperationMode *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 104;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneOutput_Raw_operationMode(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneOutput_Raw*)data)->operationMode, qpb_membersize(VisionCore_Road_LaneOutput_Raw, operationMode));
}

static inline void encode_VisionCore_Road_LaneOutput_egoLane(qpb_ostream_t *const stream, const VisionCore_Road_EgoLane *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_EgoLane(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_LaneOutput_egoLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_EgoLane(&substream, &((VisionCore_Road_LaneOutput*)data)->egoLane);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_LaneOutput_coupledEgoLane(qpb_ostream_t *const stream, const VisionCore_Road_EgoLane *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_EgoLane(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_LaneOutput_coupledEgoLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_EgoLane(&substream, &((VisionCore_Road_LaneOutput*)data)->coupledEgoLane);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_LaneOutput_neighborLeft(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_LaneTrack(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_LaneOutput_neighborLeft(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_LaneTrack(&substream, &((VisionCore_Road_LaneOutput*)data)->neighborLeft);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_LaneOutput_neighborRight(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_LaneTrack(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_LaneOutput_neighborRight(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_LaneTrack(&substream, &((VisionCore_Road_LaneOutput*)data)->neighborRight);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_LaneOutput_events(qpb_ostream_t *const stream, const VisionCore_Road_LaneEvent arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 42;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_VisionCore_Road_LaneEvent(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_VisionCore_Road_LaneOutput_events(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((VisionCore_Road_LaneOutput*)data)->events_count + 1) > 4)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_VisionCore_Road_LaneEvent(&substream, &((VisionCore_Road_LaneOutput*)data)->events[((VisionCore_Road_LaneOutput*)data)->events_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_VisionCore_Road_LaneOutput_temporaryMarkings(qpb_ostream_t *const stream, const VisionCore_Road_TemporaryMarkings *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 50;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_VisionCore_Road_TemporaryMarkings(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_VisionCore_Road_LaneOutput_temporaryMarkings(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_VisionCore_Road_TemporaryMarkings(&substream, &((VisionCore_Road_LaneOutput*)data)->temporaryMarkings);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_VisionCore_Road_LaneOutput_sideSuggestion(qpb_ostream_t *const stream, const VisionCore_Road_SideSuggestion *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneOutput_sideSuggestion(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneOutput*)data)->sideSuggestion, qpb_membersize(VisionCore_Road_LaneOutput, sideSuggestion));
}

static inline void encode_VisionCore_Road_LaneOutput_laneChange(qpb_ostream_t *const stream, const VisionCore_Road_LaneChange *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneOutput_laneChange(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneOutput*)data)->laneChange, qpb_membersize(VisionCore_Road_LaneOutput, laneChange));
}

static inline void encode_VisionCore_Road_LaneOutput_frameDrop(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 72;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneOutput_frameDrop(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneOutput*)data)->frameDrop, sizeof(bool));
}

static inline void encode_VisionCore_Road_LaneOutput_blockageDuration(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 80;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneOutput_blockageDuration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Road_LaneOutput*)data)->blockageDuration, sizeof(uint16_t));
}

static inline void encode_VisionCore_Road_LaneOutput_selfAssessmentFailed(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 88;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneOutput_selfAssessmentFailed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneOutput*)data)->selfAssessmentFailed, sizeof(bool));
}

static inline void encode_VisionCore_Road_LaneOutput_attentionMarkers(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 96;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneOutput_attentionMarkers(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneOutput*)data)->attentionMarkers, sizeof(bool));
}

static inline void encode_VisionCore_Road_LaneOutput_operationMode(qpb_ostream_t *const stream, const VisionCore_Road_LaneOperationMode *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 104;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Road_LaneOutput_operationMode(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Road_LaneOutput*)data)->operationMode, qpb_membersize(VisionCore_Road_LaneOutput, operationMode));
}

/* Encoding / decoding functions */
bool encode_VisionCore_Road_Clothoid_Raw(qpb_ostream_t *const stream, const VisionCore_Road_Clothoid_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_Clothoid_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_Clothoid_Raw_lateralDistance(stream, &data->lateralDistance);
   encode_VisionCore_Road_Clothoid_Raw_heading(stream, &data->heading);
   encode_VisionCore_Road_Clothoid_Raw_curvature(stream, &data->curvature);
   encode_VisionCore_Road_Clothoid_Raw_curvatureRate(stream, &data->curvatureRate);
   encode_VisionCore_Road_Clothoid_Raw_transitionDistance(stream, &data->transitionDistance);
   encode_VisionCore_Road_Clothoid_Raw_curvatureRateSecondClothoid(stream, &data->curvatureRateSecondClothoid);
   encode_VisionCore_Road_Clothoid_Raw_secondClothoidActive(stream, &data->secondClothoidActive);
   return true;
}

bool decode_VisionCore_Road_Clothoid_Raw(qpb_istream_t *const stream, VisionCore_Road_Clothoid_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_Clothoid_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_Clothoid_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_Clothoid(qpb_ostream_t *const stream, const VisionCore_Road_Clothoid *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_Clothoid_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_Clothoid_lateralDistance(stream, &data->lateralDistance);
   encode_VisionCore_Road_Clothoid_heading(stream, &data->heading);
   encode_VisionCore_Road_Clothoid_curvature(stream, &data->curvature);
   encode_VisionCore_Road_Clothoid_curvatureRate(stream, &data->curvatureRate);
   encode_VisionCore_Road_Clothoid_transitionDistance(stream, &data->transitionDistance);
   encode_VisionCore_Road_Clothoid_curvatureRateSecondClothoid(stream, &data->curvatureRateSecondClothoid);
   encode_VisionCore_Road_Clothoid_Raw_secondClothoidActive(stream, &data->secondClothoidActive);
   return true;
}

bool decode_VisionCore_Road_Clothoid(qpb_istream_t *const stream, VisionCore_Road_Clothoid *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_Clothoid_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_Clothoid_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_ClothoidVariance_Raw(qpb_ostream_t *const stream, const VisionCore_Road_ClothoidVariance_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_ClothoidVariance_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_ClothoidVariance_Raw_lateralDistanceVariance(stream, &data->lateralDistanceVariance);
   encode_VisionCore_Road_ClothoidVariance_Raw_headingVariance(stream, &data->headingVariance);
   encode_VisionCore_Road_ClothoidVariance_Raw_curvatureVariance(stream, &data->curvatureVariance);
   encode_VisionCore_Road_ClothoidVariance_Raw_curvatureRateVariance(stream, &data->curvatureRateVariance);
   encode_VisionCore_Road_ClothoidVariance_Raw_curvatureRateSecondClothoidVariance(stream, &data->curvatureRateSecondClothoidVariance);
   return true;
}

bool decode_VisionCore_Road_ClothoidVariance_Raw(qpb_istream_t *const stream, VisionCore_Road_ClothoidVariance_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_ClothoidVariance_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_ClothoidVariance_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_ClothoidVariance(qpb_ostream_t *const stream, const VisionCore_Road_ClothoidVariance *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_ClothoidVariance_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_ClothoidVariance_lateralDistanceVariance(stream, &data->lateralDistanceVariance);
   encode_VisionCore_Road_ClothoidVariance_headingVariance(stream, &data->headingVariance);
   encode_VisionCore_Road_ClothoidVariance_curvatureVariance(stream, &data->curvatureVariance);
   encode_VisionCore_Road_ClothoidVariance_curvatureRateVariance(stream, &data->curvatureRateVariance);
   encode_VisionCore_Road_ClothoidVariance_curvatureRateSecondClothoidVariance(stream, &data->curvatureRateSecondClothoidVariance);
   return true;
}

bool decode_VisionCore_Road_ClothoidVariance(qpb_istream_t *const stream, VisionCore_Road_ClothoidVariance *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_ClothoidVariance_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_ClothoidVariance_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_LaneEvent_Raw(qpb_ostream_t *const stream, const VisionCore_Road_LaneEvent_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_LaneEvent_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_LaneEvent_Raw_id(stream, &data->id);
   encode_VisionCore_Road_LaneEvent_Raw_laneTrackId(stream, &data->laneTrackId);
   encode_VisionCore_Road_LaneEvent_Raw_distance(stream, &data->distance);
   encode_VisionCore_Road_LaneEvent_Raw_eventType(stream, &data->eventType);
   encode_VisionCore_Road_LaneEvent_Raw_side(stream, &data->side);
   return true;
}

bool decode_VisionCore_Road_LaneEvent_Raw(qpb_istream_t *const stream, VisionCore_Road_LaneEvent_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_LaneEvent_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_LaneEvent_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_LaneEvent(qpb_ostream_t *const stream, const VisionCore_Road_LaneEvent *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_LaneEvent_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_LaneEvent_Raw_id(stream, &data->id);
   encode_VisionCore_Road_LaneEvent_Raw_laneTrackId(stream, &data->laneTrackId);
   encode_VisionCore_Road_LaneEvent_distance(stream, &data->distance);
   encode_VisionCore_Road_LaneEvent_Raw_eventType(stream, &data->eventType);
   encode_VisionCore_Road_LaneEvent_Raw_side(stream, &data->side);
   return true;
}

bool decode_VisionCore_Road_LaneEvent(qpb_istream_t *const stream, VisionCore_Road_LaneEvent *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_LaneEvent_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_LaneEvent_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_TemporaryMarkings_Raw(qpb_ostream_t *const stream, const VisionCore_Road_TemporaryMarkings_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_TemporaryMarkings_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_TemporaryMarkings_Raw_type(stream, &data->type);
   encode_VisionCore_Road_TemporaryMarkings_Raw_longitudinalDistance(stream, &data->longitudinalDistance);
   return true;
}

bool decode_VisionCore_Road_TemporaryMarkings_Raw(qpb_istream_t *const stream, VisionCore_Road_TemporaryMarkings_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_TemporaryMarkings_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_TemporaryMarkings_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_TemporaryMarkings(qpb_ostream_t *const stream, const VisionCore_Road_TemporaryMarkings *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_TemporaryMarkings_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_TemporaryMarkings_Raw_type(stream, &data->type);
   encode_VisionCore_Road_TemporaryMarkings_longitudinalDistance(stream, &data->longitudinalDistance);
   return true;
}

bool decode_VisionCore_Road_TemporaryMarkings(qpb_istream_t *const stream, VisionCore_Road_TemporaryMarkings *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_TemporaryMarkings_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_TemporaryMarkings_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_LaneTrack_Raw(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_LaneTrack_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_LaneTrack_Raw_valid(stream, &data->valid);
   encode_VisionCore_Road_LaneTrack_Raw_id(stream, &data->id);
   encode_VisionCore_Road_LaneTrack_Raw_detectionDistance(stream, &data->detectionDistance);
   encode_VisionCore_Road_LaneTrack_Raw_markingType(stream, &data->markingType);
   encode_VisionCore_Road_LaneTrack_Raw_markingLength(stream, &data->markingLength);
   encode_VisionCore_Road_LaneTrack_Raw_gapLength(stream, &data->gapLength);
   encode_VisionCore_Road_LaneTrack_Raw_secondMarkingType(stream, &data->secondMarkingType);
   encode_VisionCore_Road_LaneTrack_Raw_markingStructure(stream, &data->markingStructure);
   encode_VisionCore_Road_LaneTrack_Raw_trackingStatus(stream, &data->trackingStatus);
   encode_VisionCore_Road_LaneTrack_Raw_markingWidth(stream, &data->markingWidth);
   encode_VisionCore_Road_LaneTrack_Raw_totalMarkingWidth(stream, &data->totalMarkingWidth);
   encode_VisionCore_Road_LaneTrack_Raw_color(stream, &data->color);
   encode_VisionCore_Road_LaneTrack_Raw_modelError(stream, &data->modelError);
   encode_VisionCore_Road_LaneTrack_Raw_measurementQuality(stream, &data->measurementQuality);
   encode_VisionCore_Road_LaneTrack_Raw_selectionConfidence(stream, &data->selectionConfidence);
   encode_VisionCore_Road_LaneTrack_Raw_distanceFirstToSecondMarking(stream, &data->distanceFirstToSecondMarking);
   encode_VisionCore_Road_LaneTrack_Raw_clothoid(stream, &data->clothoid);
   encode_VisionCore_Road_LaneTrack_Raw_isSafe(stream, &data->isSafe);
   encode_VisionCore_Road_LaneTrack_Raw_unsafeReason(stream, &data->unsafeReason);
   encode_VisionCore_Road_LaneTrack_Raw_clothoidVariance(stream, &data->clothoidVariance);
   return true;
}

bool decode_VisionCore_Road_LaneTrack_Raw(qpb_istream_t *const stream, VisionCore_Road_LaneTrack_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_LaneTrack_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_LaneTrack_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_LaneTrack(qpb_ostream_t *const stream, const VisionCore_Road_LaneTrack *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_LaneTrack_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_LaneTrack_Raw_valid(stream, &data->valid);
   encode_VisionCore_Road_LaneTrack_Raw_id(stream, &data->id);
   encode_VisionCore_Road_LaneTrack_detectionDistance(stream, &data->detectionDistance);
   encode_VisionCore_Road_LaneTrack_Raw_markingType(stream, &data->markingType);
   encode_VisionCore_Road_LaneTrack_markingLength(stream, &data->markingLength);
   encode_VisionCore_Road_LaneTrack_gapLength(stream, &data->gapLength);
   encode_VisionCore_Road_LaneTrack_Raw_secondMarkingType(stream, &data->secondMarkingType);
   encode_VisionCore_Road_LaneTrack_Raw_markingStructure(stream, &data->markingStructure);
   encode_VisionCore_Road_LaneTrack_Raw_trackingStatus(stream, &data->trackingStatus);
   encode_VisionCore_Road_LaneTrack_markingWidth(stream, &data->markingWidth);
   encode_VisionCore_Road_LaneTrack_totalMarkingWidth(stream, &data->totalMarkingWidth);
   encode_VisionCore_Road_LaneTrack_Raw_color(stream, &data->color);
   encode_VisionCore_Road_LaneTrack_modelError(stream, &data->modelError);
   encode_VisionCore_Road_LaneTrack_Raw_measurementQuality(stream, &data->measurementQuality);
   encode_VisionCore_Road_LaneTrack_Raw_selectionConfidence(stream, &data->selectionConfidence);
   encode_VisionCore_Road_LaneTrack_distanceFirstToSecondMarking(stream, &data->distanceFirstToSecondMarking);
   encode_VisionCore_Road_LaneTrack_clothoid(stream, &data->clothoid);
   encode_VisionCore_Road_LaneTrack_Raw_isSafe(stream, &data->isSafe);
   encode_VisionCore_Road_LaneTrack_Raw_unsafeReason(stream, &data->unsafeReason);
   encode_VisionCore_Road_LaneTrack_clothoidVariance(stream, &data->clothoidVariance);
   return true;
}

bool decode_VisionCore_Road_LaneTrack(qpb_istream_t *const stream, VisionCore_Road_LaneTrack *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_LaneTrack_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_LaneTrack_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_EgoLane_Raw(qpb_ostream_t *const stream, const VisionCore_Road_EgoLane_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_EgoLane_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_EgoLane_Raw_left(stream, &data->left);
   encode_VisionCore_Road_EgoLane_Raw_right(stream, &data->right);
   encode_VisionCore_Road_EgoLane_Raw_parallelDistance(stream, &data->parallelDistance);
   return true;
}

bool decode_VisionCore_Road_EgoLane_Raw(qpb_istream_t *const stream, VisionCore_Road_EgoLane_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_EgoLane_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_EgoLane_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_EgoLane(qpb_ostream_t *const stream, const VisionCore_Road_EgoLane *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_EgoLane_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_EgoLane_left(stream, &data->left);
   encode_VisionCore_Road_EgoLane_right(stream, &data->right);
   encode_VisionCore_Road_EgoLane_parallelDistance(stream, &data->parallelDistance);
   return true;
}

bool decode_VisionCore_Road_EgoLane(qpb_istream_t *const stream, VisionCore_Road_EgoLane *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_EgoLane_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_EgoLane_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_LaneOutput_Raw(qpb_ostream_t *const stream, const VisionCore_Road_LaneOutput_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_LaneOutput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_LaneOutput_Raw_egoLane(stream, &data->egoLane);
   encode_VisionCore_Road_LaneOutput_Raw_coupledEgoLane(stream, &data->coupledEgoLane);
   encode_VisionCore_Road_LaneOutput_Raw_neighborLeft(stream, &data->neighborLeft);
   encode_VisionCore_Road_LaneOutput_Raw_neighborRight(stream, &data->neighborRight);
   encode_VisionCore_Road_LaneOutput_Raw_events(stream, data->events, data->events_count);
   encode_VisionCore_Road_LaneOutput_Raw_temporaryMarkings(stream, &data->temporaryMarkings);
   encode_VisionCore_Road_LaneOutput_Raw_sideSuggestion(stream, &data->sideSuggestion);
   encode_VisionCore_Road_LaneOutput_Raw_laneChange(stream, &data->laneChange);
   encode_VisionCore_Road_LaneOutput_Raw_frameDrop(stream, &data->frameDrop);
   encode_VisionCore_Road_LaneOutput_Raw_blockageDuration(stream, &data->blockageDuration);
   encode_VisionCore_Road_LaneOutput_Raw_selfAssessmentFailed(stream, &data->selfAssessmentFailed);
   encode_VisionCore_Road_LaneOutput_Raw_attentionMarkers(stream, &data->attentionMarkers);
   encode_VisionCore_Road_LaneOutput_Raw_operationMode(stream, &data->operationMode);
   return true;
}

bool decode_VisionCore_Road_LaneOutput_Raw(qpb_istream_t *const stream, VisionCore_Road_LaneOutput_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_LaneOutput_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_LaneOutput_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Road_LaneOutput(qpb_ostream_t *const stream, const VisionCore_Road_LaneOutput *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Road_LaneOutput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Road_LaneOutput_egoLane(stream, &data->egoLane);
   encode_VisionCore_Road_LaneOutput_coupledEgoLane(stream, &data->coupledEgoLane);
   encode_VisionCore_Road_LaneOutput_neighborLeft(stream, &data->neighborLeft);
   encode_VisionCore_Road_LaneOutput_neighborRight(stream, &data->neighborRight);
   encode_VisionCore_Road_LaneOutput_events(stream, data->events, data->events_count);
   encode_VisionCore_Road_LaneOutput_temporaryMarkings(stream, &data->temporaryMarkings);
   encode_VisionCore_Road_LaneOutput_Raw_sideSuggestion(stream, &data->sideSuggestion);
   encode_VisionCore_Road_LaneOutput_Raw_laneChange(stream, &data->laneChange);
   encode_VisionCore_Road_LaneOutput_Raw_frameDrop(stream, &data->frameDrop);
   encode_VisionCore_Road_LaneOutput_Raw_blockageDuration(stream, &data->blockageDuration);
   encode_VisionCore_Road_LaneOutput_Raw_selfAssessmentFailed(stream, &data->selfAssessmentFailed);
   encode_VisionCore_Road_LaneOutput_Raw_attentionMarkers(stream, &data->attentionMarkers);
   encode_VisionCore_Road_LaneOutput_Raw_operationMode(stream, &data->operationMode);
   return true;
}

bool decode_VisionCore_Road_LaneOutput(qpb_istream_t *const stream, VisionCore_Road_LaneOutput *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Road_LaneOutput_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Road_LaneOutput_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

