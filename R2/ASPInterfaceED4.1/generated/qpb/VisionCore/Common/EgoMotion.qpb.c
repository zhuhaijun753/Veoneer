/* Automatically generated qpb constant definitions */
/* Generated by Quick Protocol Buffers - 2 */

#include "VisionCore/Common/EgoMotion.qpb.h"
#include "Tools/QuickProtobuf/qpb_decode.h"
#include "Tools/QuickProtobuf/qpb_encode.h"
#include "Tools/CSupport/ConversionSupport.h"

#if QPB_PROTO_HEADER_VERSION != 2
#error Regenerate this file with the current version of qpb generator.
#endif

#define F_0_0001             0.0001f
#define F_0_01               0.01f

static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalVelocity(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalAcceleration(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_lateralVelocity(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_Raw_lateralVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_lateralAcceleration(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_Raw_lateralAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_yawRate(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_Raw_yawRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_isAvailable(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_Raw_isAvailable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_timestamp(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_Raw_timestamp(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalVelocityStatus(qpb_ostream_t *const stream, const VisionCore_Common_EgoMotionGateKeeperStatus *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalVelocityStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_accelerationStatus(qpb_ostream_t *const stream, const VisionCore_Common_EgoMotionGateKeeperStatus *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_Raw_accelerationStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_yawRateStatus(qpb_ostream_t *const stream, const VisionCore_Common_EgoMotionGateKeeperStatus *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_Raw_yawRateStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_longitudinalVelocity(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_longitudinalVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_longitudinalAcceleration(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_longitudinalAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_lateralVelocity(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_lateralVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_lateralAcceleration(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_lateralAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_yawRate(qpb_ostream_t *const stream, const float *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_yawRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_isAvailable(qpb_ostream_t *const stream, const bool *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_isAvailable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_timestamp(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_timestamp(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_longitudinalVelocityStatus(qpb_ostream_t *const stream, const VisionCore_Common_EgoMotionGateKeeperStatus *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_longitudinalVelocityStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_accelerationStatus(qpb_ostream_t *const stream, const VisionCore_Common_EgoMotionGateKeeperStatus *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_accelerationStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_VisionCore_Common_EgoMotionOutput_yawRateStatus(qpb_ostream_t *const stream, const VisionCore_Common_EgoMotionGateKeeperStatus *const data);
static bool decode_VisionCore_Common_EgoMotionOutput_yawRateStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);

#define VisionCore_Common_EgoMotionOutput_Raw_DECODERS_COUNT 11
const qpb_decoder_entry_t VisionCore_Common_EgoMotionOutput_Raw_decoders[VisionCore_Common_EgoMotionOutput_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalVelocity },
   { &decode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalAcceleration },
   { &decode_VisionCore_Common_EgoMotionOutput_Raw_lateralVelocity },
   { &decode_VisionCore_Common_EgoMotionOutput_Raw_lateralAcceleration },
   { &decode_VisionCore_Common_EgoMotionOutput_Raw_yawRate },
   { &decode_VisionCore_Common_EgoMotionOutput_Raw_isAvailable },
   { &decode_VisionCore_Common_EgoMotionOutput_Raw_timestamp },
   { &decode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalVelocityStatus },
   { &decode_VisionCore_Common_EgoMotionOutput_Raw_accelerationStatus },
   { &decode_VisionCore_Common_EgoMotionOutput_Raw_yawRateStatus }
};

#define VisionCore_Common_EgoMotionOutput_DECODERS_COUNT 11
const qpb_decoder_entry_t VisionCore_Common_EgoMotionOutput_decoders[VisionCore_Common_EgoMotionOutput_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_VisionCore_Common_EgoMotionOutput_longitudinalVelocity },
   { &decode_VisionCore_Common_EgoMotionOutput_longitudinalAcceleration },
   { &decode_VisionCore_Common_EgoMotionOutput_lateralVelocity },
   { &decode_VisionCore_Common_EgoMotionOutput_lateralAcceleration },
   { &decode_VisionCore_Common_EgoMotionOutput_yawRate },
   { &decode_VisionCore_Common_EgoMotionOutput_isAvailable },
   { &decode_VisionCore_Common_EgoMotionOutput_timestamp },
   { &decode_VisionCore_Common_EgoMotionOutput_longitudinalVelocityStatus },
   { &decode_VisionCore_Common_EgoMotionOutput_accelerationStatus },
   { &decode_VisionCore_Common_EgoMotionOutput_yawRateStatus }
};

static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalVelocity(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Common_EgoMotionOutput_Raw*)data)->longitudinalVelocity, sizeof(int16_t));
}

static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalAcceleration(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Common_EgoMotionOutput_Raw*)data)->longitudinalAcceleration, sizeof(int16_t));
}

static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_lateralVelocity(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Common_EgoMotionOutput_Raw_lateralVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Common_EgoMotionOutput_Raw*)data)->lateralVelocity, sizeof(int16_t));
}

static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_lateralAcceleration(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Common_EgoMotionOutput_Raw_lateralAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Common_EgoMotionOutput_Raw*)data)->lateralAcceleration, sizeof(int16_t));
}

static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_yawRate(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_VisionCore_Common_EgoMotionOutput_Raw_yawRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((VisionCore_Common_EgoMotionOutput_Raw*)data)->yawRate, sizeof(int16_t));
}

static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_isAvailable(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Common_EgoMotionOutput_Raw_isAvailable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Common_EgoMotionOutput_Raw*)data)->isAvailable, sizeof(bool));
}

static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_timestamp(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Common_EgoMotionOutput_Raw_timestamp(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Common_EgoMotionOutput_Raw*)data)->timestamp, sizeof(uint32_t));
}

static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalVelocityStatus(qpb_ostream_t *const stream, const VisionCore_Common_EgoMotionGateKeeperStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalVelocityStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Common_EgoMotionOutput_Raw*)data)->longitudinalVelocityStatus, qpb_membersize(VisionCore_Common_EgoMotionOutput_Raw, longitudinalVelocityStatus));
}

static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_accelerationStatus(qpb_ostream_t *const stream, const VisionCore_Common_EgoMotionGateKeeperStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 72;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Common_EgoMotionOutput_Raw_accelerationStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Common_EgoMotionOutput_Raw*)data)->accelerationStatus, qpb_membersize(VisionCore_Common_EgoMotionOutput_Raw, accelerationStatus));
}

static inline void encode_VisionCore_Common_EgoMotionOutput_Raw_yawRateStatus(qpb_ostream_t *const stream, const VisionCore_Common_EgoMotionGateKeeperStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 80;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Common_EgoMotionOutput_Raw_yawRateStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Common_EgoMotionOutput_Raw*)data)->yawRateStatus, qpb_membersize(VisionCore_Common_EgoMotionOutput_Raw, yawRateStatus));
}

static inline void encode_VisionCore_Common_EgoMotionOutput_longitudinalVelocity(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalVelocity(stream, &value);
}

static bool decode_VisionCore_Common_EgoMotionOutput_longitudinalVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Common_EgoMotionOutput*)data)->longitudinalVelocity = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_Common_EgoMotionOutput_longitudinalAcceleration(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalAcceleration(stream, &value);
}

static bool decode_VisionCore_Common_EgoMotionOutput_longitudinalAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Common_EgoMotionOutput*)data)->longitudinalAcceleration = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_Common_EgoMotionOutput_lateralVelocity(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_VisionCore_Common_EgoMotionOutput_Raw_lateralVelocity(stream, &value);
}

static bool decode_VisionCore_Common_EgoMotionOutput_lateralVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Common_EgoMotionOutput*)data)->lateralVelocity = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_Common_EgoMotionOutput_lateralAcceleration(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_VisionCore_Common_EgoMotionOutput_Raw_lateralAcceleration(stream, &value);
}

static bool decode_VisionCore_Common_EgoMotionOutput_lateralAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Common_EgoMotionOutput*)data)->lateralAcceleration = value * F_0_01;
   return result;
}

static inline void encode_VisionCore_Common_EgoMotionOutput_yawRate(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_0001, INT16_MIN, INT16_MAX);
   encode_VisionCore_Common_EgoMotionOutput_Raw_yawRate(stream, &value);
}

static bool decode_VisionCore_Common_EgoMotionOutput_yawRate(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((VisionCore_Common_EgoMotionOutput*)data)->yawRate = value * F_0_0001;
   return result;
}

static inline void encode_VisionCore_Common_EgoMotionOutput_isAvailable(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Common_EgoMotionOutput_isAvailable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Common_EgoMotionOutput*)data)->isAvailable, sizeof(bool));
}

static inline void encode_VisionCore_Common_EgoMotionOutput_timestamp(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_VisionCore_Common_EgoMotionOutput_timestamp(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((VisionCore_Common_EgoMotionOutput*)data)->timestamp, sizeof(uint32_t));
}

static inline void encode_VisionCore_Common_EgoMotionOutput_longitudinalVelocityStatus(qpb_ostream_t *const stream, const VisionCore_Common_EgoMotionGateKeeperStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Common_EgoMotionOutput_longitudinalVelocityStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Common_EgoMotionOutput*)data)->longitudinalVelocityStatus, qpb_membersize(VisionCore_Common_EgoMotionOutput, longitudinalVelocityStatus));
}

static inline void encode_VisionCore_Common_EgoMotionOutput_accelerationStatus(qpb_ostream_t *const stream, const VisionCore_Common_EgoMotionGateKeeperStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 72;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Common_EgoMotionOutput_accelerationStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Common_EgoMotionOutput*)data)->accelerationStatus, qpb_membersize(VisionCore_Common_EgoMotionOutput, accelerationStatus));
}

static inline void encode_VisionCore_Common_EgoMotionOutput_yawRateStatus(qpb_ostream_t *const stream, const VisionCore_Common_EgoMotionGateKeeperStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 80;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_VisionCore_Common_EgoMotionOutput_yawRateStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((VisionCore_Common_EgoMotionOutput*)data)->yawRateStatus, qpb_membersize(VisionCore_Common_EgoMotionOutput, yawRateStatus));
}

/* Encoding / decoding functions */
bool encode_VisionCore_Common_EgoMotionOutput_Raw(qpb_ostream_t *const stream, const VisionCore_Common_EgoMotionOutput_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Common_EgoMotionOutput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalVelocity(stream, &data->longitudinalVelocity);
   encode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalAcceleration(stream, &data->longitudinalAcceleration);
   encode_VisionCore_Common_EgoMotionOutput_Raw_lateralVelocity(stream, &data->lateralVelocity);
   encode_VisionCore_Common_EgoMotionOutput_Raw_lateralAcceleration(stream, &data->lateralAcceleration);
   encode_VisionCore_Common_EgoMotionOutput_Raw_yawRate(stream, &data->yawRate);
   encode_VisionCore_Common_EgoMotionOutput_Raw_isAvailable(stream, &data->isAvailable);
   encode_VisionCore_Common_EgoMotionOutput_Raw_timestamp(stream, &data->timestamp);
   encode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalVelocityStatus(stream, &data->longitudinalVelocityStatus);
   encode_VisionCore_Common_EgoMotionOutput_Raw_accelerationStatus(stream, &data->accelerationStatus);
   encode_VisionCore_Common_EgoMotionOutput_Raw_yawRateStatus(stream, &data->yawRateStatus);
   return true;
}

bool decode_VisionCore_Common_EgoMotionOutput_Raw(qpb_istream_t *const stream, VisionCore_Common_EgoMotionOutput_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Common_EgoMotionOutput_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Common_EgoMotionOutput_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_VisionCore_Common_EgoMotionOutput(qpb_ostream_t *const stream, const VisionCore_Common_EgoMotionOutput *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < VisionCore_Common_EgoMotionOutput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_VisionCore_Common_EgoMotionOutput_longitudinalVelocity(stream, &data->longitudinalVelocity);
   encode_VisionCore_Common_EgoMotionOutput_longitudinalAcceleration(stream, &data->longitudinalAcceleration);
   encode_VisionCore_Common_EgoMotionOutput_lateralVelocity(stream, &data->lateralVelocity);
   encode_VisionCore_Common_EgoMotionOutput_lateralAcceleration(stream, &data->lateralAcceleration);
   encode_VisionCore_Common_EgoMotionOutput_yawRate(stream, &data->yawRate);
   encode_VisionCore_Common_EgoMotionOutput_Raw_isAvailable(stream, &data->isAvailable);
   encode_VisionCore_Common_EgoMotionOutput_Raw_timestamp(stream, &data->timestamp);
   encode_VisionCore_Common_EgoMotionOutput_Raw_longitudinalVelocityStatus(stream, &data->longitudinalVelocityStatus);
   encode_VisionCore_Common_EgoMotionOutput_Raw_accelerationStatus(stream, &data->accelerationStatus);
   encode_VisionCore_Common_EgoMotionOutput_Raw_yawRateStatus(stream, &data->yawRateStatus);
   return true;
}

bool decode_VisionCore_Common_EgoMotionOutput(qpb_istream_t *const stream, VisionCore_Common_EgoMotionOutput *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < VisionCore_Common_EgoMotionOutput_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = VisionCore_Common_EgoMotionOutput_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

