/* Automatically generated qpb constant definitions */
/* Generated by Quick Protocol Buffers - 2 */

#include "Zenuity/Debug/CaLong_Debug.qpb.h"
#include "Tools/QuickProtobuf/qpb_decode.h"
#include "Tools/QuickProtobuf/qpb_encode.h"
#include "Tools/CSupport/ConversionSupport.h"

#if QPB_PROTO_HEADER_VERSION != 2
#error Regenerate this file with the current version of qpb generator.
#endif

#define F_0_01               0.01f
#define F_0_1                0.1f

static inline void encode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_deactivationCause(qpb_ostream_t *const stream, const Zenuity_Debug_AebDeactivationCause *const data);
static bool decode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_deactivationCause(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_postStatus(qpb_ostream_t *const stream, const Zenuity_Debug_PostAebStatus *const data);
static bool decode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_postStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_triggeringCause(qpb_ostream_t *const stream, const Zenuity_Debug_AebTriggeringScenario *const data);
static bool decode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_triggeringCause(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_abortIfNotConfirmed(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_abortIfNotConfirmed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_hostAvoidInhibit(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_hostAvoidInhibit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_inhibitActivation(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_inhibitActivation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_objectDirectionInhibit(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_objectDirectionInhibit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_oncomingInhibit(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_oncomingInhibit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_notOncomingScenarioInScope(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_notOncomingScenarioInScope(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_pointOfImpactInhibit(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_pointOfImpactInhibit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_radarOnlyInhibit(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_radarOnlyInhibit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_speedInhibit(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_speedInhibit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AebPrimaryTarget_Raw_objectIdForBraking(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_Zenuity_Debug_AebPrimaryTarget_Raw_objectIdForBraking(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_BrakingDiagnostic_Raw_accelerationThreat(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_BrakingDiagnostic_Raw_accelerationThreat(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_BrakingDiagnostic_Raw_brakingThreat(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_BrakingDiagnostic_Raw_brakingThreat(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_BrakingDiagnostic_Raw_multiTargetSteeringThreat(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_BrakingDiagnostic_Raw_multiTargetSteeringThreat(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_BrakingDiagnostic_Raw_brakingConfidence(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_BrakingDiagnostic_Raw_brakingConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_BrakingDiagnostic_Raw_singleTargetSteeringThreat(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_BrakingDiagnostic_Raw_singleTargetSteeringThreat(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_BrakingDiagnostic_Raw_steeringThreat(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_BrakingDiagnostic_Raw_steeringThreat(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_brakeGainActive(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_brakeGainActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_brakeThreatNumberAboveLimit(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_brakeThreatNumberAboveLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_driverPressedBrakePedal(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_driverPressedBrakePedal(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_driverDecelerationRequestAboveLimit(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_driverDecelerationRequestAboveLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_cwInhibit(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_cwInhibit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_belowLowSpeedLimit(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_belowLowSpeedLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_aboveHighSpeedLimit(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_aboveHighSpeedLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_disabledByFaultManager(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_disabledByFaultManager(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_startConditionsMet(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_startConditionsMet(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_btnBasedWarningDriver(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_btnBasedWarningDriver(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_btnBaseWarningAcc(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_btnBaseWarningAcc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_comfortDistanceWarning(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_comfortDistanceWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_abnormalAccelerationWarning(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_abnormalAccelerationWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_visionOnlyWarning(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_visionOnlyWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_activatingLateralJerk(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_activatingLateralJerk(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_eventIsJustified(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_eventIsJustified(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_scenario(qpb_ostream_t *const stream, const Zenuity_Debug_MotionPattern *const data);
static bool decode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_scenario(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_state(qpb_ostream_t *const stream, const Zenuity_Debug_EmaState *const data);
static bool decode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_state(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_HighestThreatInfo_Raw_objectId(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_Zenuity_Debug_HighestThreatInfo_Raw_objectId(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_HighestThreatInfo_Raw_timeToCollision(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_Zenuity_Debug_HighestThreatInfo_Raw_timeToCollision(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_HighestThreatInfo_Raw_lateralMargin(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_Zenuity_Debug_HighestThreatInfo_Raw_lateralMargin(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_HighestThreatInfo_objectId(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_Zenuity_Debug_HighestThreatInfo_objectId(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_HighestThreatInfo_timeToCollision(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Debug_HighestThreatInfo_timeToCollision(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_HighestThreatInfo_lateralMargin(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Debug_HighestThreatInfo_lateralMargin(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectLeftHostLeftOverlap(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectLeftHostLeftOverlap(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectLeftHostRightOverlap(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectLeftHostRightOverlap(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectRightHostLeftOverlap(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectRightHostLeftOverlap(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectRightHostRightOverlap(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectRightHostRightOverlap(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_electronicHorizonUsage(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_electronicHorizonUsage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralSafetyOffsetToObject(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralSafetyOffsetToObject(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralInPathOffsetToPredictedObject(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralInPathOffsetToPredictedObject(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralInPathOffsetToObject(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralInPathOffsetToObject(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_longitudinalSafetyOffsetToObject(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_longitudinalSafetyOffsetToObject(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_loopIndexTa(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_loopIndexTa(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectBusSource(qpb_ostream_t *const stream, const Zenuity_Debug_ObjectBusType *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectBusSource(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectCenterTimeVectorIndex(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectCenterTimeVectorIndex(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectCosineHeading(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectCosineHeading(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectDirection(qpb_ostream_t *const stream, const Zenuity_Debug_MotionPattern *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectDirection(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectInPath(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectInPath(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLateralPositionCenter(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLateralPositionCenter(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLength(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLength(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLongitudinalPositionCenter(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLongitudinalPositionCenter(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectSineHeading(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectSineHeading(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectTrajectoryLastInPath(qpb_ostream_t *const stream, const Zenuity_Debug_ObjectTrajectoryInPath *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectTrajectoryLastInPath(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectWidth(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectWidth(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_timeToReachObject(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_timeToReachObject(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_visionId(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_visionId(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_validSensorData(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_validSensorData(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_sufficientSensorData(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_sufficientSensorData(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_threatExists(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_threatExists(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_objectManeuverOverlapsHostManeuver(qpb_ostream_t *const stream, const Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw *const data);
static bool decode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_objectManeuverOverlapsHostManeuver(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AllBrakeDiagnostics_Raw_fullBrake(qpb_ostream_t *const stream, const Zenuity_Debug_BrakingDiagnostic_Raw *const data);
static bool decode_Zenuity_Debug_AllBrakeDiagnostics_Raw_fullBrake(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AllBrakeDiagnostics_Raw_preBrake(qpb_ostream_t *const stream, const Zenuity_Debug_BrakingDiagnostic_Raw *const data);
static bool decode_Zenuity_Debug_AllBrakeDiagnostics_Raw_preBrake(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakeGainInhibitConditionStatus(qpb_ostream_t *const stream, const Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw *const data);
static bool decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakeGainInhibitConditionStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakeGainState(qpb_ostream_t *const stream, const Zenuity_Debug_BrakeGainState *const data);
static bool decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakeGainState(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakePulseState(qpb_ostream_t *const stream, const Zenuity_Debug_BrakePulseState *const data);
static bool decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakePulseState(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_inhibitionConditionStatus(qpb_ostream_t *const stream, const Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw *const data);
static bool decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_inhibitionConditionStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_objectIdForWarning(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_objectIdForWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_startConditionStatus(qpb_ostream_t *const stream, const Zenuity_Debug_CollisionWarningStartConditionStatus_Raw *const data);
static bool decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_startConditionStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_warningState(qpb_ostream_t *const stream, const Zenuity_Debug_AudioVisualWarningState *const data);
static bool decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_warningState(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_warningType(qpb_ostream_t *const stream, const Zenuity_Debug_WarningType *const data);
static bool decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_warningType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnostics_Raw_sortedObjects(qpb_ostream_t *const stream, const Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_Zenuity_Debug_ThreatAssessmentDiagnostics_Raw_sortedObjects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_VruCollisionAvoidanceDiagnostics_Raw_highestThreatInfo(qpb_ostream_t *const stream, const Zenuity_Debug_HighestThreatInfo_Raw *const data);
static bool decode_Zenuity_Debug_VruCollisionAvoidanceDiagnostics_Raw_highestThreatInfo(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_VruCollisionAvoidanceDiagnostics_highestThreatInfo(qpb_ostream_t *const stream, const Zenuity_Debug_HighestThreatInfo *const data);
static bool decode_Zenuity_Debug_VruCollisionAvoidanceDiagnostics_highestThreatInfo(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AebDiagnostics_Raw_allBraking(qpb_ostream_t *const stream, const Zenuity_Debug_AllBrakeDiagnostics_Raw *const data);
static bool decode_Zenuity_Debug_AebDiagnostics_Raw_allBraking(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AebDiagnostics_Raw_inhibition(qpb_ostream_t *const stream, const Zenuity_Debug_AebInhibitionDiagnostic_Raw *const data);
static bool decode_Zenuity_Debug_AebDiagnostics_Raw_inhibition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AebDiagnostics_Raw_status(qpb_ostream_t *const stream, const Zenuity_Debug_AebGeneralStatusDiagnostic_Raw *const data);
static bool decode_Zenuity_Debug_AebDiagnostics_Raw_status(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Debug_AebDiagnostics_Raw_primaryTarget(qpb_ostream_t *const stream, const Zenuity_Debug_AebPrimaryTarget_Raw *const data);
static bool decode_Zenuity_Debug_AebDiagnostics_Raw_primaryTarget(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);

#define Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_DECODERS_COUNT 4
const qpb_decoder_entry_t Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_decoders[Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_deactivationCause },
   { &decode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_postStatus },
   { &decode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_triggeringCause }
};

#define Zenuity_Debug_AebInhibitionDiagnostic_Raw_DECODERS_COUNT 10
const qpb_decoder_entry_t Zenuity_Debug_AebInhibitionDiagnostic_Raw_decoders[Zenuity_Debug_AebInhibitionDiagnostic_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_abortIfNotConfirmed },
   { &decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_hostAvoidInhibit },
   { &decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_inhibitActivation },
   { &decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_objectDirectionInhibit },
   { &decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_oncomingInhibit },
   { &decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_notOncomingScenarioInScope },
   { &decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_pointOfImpactInhibit },
   { &decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_radarOnlyInhibit },
   { &decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_speedInhibit }
};

#define Zenuity_Debug_AebPrimaryTarget_Raw_DECODERS_COUNT 2
const qpb_decoder_entry_t Zenuity_Debug_AebPrimaryTarget_Raw_decoders[Zenuity_Debug_AebPrimaryTarget_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_AebPrimaryTarget_Raw_objectIdForBraking }
};

#define Zenuity_Debug_BrakingDiagnostic_Raw_DECODERS_COUNT 7
const qpb_decoder_entry_t Zenuity_Debug_BrakingDiagnostic_Raw_decoders[Zenuity_Debug_BrakingDiagnostic_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_BrakingDiagnostic_Raw_accelerationThreat },
   { &decode_Zenuity_Debug_BrakingDiagnostic_Raw_brakingThreat },
   { &decode_Zenuity_Debug_BrakingDiagnostic_Raw_multiTargetSteeringThreat },
   { &decode_Zenuity_Debug_BrakingDiagnostic_Raw_brakingConfidence },
   { &decode_Zenuity_Debug_BrakingDiagnostic_Raw_singleTargetSteeringThreat },
   { &decode_Zenuity_Debug_BrakingDiagnostic_Raw_steeringThreat }
};

#define Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_decoders[Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_brakeGainActive },
   { &decode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_brakeThreatNumberAboveLimit },
   { &decode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_driverPressedBrakePedal },
   { &decode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_driverDecelerationRequestAboveLimit }
};

#define Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_decoders[Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_cwInhibit },
   { &decode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_belowLowSpeedLimit },
   { &decode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_aboveHighSpeedLimit },
   { &decode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_disabledByFaultManager }
};

#define Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_DECODERS_COUNT 7
const qpb_decoder_entry_t Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_decoders[Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_startConditionsMet },
   { &decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_btnBasedWarningDriver },
   { &decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_btnBaseWarningAcc },
   { &decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_comfortDistanceWarning },
   { &decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_abnormalAccelerationWarning },
   { &decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_visionOnlyWarning }
};

#define Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_decoders[Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_activatingLateralJerk },
   { &decode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_eventIsJustified },
   { &decode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_scenario },
   { &decode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_state }
};

#define Zenuity_Debug_HighestThreatInfo_Raw_DECODERS_COUNT 4
const qpb_decoder_entry_t Zenuity_Debug_HighestThreatInfo_Raw_decoders[Zenuity_Debug_HighestThreatInfo_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_HighestThreatInfo_Raw_objectId },
   { &decode_Zenuity_Debug_HighestThreatInfo_Raw_timeToCollision },
   { &decode_Zenuity_Debug_HighestThreatInfo_Raw_lateralMargin }
};

#define Zenuity_Debug_HighestThreatInfo_DECODERS_COUNT 4
const qpb_decoder_entry_t Zenuity_Debug_HighestThreatInfo_decoders[Zenuity_Debug_HighestThreatInfo_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_HighestThreatInfo_objectId },
   { &decode_Zenuity_Debug_HighestThreatInfo_timeToCollision },
   { &decode_Zenuity_Debug_HighestThreatInfo_lateralMargin }
};

#define Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_decoders[Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectLeftHostLeftOverlap },
   { &decode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectLeftHostRightOverlap },
   { &decode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectRightHostLeftOverlap },
   { &decode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectRightHostRightOverlap }
};

#define Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_DECODERS_COUNT 20
const qpb_decoder_entry_t Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_decoders[Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_electronicHorizonUsage },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralSafetyOffsetToObject },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralInPathOffsetToPredictedObject },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralInPathOffsetToObject },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_longitudinalSafetyOffsetToObject },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_loopIndexTa },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectBusSource },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectCenterTimeVectorIndex },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectCosineHeading },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectDirection },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectInPath },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLateralPositionCenter },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLength },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLongitudinalPositionCenter },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectSineHeading },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectTrajectoryLastInPath },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectWidth },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_timeToReachObject },
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_visionId }
};

#define Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_decoders[Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_validSensorData },
   { &decode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_sufficientSensorData },
   { &decode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_threatExists },
   { &decode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_objectManeuverOverlapsHostManeuver }
};

#define Zenuity_Debug_AllBrakeDiagnostics_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t Zenuity_Debug_AllBrakeDiagnostics_Raw_decoders[Zenuity_Debug_AllBrakeDiagnostics_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_AllBrakeDiagnostics_Raw_fullBrake },
   { &decode_Zenuity_Debug_AllBrakeDiagnostics_Raw_preBrake }
};

#define Zenuity_Debug_CollisionWarningDiagnostics_Raw_DECODERS_COUNT 9
const qpb_decoder_entry_t Zenuity_Debug_CollisionWarningDiagnostics_Raw_decoders[Zenuity_Debug_CollisionWarningDiagnostics_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakeGainInhibitConditionStatus },
   { &decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakeGainState },
   { &decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakePulseState },
   { &decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_inhibitionConditionStatus },
   { &decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_objectIdForWarning },
   { &decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_startConditionStatus },
   { &decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_warningState },
   { &decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_warningType }
};

#define Zenuity_Debug_ThreatAssessmentDiagnostics_Raw_DECODERS_COUNT 2
const qpb_decoder_entry_t Zenuity_Debug_ThreatAssessmentDiagnostics_Raw_decoders[Zenuity_Debug_ThreatAssessmentDiagnostics_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_ThreatAssessmentDiagnostics_Raw_sortedObjects }
};

#define Zenuity_Debug_VruCollisionAvoidanceDiagnostics_Raw_DECODERS_COUNT 2
const qpb_decoder_entry_t Zenuity_Debug_VruCollisionAvoidanceDiagnostics_Raw_decoders[Zenuity_Debug_VruCollisionAvoidanceDiagnostics_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_VruCollisionAvoidanceDiagnostics_Raw_highestThreatInfo }
};

#define Zenuity_Debug_VruCollisionAvoidanceDiagnostics_DECODERS_COUNT 2
const qpb_decoder_entry_t Zenuity_Debug_VruCollisionAvoidanceDiagnostics_decoders[Zenuity_Debug_VruCollisionAvoidanceDiagnostics_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_VruCollisionAvoidanceDiagnostics_highestThreatInfo }
};

#define Zenuity_Debug_AebDiagnostics_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t Zenuity_Debug_AebDiagnostics_Raw_decoders[Zenuity_Debug_AebDiagnostics_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Debug_AebDiagnostics_Raw_allBraking },
   { &decode_Zenuity_Debug_AebDiagnostics_Raw_inhibition },
   { &decode_Zenuity_Debug_AebDiagnostics_Raw_status },
   { &decode_Zenuity_Debug_AebDiagnostics_Raw_primaryTarget }
};

static inline void encode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_deactivationCause(qpb_ostream_t *const stream, const Zenuity_Debug_AebDeactivationCause *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_deactivationCause(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_AebGeneralStatusDiagnostic_Raw*)data)->deactivationCause, qpb_membersize(Zenuity_Debug_AebGeneralStatusDiagnostic_Raw, deactivationCause));
}

static inline void encode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_postStatus(qpb_ostream_t *const stream, const Zenuity_Debug_PostAebStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_postStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_AebGeneralStatusDiagnostic_Raw*)data)->postStatus, qpb_membersize(Zenuity_Debug_AebGeneralStatusDiagnostic_Raw, postStatus));
}

static inline void encode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_triggeringCause(qpb_ostream_t *const stream, const Zenuity_Debug_AebTriggeringScenario *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_triggeringCause(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_AebGeneralStatusDiagnostic_Raw*)data)->triggeringCause, qpb_membersize(Zenuity_Debug_AebGeneralStatusDiagnostic_Raw, triggeringCause));
}

static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_abortIfNotConfirmed(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_abortIfNotConfirmed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_AebInhibitionDiagnostic_Raw*)data)->abortIfNotConfirmed, sizeof(bool));
}

static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_hostAvoidInhibit(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_hostAvoidInhibit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_AebInhibitionDiagnostic_Raw*)data)->hostAvoidInhibit, sizeof(bool));
}

static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_inhibitActivation(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_inhibitActivation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_AebInhibitionDiagnostic_Raw*)data)->inhibitActivation, sizeof(bool));
}

static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_objectDirectionInhibit(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_objectDirectionInhibit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_AebInhibitionDiagnostic_Raw*)data)->objectDirectionInhibit, sizeof(bool));
}

static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_oncomingInhibit(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_oncomingInhibit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_AebInhibitionDiagnostic_Raw*)data)->oncomingInhibit, sizeof(bool));
}

static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_notOncomingScenarioInScope(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_notOncomingScenarioInScope(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_AebInhibitionDiagnostic_Raw*)data)->notOncomingScenarioInScope, sizeof(bool));
}

static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_pointOfImpactInhibit(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_pointOfImpactInhibit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_AebInhibitionDiagnostic_Raw*)data)->pointOfImpactInhibit, sizeof(bool));
}

static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_radarOnlyInhibit(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_radarOnlyInhibit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_AebInhibitionDiagnostic_Raw*)data)->radarOnlyInhibit, sizeof(bool));
}

static inline void encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_speedInhibit(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 72;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_speedInhibit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_AebInhibitionDiagnostic_Raw*)data)->speedInhibit, sizeof(bool));
}

static inline void encode_Zenuity_Debug_AebPrimaryTarget_Raw_objectIdForBraking(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_AebPrimaryTarget_Raw_objectIdForBraking(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((Zenuity_Debug_AebPrimaryTarget_Raw*)data)->objectIdForBraking, sizeof(uint16_t));
}

static inline void encode_Zenuity_Debug_BrakingDiagnostic_Raw_accelerationThreat(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_BrakingDiagnostic_Raw_accelerationThreat(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_BrakingDiagnostic_Raw*)data)->accelerationThreat, sizeof(bool));
}

static inline void encode_Zenuity_Debug_BrakingDiagnostic_Raw_brakingThreat(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_BrakingDiagnostic_Raw_brakingThreat(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_BrakingDiagnostic_Raw*)data)->brakingThreat, sizeof(bool));
}

static inline void encode_Zenuity_Debug_BrakingDiagnostic_Raw_multiTargetSteeringThreat(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_BrakingDiagnostic_Raw_multiTargetSteeringThreat(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_BrakingDiagnostic_Raw*)data)->multiTargetSteeringThreat, sizeof(bool));
}

static inline void encode_Zenuity_Debug_BrakingDiagnostic_Raw_brakingConfidence(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_BrakingDiagnostic_Raw_brakingConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_BrakingDiagnostic_Raw*)data)->brakingConfidence, sizeof(bool));
}

static inline void encode_Zenuity_Debug_BrakingDiagnostic_Raw_singleTargetSteeringThreat(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_BrakingDiagnostic_Raw_singleTargetSteeringThreat(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_BrakingDiagnostic_Raw*)data)->singleTargetSteeringThreat, sizeof(bool));
}

static inline void encode_Zenuity_Debug_BrakingDiagnostic_Raw_steeringThreat(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_BrakingDiagnostic_Raw_steeringThreat(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_BrakingDiagnostic_Raw*)data)->steeringThreat, sizeof(bool));
}

static inline void encode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_brakeGainActive(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_brakeGainActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw*)data)->brakeGainActive, sizeof(bool));
}

static inline void encode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_brakeThreatNumberAboveLimit(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_brakeThreatNumberAboveLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw*)data)->brakeThreatNumberAboveLimit, sizeof(bool));
}

static inline void encode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_driverPressedBrakePedal(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_driverPressedBrakePedal(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw*)data)->driverPressedBrakePedal, sizeof(bool));
}

static inline void encode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_driverDecelerationRequestAboveLimit(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_driverDecelerationRequestAboveLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw*)data)->driverDecelerationRequestAboveLimit, sizeof(bool));
}

static inline void encode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_cwInhibit(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_cwInhibit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw*)data)->cwInhibit, sizeof(bool));
}

static inline void encode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_belowLowSpeedLimit(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_belowLowSpeedLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw*)data)->belowLowSpeedLimit, sizeof(bool));
}

static inline void encode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_aboveHighSpeedLimit(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_aboveHighSpeedLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw*)data)->aboveHighSpeedLimit, sizeof(bool));
}

static inline void encode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_disabledByFaultManager(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_disabledByFaultManager(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw*)data)->disabledByFaultManager, sizeof(bool));
}

static inline void encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_startConditionsMet(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_startConditionsMet(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_CollisionWarningStartConditionStatus_Raw*)data)->startConditionsMet, sizeof(bool));
}

static inline void encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_btnBasedWarningDriver(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_btnBasedWarningDriver(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_CollisionWarningStartConditionStatus_Raw*)data)->btnBasedWarningDriver, sizeof(bool));
}

static inline void encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_btnBaseWarningAcc(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_btnBaseWarningAcc(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_CollisionWarningStartConditionStatus_Raw*)data)->btnBaseWarningAcc, sizeof(bool));
}

static inline void encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_comfortDistanceWarning(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_comfortDistanceWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_CollisionWarningStartConditionStatus_Raw*)data)->comfortDistanceWarning, sizeof(bool));
}

static inline void encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_abnormalAccelerationWarning(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_abnormalAccelerationWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_CollisionWarningStartConditionStatus_Raw*)data)->abnormalAccelerationWarning, sizeof(bool));
}

static inline void encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_visionOnlyWarning(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_visionOnlyWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_CollisionWarningStartConditionStatus_Raw*)data)->visionOnlyWarning, sizeof(bool));
}

static inline void encode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_activatingLateralJerk(qpb_ostream_t *const stream, const float *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 13;
      ++stream->buffer;
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_activatingLateralJerk(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw*)data)->activatingLateralJerk);
}

static inline void encode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_eventIsJustified(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_eventIsJustified(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw*)data)->eventIsJustified, sizeof(bool));
}

static inline void encode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_scenario(qpb_ostream_t *const stream, const Zenuity_Debug_MotionPattern *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_scenario(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw*)data)->scenario, qpb_membersize(Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw, scenario));
}

static inline void encode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_state(qpb_ostream_t *const stream, const Zenuity_Debug_EmaState *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_state(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw*)data)->state, qpb_membersize(Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw, state));
}

static inline void encode_Zenuity_Debug_HighestThreatInfo_Raw_objectId(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_HighestThreatInfo_Raw_objectId(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((Zenuity_Debug_HighestThreatInfo_Raw*)data)->objectId, sizeof(uint16_t));
}

static inline void encode_Zenuity_Debug_HighestThreatInfo_Raw_timeToCollision(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_HighestThreatInfo_Raw_timeToCollision(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((Zenuity_Debug_HighestThreatInfo_Raw*)data)->timeToCollision, sizeof(uint16_t));
}

static inline void encode_Zenuity_Debug_HighestThreatInfo_Raw_lateralMargin(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_HighestThreatInfo_Raw_lateralMargin(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((Zenuity_Debug_HighestThreatInfo_Raw*)data)->lateralMargin, sizeof(int16_t));
}

static inline void encode_Zenuity_Debug_HighestThreatInfo_objectId(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_HighestThreatInfo_objectId(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((Zenuity_Debug_HighestThreatInfo*)data)->objectId, sizeof(uint16_t));
}

static inline void encode_Zenuity_Debug_HighestThreatInfo_timeToCollision(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_Zenuity_Debug_HighestThreatInfo_Raw_timeToCollision(stream, &value);
}

static bool decode_Zenuity_Debug_HighestThreatInfo_timeToCollision(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((Zenuity_Debug_HighestThreatInfo*)data)->timeToCollision = value * F_0_01;
   return result;
}

static inline void encode_Zenuity_Debug_HighestThreatInfo_lateralMargin(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_1, INT16_MIN, INT16_MAX);
   encode_Zenuity_Debug_HighestThreatInfo_Raw_lateralMargin(stream, &value);
}

static bool decode_Zenuity_Debug_HighestThreatInfo_lateralMargin(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((Zenuity_Debug_HighestThreatInfo*)data)->lateralMargin = value * F_0_1;
   return result;
}

static inline void encode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectLeftHostLeftOverlap(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectLeftHostLeftOverlap(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw*)data)->objectLeftHostLeftOverlap, sizeof(bool));
}

static inline void encode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectLeftHostRightOverlap(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectLeftHostRightOverlap(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw*)data)->objectLeftHostRightOverlap, sizeof(bool));
}

static inline void encode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectRightHostLeftOverlap(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectRightHostLeftOverlap(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw*)data)->objectRightHostLeftOverlap, sizeof(bool));
}

static inline void encode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectRightHostRightOverlap(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectRightHostRightOverlap(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw*)data)->objectRightHostRightOverlap, sizeof(bool));
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_electronicHorizonUsage(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_electronicHorizonUsage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->electronicHorizonUsage, sizeof(bool));
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralSafetyOffsetToObject(qpb_ostream_t *const stream, const float *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 21;
      ++stream->buffer;
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralSafetyOffsetToObject(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->lateralSafetyOffsetToObject);
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralInPathOffsetToPredictedObject(qpb_ostream_t *const stream, const float *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 29;
      ++stream->buffer;
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralInPathOffsetToPredictedObject(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->lateralInPathOffsetToPredictedObject);
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralInPathOffsetToObject(qpb_ostream_t *const stream, const float *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 37;
      ++stream->buffer;
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralInPathOffsetToObject(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->lateralInPathOffsetToObject);
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_longitudinalSafetyOffsetToObject(qpb_ostream_t *const stream, const float *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 45;
      ++stream->buffer;
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_longitudinalSafetyOffsetToObject(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->longitudinalSafetyOffsetToObject);
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_loopIndexTa(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_loopIndexTa(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->loopIndexTa, sizeof(uint8_t));
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectBusSource(qpb_ostream_t *const stream, const Zenuity_Debug_ObjectBusType *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectBusSource(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->objectBusSource, qpb_membersize(Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw, objectBusSource));
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectCenterTimeVectorIndex(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectCenterTimeVectorIndex(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->objectCenterTimeVectorIndex, sizeof(uint16_t));
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectCosineHeading(qpb_ostream_t *const stream, const float *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 77;
      ++stream->buffer;
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectCosineHeading(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->objectCosineHeading);
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectDirection(qpb_ostream_t *const stream, const Zenuity_Debug_MotionPattern *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 80;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectDirection(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->objectDirection, qpb_membersize(Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw, objectDirection));
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectInPath(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 88;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectInPath(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->objectInPath, sizeof(bool));
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLateralPositionCenter(qpb_ostream_t *const stream, const float *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 101;
      ++stream->buffer;
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLateralPositionCenter(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->objectLateralPositionCenter);
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLength(qpb_ostream_t *const stream, const float *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 109;
      ++stream->buffer;
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLength(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->objectLength);
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLongitudinalPositionCenter(qpb_ostream_t *const stream, const float *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 117;
      ++stream->buffer;
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLongitudinalPositionCenter(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->objectLongitudinalPositionCenter);
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectSineHeading(qpb_ostream_t *const stream, const float *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 125;
      ++stream->buffer;
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectSineHeading(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->objectSineHeading);
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectTrajectoryLastInPath(qpb_ostream_t *const stream, const Zenuity_Debug_ObjectTrajectoryInPath *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 128);
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectTrajectoryLastInPath(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->objectTrajectoryLastInPath, qpb_membersize(Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw, objectTrajectoryLastInPath));
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectWidth(qpb_ostream_t *const stream, const float *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 141);
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectWidth(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->objectWidth);
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_timeToReachObject(qpb_ostream_t *const stream, const float *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 149);
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_timeToReachObject(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->timeToReachObject);
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_visionId(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 152);
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_visionId(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw*)data)->visionId, sizeof(uint8_t));
}

static inline void encode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_validSensorData(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_validSensorData(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw*)data)->validSensorData, sizeof(bool));
}

static inline void encode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_sufficientSensorData(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_sufficientSensorData(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw*)data)->sufficientSensorData, sizeof(bool));
}

static inline void encode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_threatExists(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_threatExists(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw*)data)->threatExists, sizeof(bool));
}

static inline void encode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_objectManeuverOverlapsHostManeuver(qpb_ostream_t *const stream, const Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_objectManeuverOverlapsHostManeuver(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw(&substream, &((Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw*)data)->objectManeuverOverlapsHostManeuver);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Debug_AllBrakeDiagnostics_Raw_fullBrake(qpb_ostream_t *const stream, const Zenuity_Debug_BrakingDiagnostic_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Debug_BrakingDiagnostic_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Debug_AllBrakeDiagnostics_Raw_fullBrake(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Debug_BrakingDiagnostic_Raw(&substream, &((Zenuity_Debug_AllBrakeDiagnostics_Raw*)data)->fullBrake);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Debug_AllBrakeDiagnostics_Raw_preBrake(qpb_ostream_t *const stream, const Zenuity_Debug_BrakingDiagnostic_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Debug_BrakingDiagnostic_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Debug_AllBrakeDiagnostics_Raw_preBrake(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Debug_BrakingDiagnostic_Raw(&substream, &((Zenuity_Debug_AllBrakeDiagnostics_Raw*)data)->preBrake);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakeGainInhibitConditionStatus(qpb_ostream_t *const stream, const Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakeGainInhibitConditionStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw(&substream, &((Zenuity_Debug_CollisionWarningDiagnostics_Raw*)data)->brakeGainInhibitConditionStatus);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakeGainState(qpb_ostream_t *const stream, const Zenuity_Debug_BrakeGainState *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakeGainState(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_CollisionWarningDiagnostics_Raw*)data)->brakeGainState, qpb_membersize(Zenuity_Debug_CollisionWarningDiagnostics_Raw, brakeGainState));
}

static inline void encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakePulseState(qpb_ostream_t *const stream, const Zenuity_Debug_BrakePulseState *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakePulseState(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_CollisionWarningDiagnostics_Raw*)data)->brakePulseState, qpb_membersize(Zenuity_Debug_CollisionWarningDiagnostics_Raw, brakePulseState));
}

static inline void encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_inhibitionConditionStatus(qpb_ostream_t *const stream, const Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_inhibitionConditionStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw(&substream, &((Zenuity_Debug_CollisionWarningDiagnostics_Raw*)data)->inhibitionConditionStatus);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_objectIdForWarning(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_objectIdForWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((Zenuity_Debug_CollisionWarningDiagnostics_Raw*)data)->objectIdForWarning, sizeof(uint16_t));
}

static inline void encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_startConditionStatus(qpb_ostream_t *const stream, const Zenuity_Debug_CollisionWarningStartConditionStatus_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 50;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_startConditionStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw(&substream, &((Zenuity_Debug_CollisionWarningDiagnostics_Raw*)data)->startConditionStatus);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_warningState(qpb_ostream_t *const stream, const Zenuity_Debug_AudioVisualWarningState *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_warningState(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_CollisionWarningDiagnostics_Raw*)data)->warningState, qpb_membersize(Zenuity_Debug_CollisionWarningDiagnostics_Raw, warningState));
}

static inline void encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_warningType(qpb_ostream_t *const stream, const Zenuity_Debug_WarningType *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_warningType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Debug_CollisionWarningDiagnostics_Raw*)data)->warningType, qpb_membersize(Zenuity_Debug_CollisionWarningDiagnostics_Raw, warningType));
}

static inline void encode_Zenuity_Debug_ThreatAssessmentDiagnostics_Raw_sortedObjects(qpb_ostream_t *const stream, const Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 10;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_Zenuity_Debug_ThreatAssessmentDiagnostics_Raw_sortedObjects(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((Zenuity_Debug_ThreatAssessmentDiagnostics_Raw*)data)->sortedObjects_count + 1) > 5)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw(&substream, &((Zenuity_Debug_ThreatAssessmentDiagnostics_Raw*)data)->sortedObjects[((Zenuity_Debug_ThreatAssessmentDiagnostics_Raw*)data)->sortedObjects_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_Zenuity_Debug_VruCollisionAvoidanceDiagnostics_Raw_highestThreatInfo(qpb_ostream_t *const stream, const Zenuity_Debug_HighestThreatInfo_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Debug_HighestThreatInfo_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Debug_VruCollisionAvoidanceDiagnostics_Raw_highestThreatInfo(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Debug_HighestThreatInfo_Raw(&substream, &((Zenuity_Debug_VruCollisionAvoidanceDiagnostics_Raw*)data)->highestThreatInfo);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Debug_VruCollisionAvoidanceDiagnostics_highestThreatInfo(qpb_ostream_t *const stream, const Zenuity_Debug_HighestThreatInfo *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Debug_HighestThreatInfo(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Debug_VruCollisionAvoidanceDiagnostics_highestThreatInfo(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Debug_HighestThreatInfo(&substream, &((Zenuity_Debug_VruCollisionAvoidanceDiagnostics*)data)->highestThreatInfo);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Debug_AebDiagnostics_Raw_allBraking(qpb_ostream_t *const stream, const Zenuity_Debug_AllBrakeDiagnostics_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Debug_AllBrakeDiagnostics_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Debug_AebDiagnostics_Raw_allBraking(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Debug_AllBrakeDiagnostics_Raw(&substream, &((Zenuity_Debug_AebDiagnostics_Raw*)data)->allBraking);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Debug_AebDiagnostics_Raw_inhibition(qpb_ostream_t *const stream, const Zenuity_Debug_AebInhibitionDiagnostic_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Debug_AebDiagnostics_Raw_inhibition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw(&substream, &((Zenuity_Debug_AebDiagnostics_Raw*)data)->inhibition);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Debug_AebDiagnostics_Raw_status(qpb_ostream_t *const stream, const Zenuity_Debug_AebGeneralStatusDiagnostic_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Debug_AebDiagnostics_Raw_status(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw(&substream, &((Zenuity_Debug_AebDiagnostics_Raw*)data)->status);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Debug_AebDiagnostics_Raw_primaryTarget(qpb_ostream_t *const stream, const Zenuity_Debug_AebPrimaryTarget_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Debug_AebPrimaryTarget_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Debug_AebDiagnostics_Raw_primaryTarget(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Debug_AebPrimaryTarget_Raw(&substream, &((Zenuity_Debug_AebDiagnostics_Raw*)data)->primaryTarget);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

/* Encoding / decoding functions */
bool encode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw(qpb_ostream_t *const stream, const Zenuity_Debug_AebGeneralStatusDiagnostic_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_AebGeneralStatusDiagnostic_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_deactivationCause(stream, &data->deactivationCause);
   encode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_postStatus(stream, &data->postStatus);
   encode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_triggeringCause(stream, &data->triggeringCause);
   return true;
}

bool decode_Zenuity_Debug_AebGeneralStatusDiagnostic_Raw(qpb_istream_t *const stream, Zenuity_Debug_AebGeneralStatusDiagnostic_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_AebGeneralStatusDiagnostic_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw(qpb_ostream_t *const stream, const Zenuity_Debug_AebInhibitionDiagnostic_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_AebInhibitionDiagnostic_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_abortIfNotConfirmed(stream, &data->abortIfNotConfirmed);
   encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_hostAvoidInhibit(stream, &data->hostAvoidInhibit);
   encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_inhibitActivation(stream, &data->inhibitActivation);
   encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_objectDirectionInhibit(stream, &data->objectDirectionInhibit);
   encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_oncomingInhibit(stream, &data->oncomingInhibit);
   encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_notOncomingScenarioInScope(stream, &data->notOncomingScenarioInScope);
   encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_pointOfImpactInhibit(stream, &data->pointOfImpactInhibit);
   encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_radarOnlyInhibit(stream, &data->radarOnlyInhibit);
   encode_Zenuity_Debug_AebInhibitionDiagnostic_Raw_speedInhibit(stream, &data->speedInhibit);
   return true;
}

bool decode_Zenuity_Debug_AebInhibitionDiagnostic_Raw(qpb_istream_t *const stream, Zenuity_Debug_AebInhibitionDiagnostic_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_AebInhibitionDiagnostic_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_AebInhibitionDiagnostic_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_AebPrimaryTarget_Raw(qpb_ostream_t *const stream, const Zenuity_Debug_AebPrimaryTarget_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_AebPrimaryTarget_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_AebPrimaryTarget_Raw_objectIdForBraking(stream, &data->objectIdForBraking);
   return true;
}

bool decode_Zenuity_Debug_AebPrimaryTarget_Raw(qpb_istream_t *const stream, Zenuity_Debug_AebPrimaryTarget_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_AebPrimaryTarget_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_AebPrimaryTarget_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_BrakingDiagnostic_Raw(qpb_ostream_t *const stream, const Zenuity_Debug_BrakingDiagnostic_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_BrakingDiagnostic_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_BrakingDiagnostic_Raw_accelerationThreat(stream, &data->accelerationThreat);
   encode_Zenuity_Debug_BrakingDiagnostic_Raw_brakingThreat(stream, &data->brakingThreat);
   encode_Zenuity_Debug_BrakingDiagnostic_Raw_multiTargetSteeringThreat(stream, &data->multiTargetSteeringThreat);
   encode_Zenuity_Debug_BrakingDiagnostic_Raw_brakingConfidence(stream, &data->brakingConfidence);
   encode_Zenuity_Debug_BrakingDiagnostic_Raw_singleTargetSteeringThreat(stream, &data->singleTargetSteeringThreat);
   encode_Zenuity_Debug_BrakingDiagnostic_Raw_steeringThreat(stream, &data->steeringThreat);
   return true;
}

bool decode_Zenuity_Debug_BrakingDiagnostic_Raw(qpb_istream_t *const stream, Zenuity_Debug_BrakingDiagnostic_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_BrakingDiagnostic_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_BrakingDiagnostic_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw(qpb_ostream_t *const stream, const Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_BrakingGainInhibitConditionStatus_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_brakeGainActive(stream, &data->brakeGainActive);
   encode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_brakeThreatNumberAboveLimit(stream, &data->brakeThreatNumberAboveLimit);
   encode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_driverPressedBrakePedal(stream, &data->driverPressedBrakePedal);
   encode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_driverDecelerationRequestAboveLimit(stream, &data->driverDecelerationRequestAboveLimit);
   return true;
}

bool decode_Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw(qpb_istream_t *const stream, Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_BrakingGainInhibitConditionStatus_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw(qpb_ostream_t *const stream, const Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_CollisionWarningInhibitConditionStatus_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_cwInhibit(stream, &data->cwInhibit);
   encode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_belowLowSpeedLimit(stream, &data->belowLowSpeedLimit);
   encode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_aboveHighSpeedLimit(stream, &data->aboveHighSpeedLimit);
   encode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_disabledByFaultManager(stream, &data->disabledByFaultManager);
   return true;
}

bool decode_Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw(qpb_istream_t *const stream, Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_CollisionWarningInhibitConditionStatus_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw(qpb_ostream_t *const stream, const Zenuity_Debug_CollisionWarningStartConditionStatus_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_CollisionWarningStartConditionStatus_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_startConditionsMet(stream, &data->startConditionsMet);
   encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_btnBasedWarningDriver(stream, &data->btnBasedWarningDriver);
   encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_btnBaseWarningAcc(stream, &data->btnBaseWarningAcc);
   encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_comfortDistanceWarning(stream, &data->comfortDistanceWarning);
   encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_abnormalAccelerationWarning(stream, &data->abnormalAccelerationWarning);
   encode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_visionOnlyWarning(stream, &data->visionOnlyWarning);
   return true;
}

bool decode_Zenuity_Debug_CollisionWarningStartConditionStatus_Raw(qpb_istream_t *const stream, Zenuity_Debug_CollisionWarningStartConditionStatus_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_CollisionWarningStartConditionStatus_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw(qpb_ostream_t *const stream, const Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_activatingLateralJerk(stream, &data->activatingLateralJerk);
   encode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_eventIsJustified(stream, &data->eventIsJustified);
   encode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_scenario(stream, &data->scenario);
   encode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_state(stream, &data->state);
   return true;
}

bool decode_Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw(qpb_istream_t *const stream, Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_EvasiveManoeuvreAssistDiagnostics_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_HighestThreatInfo_Raw(qpb_ostream_t *const stream, const Zenuity_Debug_HighestThreatInfo_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_HighestThreatInfo_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_HighestThreatInfo_Raw_objectId(stream, &data->objectId);
   encode_Zenuity_Debug_HighestThreatInfo_Raw_timeToCollision(stream, &data->timeToCollision);
   encode_Zenuity_Debug_HighestThreatInfo_Raw_lateralMargin(stream, &data->lateralMargin);
   return true;
}

bool decode_Zenuity_Debug_HighestThreatInfo_Raw(qpb_istream_t *const stream, Zenuity_Debug_HighestThreatInfo_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_HighestThreatInfo_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_HighestThreatInfo_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_HighestThreatInfo(qpb_ostream_t *const stream, const Zenuity_Debug_HighestThreatInfo *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_HighestThreatInfo_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_HighestThreatInfo_Raw_objectId(stream, &data->objectId);
   encode_Zenuity_Debug_HighestThreatInfo_timeToCollision(stream, &data->timeToCollision);
   encode_Zenuity_Debug_HighestThreatInfo_lateralMargin(stream, &data->lateralMargin);
   return true;
}

bool decode_Zenuity_Debug_HighestThreatInfo(qpb_istream_t *const stream, Zenuity_Debug_HighestThreatInfo *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_HighestThreatInfo_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_HighestThreatInfo_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw(qpb_ostream_t *const stream, const Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectLeftHostLeftOverlap(stream, &data->objectLeftHostLeftOverlap);
   encode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectLeftHostRightOverlap(stream, &data->objectLeftHostRightOverlap);
   encode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectRightHostLeftOverlap(stream, &data->objectRightHostLeftOverlap);
   encode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_objectRightHostRightOverlap(stream, &data->objectRightHostRightOverlap);
   return true;
}

bool decode_Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw(qpb_istream_t *const stream, Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_ObjectManeuverOverlapsHostManeuver_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw(qpb_ostream_t *const stream, const Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_ThreatAssessmentDiagnosticObject_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_electronicHorizonUsage(stream, &data->electronicHorizonUsage);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralSafetyOffsetToObject(stream, &data->lateralSafetyOffsetToObject);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralInPathOffsetToPredictedObject(stream, &data->lateralInPathOffsetToPredictedObject);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_lateralInPathOffsetToObject(stream, &data->lateralInPathOffsetToObject);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_longitudinalSafetyOffsetToObject(stream, &data->longitudinalSafetyOffsetToObject);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_loopIndexTa(stream, &data->loopIndexTa);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectBusSource(stream, &data->objectBusSource);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectCenterTimeVectorIndex(stream, &data->objectCenterTimeVectorIndex);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectCosineHeading(stream, &data->objectCosineHeading);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectDirection(stream, &data->objectDirection);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectInPath(stream, &data->objectInPath);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLateralPositionCenter(stream, &data->objectLateralPositionCenter);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLength(stream, &data->objectLength);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectLongitudinalPositionCenter(stream, &data->objectLongitudinalPositionCenter);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectSineHeading(stream, &data->objectSineHeading);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectTrajectoryLastInPath(stream, &data->objectTrajectoryLastInPath);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_objectWidth(stream, &data->objectWidth);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_timeToReachObject(stream, &data->timeToReachObject);
   encode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_visionId(stream, &data->visionId);
   return true;
}

bool decode_Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw(qpb_istream_t *const stream, Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_ThreatAssessmentDiagnosticObject_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw(qpb_ostream_t *const stream, const Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_ASILThreatAssesmentDiagnostics_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_validSensorData(stream, &data->validSensorData);
   encode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_sufficientSensorData(stream, &data->sufficientSensorData);
   encode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_threatExists(stream, &data->threatExists);
   encode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_objectManeuverOverlapsHostManeuver(stream, &data->objectManeuverOverlapsHostManeuver);
   return true;
}

bool decode_Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw(qpb_istream_t *const stream, Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_ASILThreatAssesmentDiagnostics_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_AllBrakeDiagnostics_Raw(qpb_ostream_t *const stream, const Zenuity_Debug_AllBrakeDiagnostics_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_AllBrakeDiagnostics_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_AllBrakeDiagnostics_Raw_fullBrake(stream, &data->fullBrake);
   encode_Zenuity_Debug_AllBrakeDiagnostics_Raw_preBrake(stream, &data->preBrake);
   return true;
}

bool decode_Zenuity_Debug_AllBrakeDiagnostics_Raw(qpb_istream_t *const stream, Zenuity_Debug_AllBrakeDiagnostics_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_AllBrakeDiagnostics_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_AllBrakeDiagnostics_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw(qpb_ostream_t *const stream, const Zenuity_Debug_CollisionWarningDiagnostics_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_CollisionWarningDiagnostics_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakeGainInhibitConditionStatus(stream, &data->brakeGainInhibitConditionStatus);
   encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakeGainState(stream, &data->brakeGainState);
   encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_brakePulseState(stream, &data->brakePulseState);
   encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_inhibitionConditionStatus(stream, &data->inhibitionConditionStatus);
   encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_objectIdForWarning(stream, &data->objectIdForWarning);
   encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_startConditionStatus(stream, &data->startConditionStatus);
   encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_warningState(stream, &data->warningState);
   encode_Zenuity_Debug_CollisionWarningDiagnostics_Raw_warningType(stream, &data->warningType);
   return true;
}

bool decode_Zenuity_Debug_CollisionWarningDiagnostics_Raw(qpb_istream_t *const stream, Zenuity_Debug_CollisionWarningDiagnostics_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_CollisionWarningDiagnostics_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_CollisionWarningDiagnostics_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_ThreatAssessmentDiagnostics_Raw(qpb_ostream_t *const stream, const Zenuity_Debug_ThreatAssessmentDiagnostics_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_ThreatAssessmentDiagnostics_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_ThreatAssessmentDiagnostics_Raw_sortedObjects(stream, data->sortedObjects, data->sortedObjects_count);
   return true;
}

bool decode_Zenuity_Debug_ThreatAssessmentDiagnostics_Raw(qpb_istream_t *const stream, Zenuity_Debug_ThreatAssessmentDiagnostics_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_ThreatAssessmentDiagnostics_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_ThreatAssessmentDiagnostics_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_VruCollisionAvoidanceDiagnostics_Raw(qpb_ostream_t *const stream, const Zenuity_Debug_VruCollisionAvoidanceDiagnostics_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_VruCollisionAvoidanceDiagnostics_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_VruCollisionAvoidanceDiagnostics_Raw_highestThreatInfo(stream, &data->highestThreatInfo);
   return true;
}

bool decode_Zenuity_Debug_VruCollisionAvoidanceDiagnostics_Raw(qpb_istream_t *const stream, Zenuity_Debug_VruCollisionAvoidanceDiagnostics_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_VruCollisionAvoidanceDiagnostics_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_VruCollisionAvoidanceDiagnostics_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_VruCollisionAvoidanceDiagnostics(qpb_ostream_t *const stream, const Zenuity_Debug_VruCollisionAvoidanceDiagnostics *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_VruCollisionAvoidanceDiagnostics_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_VruCollisionAvoidanceDiagnostics_highestThreatInfo(stream, &data->highestThreatInfo);
   return true;
}

bool decode_Zenuity_Debug_VruCollisionAvoidanceDiagnostics(qpb_istream_t *const stream, Zenuity_Debug_VruCollisionAvoidanceDiagnostics *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_VruCollisionAvoidanceDiagnostics_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_VruCollisionAvoidanceDiagnostics_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Debug_AebDiagnostics_Raw(qpb_ostream_t *const stream, const Zenuity_Debug_AebDiagnostics_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Debug_AebDiagnostics_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Debug_AebDiagnostics_Raw_allBraking(stream, &data->allBraking);
   encode_Zenuity_Debug_AebDiagnostics_Raw_inhibition(stream, &data->inhibition);
   encode_Zenuity_Debug_AebDiagnostics_Raw_status(stream, &data->status);
   encode_Zenuity_Debug_AebDiagnostics_Raw_primaryTarget(stream, &data->primaryTarget);
   return true;
}

bool decode_Zenuity_Debug_AebDiagnostics_Raw(qpb_istream_t *const stream, Zenuity_Debug_AebDiagnostics_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Debug_AebDiagnostics_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Debug_AebDiagnostics_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

