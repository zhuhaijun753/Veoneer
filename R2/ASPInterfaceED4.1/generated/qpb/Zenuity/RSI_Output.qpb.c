/* Automatically generated qpb constant definitions */
/* Generated by Quick Protocol Buffers - 2 */

#include "Zenuity/RSI_Output.qpb.h"
#include "Tools/QuickProtobuf/qpb_decode.h"
#include "Tools/QuickProtobuf/qpb_encode.h"
#include "Tools/CSupport/ConversionSupport.h"

#if QPB_PROTO_HEADER_VERSION != 2
#error Regenerate this file with the current version of qpb generator.
#endif

#define F_10_0               10.0f

static inline void encode_Zenuity_RSI_RoadSignWarnings_Raw_overspeedWarning(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_RSI_RoadSignWarnings_Raw_overspeedWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RoadSignWarnings_Raw_speedCameraWarning(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_RSI_RoadSignWarnings_Raw_speedCameraWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RoadSignWarnings_Raw_distanceToSpeedCamera(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_Zenuity_RSI_RoadSignWarnings_Raw_distanceToSpeedCamera(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RoadSignWarnings_Raw_noEntryWarning(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_RSI_RoadSignWarnings_Raw_noEntryWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RoadSignWarnings_overspeedWarning(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_RSI_RoadSignWarnings_overspeedWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RoadSignWarnings_speedCameraWarning(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_RSI_RoadSignWarnings_speedCameraWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RoadSignWarnings_distanceToSpeedCamera(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_RSI_RoadSignWarnings_distanceToSpeedCamera(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RoadSignWarnings_noEntryWarning(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_RSI_RoadSignWarnings_noEntryWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RsiDebug_Raw_visionSpeedLimitAvailable(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_RSI_RsiDebug_Raw_visionSpeedLimitAvailable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RsiDebug_Raw_electronicHorizonSpeedLimitAvailable(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_RSI_RsiDebug_Raw_electronicHorizonSpeedLimitAvailable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RsiDebug_Raw_electronicHorizonAndVisionAvailableAndEqual(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_RSI_RsiDebug_Raw_electronicHorizonAndVisionAvailableAndEqual(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RsiDebug_Raw_speedLimitSourceIsOnlyElectronicHorizon(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_RSI_RsiDebug_Raw_speedLimitSourceIsOnlyElectronicHorizon(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_SpeedLimit_Raw_speedUnit(qpb_ostream_t *const stream, const Zenuity_RSI_SpeedUnit *const data);
static bool decode_Zenuity_RSI_SpeedLimit_Raw_speedUnit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_SpeedLimit_Raw_currentSpeedLimit(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_Zenuity_RSI_SpeedLimit_Raw_currentSpeedLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_SpeedLimit_Raw_upcomingSpeedLimit(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_Zenuity_RSI_SpeedLimit_Raw_upcomingSpeedLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_SpeedLimit_Raw_distanceToUpcomingSpeedLimit(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_Zenuity_RSI_SpeedLimit_Raw_distanceToUpcomingSpeedLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RsiOutput_Raw_availability(qpb_ostream_t *const stream, const Zenuity_RSI_RoadSignInformationAvailability *const data);
static bool decode_Zenuity_RSI_RsiOutput_Raw_availability(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RsiOutput_Raw_status(qpb_ostream_t *const stream, const Zenuity_RSI_FunctionStatus *const data);
static bool decode_Zenuity_RSI_RsiOutput_Raw_status(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RsiOutput_Raw_speedLimit(qpb_ostream_t *const stream, const Zenuity_RSI_SpeedLimit_Raw *const data);
static bool decode_Zenuity_RSI_RsiOutput_Raw_speedLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RsiOutput_Raw_warnings(qpb_ostream_t *const stream, const Zenuity_RSI_RoadSignWarnings_Raw *const data);
static bool decode_Zenuity_RSI_RsiOutput_Raw_warnings(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RsiOutput_Raw_arbitratedCountry(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_Zenuity_RSI_RsiOutput_Raw_arbitratedCountry(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RsiOutput_Raw_debug(qpb_ostream_t *const stream, const Zenuity_RSI_RsiDebug_Raw *const data);
static bool decode_Zenuity_RSI_RsiOutput_Raw_debug(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RsiOutput_availability(qpb_ostream_t *const stream, const Zenuity_RSI_RoadSignInformationAvailability *const data);
static bool decode_Zenuity_RSI_RsiOutput_availability(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RsiOutput_status(qpb_ostream_t *const stream, const Zenuity_RSI_FunctionStatus *const data);
static bool decode_Zenuity_RSI_RsiOutput_status(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RsiOutput_speedLimit(qpb_ostream_t *const stream, const Zenuity_RSI_SpeedLimit *const data);
static bool decode_Zenuity_RSI_RsiOutput_speedLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RsiOutput_warnings(qpb_ostream_t *const stream, const Zenuity_RSI_RoadSignWarnings *const data);
static bool decode_Zenuity_RSI_RsiOutput_warnings(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RsiOutput_arbitratedCountry(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_Zenuity_RSI_RsiOutput_arbitratedCountry(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_RSI_RsiOutput_debug(qpb_ostream_t *const stream, const Zenuity_RSI_RsiDebug *const data);
static bool decode_Zenuity_RSI_RsiOutput_debug(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);

#define Zenuity_RSI_RoadSignWarnings_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t Zenuity_RSI_RoadSignWarnings_Raw_decoders[Zenuity_RSI_RoadSignWarnings_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_RSI_RoadSignWarnings_Raw_overspeedWarning },
   { &decode_Zenuity_RSI_RoadSignWarnings_Raw_speedCameraWarning },
   { &decode_Zenuity_RSI_RoadSignWarnings_Raw_distanceToSpeedCamera },
   { &decode_Zenuity_RSI_RoadSignWarnings_Raw_noEntryWarning }
};

#define Zenuity_RSI_RoadSignWarnings_DECODERS_COUNT 5
const qpb_decoder_entry_t Zenuity_RSI_RoadSignWarnings_decoders[Zenuity_RSI_RoadSignWarnings_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_RSI_RoadSignWarnings_overspeedWarning },
   { &decode_Zenuity_RSI_RoadSignWarnings_speedCameraWarning },
   { &decode_Zenuity_RSI_RoadSignWarnings_distanceToSpeedCamera },
   { &decode_Zenuity_RSI_RoadSignWarnings_noEntryWarning }
};

#define Zenuity_RSI_RsiDebug_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t Zenuity_RSI_RsiDebug_Raw_decoders[Zenuity_RSI_RsiDebug_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_RSI_RsiDebug_Raw_visionSpeedLimitAvailable },
   { &decode_Zenuity_RSI_RsiDebug_Raw_electronicHorizonSpeedLimitAvailable },
   { &decode_Zenuity_RSI_RsiDebug_Raw_electronicHorizonAndVisionAvailableAndEqual },
   { &decode_Zenuity_RSI_RsiDebug_Raw_speedLimitSourceIsOnlyElectronicHorizon }
};

#define Zenuity_RSI_SpeedLimit_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t Zenuity_RSI_SpeedLimit_Raw_decoders[Zenuity_RSI_SpeedLimit_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_RSI_SpeedLimit_Raw_speedUnit },
   { &decode_Zenuity_RSI_SpeedLimit_Raw_currentSpeedLimit },
   { &decode_Zenuity_RSI_SpeedLimit_Raw_upcomingSpeedLimit },
   { &decode_Zenuity_RSI_SpeedLimit_Raw_distanceToUpcomingSpeedLimit }
};

#define Zenuity_RSI_RsiOutput_Raw_DECODERS_COUNT 7
const qpb_decoder_entry_t Zenuity_RSI_RsiOutput_Raw_decoders[Zenuity_RSI_RsiOutput_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_RSI_RsiOutput_Raw_availability },
   { &decode_Zenuity_RSI_RsiOutput_Raw_status },
   { &decode_Zenuity_RSI_RsiOutput_Raw_speedLimit },
   { &decode_Zenuity_RSI_RsiOutput_Raw_warnings },
   { &decode_Zenuity_RSI_RsiOutput_Raw_arbitratedCountry },
   { &decode_Zenuity_RSI_RsiOutput_Raw_debug }
};

#define Zenuity_RSI_RsiOutput_DECODERS_COUNT 7
const qpb_decoder_entry_t Zenuity_RSI_RsiOutput_decoders[Zenuity_RSI_RsiOutput_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_RSI_RsiOutput_availability },
   { &decode_Zenuity_RSI_RsiOutput_status },
   { &decode_Zenuity_RSI_RsiOutput_speedLimit },
   { &decode_Zenuity_RSI_RsiOutput_warnings },
   { &decode_Zenuity_RSI_RsiOutput_arbitratedCountry },
   { &decode_Zenuity_RSI_RsiOutput_debug }
};

static inline void encode_Zenuity_RSI_RoadSignWarnings_Raw_overspeedWarning(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_RoadSignWarnings_Raw_overspeedWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_RSI_RoadSignWarnings_Raw*)data)->overspeedWarning, sizeof(bool));
}

static inline void encode_Zenuity_RSI_RoadSignWarnings_Raw_speedCameraWarning(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_RoadSignWarnings_Raw_speedCameraWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_RSI_RoadSignWarnings_Raw*)data)->speedCameraWarning, sizeof(bool));
}

static inline void encode_Zenuity_RSI_RoadSignWarnings_Raw_distanceToSpeedCamera(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_RoadSignWarnings_Raw_distanceToSpeedCamera(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((Zenuity_RSI_RoadSignWarnings_Raw*)data)->distanceToSpeedCamera, sizeof(uint8_t));
}

static inline void encode_Zenuity_RSI_RoadSignWarnings_Raw_noEntryWarning(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_RoadSignWarnings_Raw_noEntryWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_RSI_RoadSignWarnings_Raw*)data)->noEntryWarning, sizeof(bool));
}

static inline void encode_Zenuity_RSI_RoadSignWarnings_overspeedWarning(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_RoadSignWarnings_overspeedWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_RSI_RoadSignWarnings*)data)->overspeedWarning, sizeof(bool));
}

static inline void encode_Zenuity_RSI_RoadSignWarnings_speedCameraWarning(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_RoadSignWarnings_speedCameraWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_RSI_RoadSignWarnings*)data)->speedCameraWarning, sizeof(bool));
}

static inline void encode_Zenuity_RSI_RoadSignWarnings_distanceToSpeedCamera(qpb_ostream_t *const stream, const float *const data)
{
   uint8_t value = (uint8_t)convertToUint32(*data, F_10_0, 0, UINT8_MAX);
   encode_Zenuity_RSI_RoadSignWarnings_Raw_distanceToSpeedCamera(stream, &value);
}

static bool decode_Zenuity_RSI_RoadSignWarnings_distanceToSpeedCamera(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint8_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint8_t));
   ((Zenuity_RSI_RoadSignWarnings*)data)->distanceToSpeedCamera = value * F_10_0;
   return result;
}

static inline void encode_Zenuity_RSI_RoadSignWarnings_noEntryWarning(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_RoadSignWarnings_noEntryWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_RSI_RoadSignWarnings*)data)->noEntryWarning, sizeof(bool));
}

static inline void encode_Zenuity_RSI_RsiDebug_Raw_visionSpeedLimitAvailable(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_RsiDebug_Raw_visionSpeedLimitAvailable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_RSI_RsiDebug_Raw*)data)->visionSpeedLimitAvailable, sizeof(bool));
}

static inline void encode_Zenuity_RSI_RsiDebug_Raw_electronicHorizonSpeedLimitAvailable(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_RsiDebug_Raw_electronicHorizonSpeedLimitAvailable(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_RSI_RsiDebug_Raw*)data)->electronicHorizonSpeedLimitAvailable, sizeof(bool));
}

static inline void encode_Zenuity_RSI_RsiDebug_Raw_electronicHorizonAndVisionAvailableAndEqual(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_RsiDebug_Raw_electronicHorizonAndVisionAvailableAndEqual(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_RSI_RsiDebug_Raw*)data)->electronicHorizonAndVisionAvailableAndEqual, sizeof(bool));
}

static inline void encode_Zenuity_RSI_RsiDebug_Raw_speedLimitSourceIsOnlyElectronicHorizon(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_RsiDebug_Raw_speedLimitSourceIsOnlyElectronicHorizon(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_RSI_RsiDebug_Raw*)data)->speedLimitSourceIsOnlyElectronicHorizon, sizeof(bool));
}

static inline void encode_Zenuity_RSI_SpeedLimit_Raw_speedUnit(qpb_ostream_t *const stream, const Zenuity_RSI_SpeedUnit *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_SpeedLimit_Raw_speedUnit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_RSI_SpeedLimit_Raw*)data)->speedUnit, qpb_membersize(Zenuity_RSI_SpeedLimit_Raw, speedUnit));
}

static inline void encode_Zenuity_RSI_SpeedLimit_Raw_currentSpeedLimit(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_SpeedLimit_Raw_currentSpeedLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((Zenuity_RSI_SpeedLimit_Raw*)data)->currentSpeedLimit, sizeof(uint8_t));
}

static inline void encode_Zenuity_RSI_SpeedLimit_Raw_upcomingSpeedLimit(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_SpeedLimit_Raw_upcomingSpeedLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((Zenuity_RSI_SpeedLimit_Raw*)data)->upcomingSpeedLimit, sizeof(uint8_t));
}

static inline void encode_Zenuity_RSI_SpeedLimit_Raw_distanceToUpcomingSpeedLimit(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_SpeedLimit_Raw_distanceToUpcomingSpeedLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((Zenuity_RSI_SpeedLimit_Raw*)data)->distanceToUpcomingSpeedLimit, sizeof(uint32_t));
}

static inline void encode_Zenuity_RSI_RsiOutput_Raw_availability(qpb_ostream_t *const stream, const Zenuity_RSI_RoadSignInformationAvailability *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_RsiOutput_Raw_availability(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_RSI_RsiOutput_Raw*)data)->availability, qpb_membersize(Zenuity_RSI_RsiOutput_Raw, availability));
}

static inline void encode_Zenuity_RSI_RsiOutput_Raw_status(qpb_ostream_t *const stream, const Zenuity_RSI_FunctionStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_RsiOutput_Raw_status(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_RSI_RsiOutput_Raw*)data)->status, qpb_membersize(Zenuity_RSI_RsiOutput_Raw, status));
}

static inline void encode_Zenuity_RSI_RsiOutput_Raw_speedLimit(qpb_ostream_t *const stream, const Zenuity_RSI_SpeedLimit_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_RSI_SpeedLimit_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_RSI_RsiOutput_Raw_speedLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_RSI_SpeedLimit_Raw(&substream, &((Zenuity_RSI_RsiOutput_Raw*)data)->speedLimit);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_RSI_RsiOutput_Raw_warnings(qpb_ostream_t *const stream, const Zenuity_RSI_RoadSignWarnings_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_RSI_RoadSignWarnings_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_RSI_RsiOutput_Raw_warnings(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_RSI_RoadSignWarnings_Raw(&substream, &((Zenuity_RSI_RsiOutput_Raw*)data)->warnings);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_RSI_RsiOutput_Raw_arbitratedCountry(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_RsiOutput_Raw_arbitratedCountry(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((Zenuity_RSI_RsiOutput_Raw*)data)->arbitratedCountry, sizeof(uint16_t));
}

static inline void encode_Zenuity_RSI_RsiOutput_Raw_debug(qpb_ostream_t *const stream, const Zenuity_RSI_RsiDebug_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 50;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_RSI_RsiDebug_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_RSI_RsiOutput_Raw_debug(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_RSI_RsiDebug_Raw(&substream, &((Zenuity_RSI_RsiOutput_Raw*)data)->debug);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_RSI_RsiOutput_availability(qpb_ostream_t *const stream, const Zenuity_RSI_RoadSignInformationAvailability *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_RsiOutput_availability(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_RSI_RsiOutput*)data)->availability, qpb_membersize(Zenuity_RSI_RsiOutput, availability));
}

static inline void encode_Zenuity_RSI_RsiOutput_status(qpb_ostream_t *const stream, const Zenuity_RSI_FunctionStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_RsiOutput_status(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_RSI_RsiOutput*)data)->status, qpb_membersize(Zenuity_RSI_RsiOutput, status));
}

static inline void encode_Zenuity_RSI_RsiOutput_speedLimit(qpb_ostream_t *const stream, const Zenuity_RSI_SpeedLimit *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_RSI_SpeedLimit(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_RSI_RsiOutput_speedLimit(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_RSI_SpeedLimit(&substream, &((Zenuity_RSI_RsiOutput*)data)->speedLimit);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_RSI_RsiOutput_warnings(qpb_ostream_t *const stream, const Zenuity_RSI_RoadSignWarnings *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_RSI_RoadSignWarnings(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_RSI_RsiOutput_warnings(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_RSI_RoadSignWarnings(&substream, &((Zenuity_RSI_RsiOutput*)data)->warnings);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_RSI_RsiOutput_arbitratedCountry(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_Zenuity_RSI_RsiOutput_arbitratedCountry(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((Zenuity_RSI_RsiOutput*)data)->arbitratedCountry, sizeof(uint16_t));
}

static inline void encode_Zenuity_RSI_RsiOutput_debug(qpb_ostream_t *const stream, const Zenuity_RSI_RsiDebug *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 50;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_RSI_RsiDebug(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_RSI_RsiOutput_debug(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_RSI_RsiDebug(&substream, &((Zenuity_RSI_RsiOutput*)data)->debug);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

/* Encoding / decoding functions */
bool encode_Zenuity_RSI_RoadSignWarnings_Raw(qpb_ostream_t *const stream, const Zenuity_RSI_RoadSignWarnings_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_RSI_RoadSignWarnings_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_RSI_RoadSignWarnings_Raw_overspeedWarning(stream, &data->overspeedWarning);
   encode_Zenuity_RSI_RoadSignWarnings_Raw_speedCameraWarning(stream, &data->speedCameraWarning);
   encode_Zenuity_RSI_RoadSignWarnings_Raw_distanceToSpeedCamera(stream, &data->distanceToSpeedCamera);
   encode_Zenuity_RSI_RoadSignWarnings_Raw_noEntryWarning(stream, &data->noEntryWarning);
   return true;
}

bool decode_Zenuity_RSI_RoadSignWarnings_Raw(qpb_istream_t *const stream, Zenuity_RSI_RoadSignWarnings_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_RSI_RoadSignWarnings_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_RSI_RoadSignWarnings_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_RSI_RoadSignWarnings(qpb_ostream_t *const stream, const Zenuity_RSI_RoadSignWarnings *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_RSI_RoadSignWarnings_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_RSI_RoadSignWarnings_Raw_overspeedWarning(stream, &data->overspeedWarning);
   encode_Zenuity_RSI_RoadSignWarnings_Raw_speedCameraWarning(stream, &data->speedCameraWarning);
   encode_Zenuity_RSI_RoadSignWarnings_distanceToSpeedCamera(stream, &data->distanceToSpeedCamera);
   encode_Zenuity_RSI_RoadSignWarnings_Raw_noEntryWarning(stream, &data->noEntryWarning);
   return true;
}

bool decode_Zenuity_RSI_RoadSignWarnings(qpb_istream_t *const stream, Zenuity_RSI_RoadSignWarnings *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_RSI_RoadSignWarnings_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_RSI_RoadSignWarnings_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_RSI_RsiDebug_Raw(qpb_ostream_t *const stream, const Zenuity_RSI_RsiDebug_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_RSI_RsiDebug_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_RSI_RsiDebug_Raw_visionSpeedLimitAvailable(stream, &data->visionSpeedLimitAvailable);
   encode_Zenuity_RSI_RsiDebug_Raw_electronicHorizonSpeedLimitAvailable(stream, &data->electronicHorizonSpeedLimitAvailable);
   encode_Zenuity_RSI_RsiDebug_Raw_electronicHorizonAndVisionAvailableAndEqual(stream, &data->electronicHorizonAndVisionAvailableAndEqual);
   encode_Zenuity_RSI_RsiDebug_Raw_speedLimitSourceIsOnlyElectronicHorizon(stream, &data->speedLimitSourceIsOnlyElectronicHorizon);
   return true;
}

bool decode_Zenuity_RSI_RsiDebug_Raw(qpb_istream_t *const stream, Zenuity_RSI_RsiDebug_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_RSI_RsiDebug_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_RSI_RsiDebug_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_RSI_SpeedLimit_Raw(qpb_ostream_t *const stream, const Zenuity_RSI_SpeedLimit_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_RSI_SpeedLimit_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_RSI_SpeedLimit_Raw_speedUnit(stream, &data->speedUnit);
   encode_Zenuity_RSI_SpeedLimit_Raw_currentSpeedLimit(stream, &data->currentSpeedLimit);
   encode_Zenuity_RSI_SpeedLimit_Raw_upcomingSpeedLimit(stream, &data->upcomingSpeedLimit);
   encode_Zenuity_RSI_SpeedLimit_Raw_distanceToUpcomingSpeedLimit(stream, &data->distanceToUpcomingSpeedLimit);
   return true;
}

bool decode_Zenuity_RSI_SpeedLimit_Raw(qpb_istream_t *const stream, Zenuity_RSI_SpeedLimit_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_RSI_SpeedLimit_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_RSI_SpeedLimit_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_RSI_RsiOutput_Raw(qpb_ostream_t *const stream, const Zenuity_RSI_RsiOutput_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_RSI_RsiOutput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_RSI_RsiOutput_Raw_availability(stream, &data->availability);
   encode_Zenuity_RSI_RsiOutput_Raw_status(stream, &data->status);
   encode_Zenuity_RSI_RsiOutput_Raw_speedLimit(stream, &data->speedLimit);
   encode_Zenuity_RSI_RsiOutput_Raw_warnings(stream, &data->warnings);
   encode_Zenuity_RSI_RsiOutput_Raw_arbitratedCountry(stream, &data->arbitratedCountry);
   encode_Zenuity_RSI_RsiOutput_Raw_debug(stream, &data->debug);
   return true;
}

bool decode_Zenuity_RSI_RsiOutput_Raw(qpb_istream_t *const stream, Zenuity_RSI_RsiOutput_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_RSI_RsiOutput_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_RSI_RsiOutput_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_RSI_RsiOutput(qpb_ostream_t *const stream, const Zenuity_RSI_RsiOutput *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_RSI_RsiOutput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_RSI_RsiOutput_Raw_availability(stream, &data->availability);
   encode_Zenuity_RSI_RsiOutput_Raw_status(stream, &data->status);
   encode_Zenuity_RSI_RsiOutput_speedLimit(stream, &data->speedLimit);
   encode_Zenuity_RSI_RsiOutput_warnings(stream, &data->warnings);
   encode_Zenuity_RSI_RsiOutput_Raw_arbitratedCountry(stream, &data->arbitratedCountry);
   encode_Zenuity_RSI_RsiOutput_debug(stream, &data->debug);
   return true;
}

bool decode_Zenuity_RSI_RsiOutput(qpb_istream_t *const stream, Zenuity_RSI_RsiOutput *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_RSI_RsiOutput_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_RSI_RsiOutput_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

