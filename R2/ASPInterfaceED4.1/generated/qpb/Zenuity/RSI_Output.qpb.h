/* Automatically generated qpb header */
/* SPP version 2.0.0 */
/* Generated by Quick Protocol Buffers - 2 */

#ifndef ZENUITY_RSI_OUTPUT_INCLUDED
#define ZENUITY_RSI_OUTPUT_INCLUDED

#include "Zenuity/RSI_Output_types.qpb.h"


#include "Tools/QuickProtobuf/qpb.h"

#if QPB_PROTO_HEADER_VERSION != 2
#error Regenerate this file with the current version of qpb generator.
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Maximum encoded size of messages (where known) */
#define Zenuity_RSI_RoadSignWarnings_size                                                (9)
#define Zenuity_RSI_RsiDebug_size                                                        (8)
#define Zenuity_RSI_SpeedLimit_size                                                      (14)
#define Zenuity_RSI_RsiOutput_size                                                       ((14 + Zenuity_RSI_SpeedLimit_size + Zenuity_RSI_RoadSignWarnings_size + Zenuity_RSI_RsiDebug_size) + QPB_VARINT_MAX_ENCODED_SIZE)

/* Message IDs (where set with "identifier" option) */
#define Zenuity_RSI_RsiOutput_source                                                     1U
#define Zenuity_RSI_RsiOutput_identifier                                                 40U
#define Zenuity_RSI_RsiOutput_majorVersion                                               1U
#define Zenuity_RSI_RsiOutput_minorVersion                                               0U

/* Encoding / decoding functions
 * Returns true on success, false on any failure.
 * Notes on Decode:
 * User is expected to provide a struct with wanted/default values (all zeroes).
 * A case where default values are not wanted is if you want to merge two messages
 * i.e. update only the fields that exist in the new message.
 * Note: These functions supports NULL termination of messages which most other
 *       protobuf implementations do not just so you know
 */
bool encode_Zenuity_RSI_RoadSignWarnings_Raw(qpb_ostream_t *const stream, const Zenuity_RSI_RoadSignWarnings_Raw *const data);
bool decode_Zenuity_RSI_RoadSignWarnings_Raw(qpb_istream_t *const stream, Zenuity_RSI_RoadSignWarnings_Raw *const data);
bool encode_Zenuity_RSI_RoadSignWarnings(qpb_ostream_t *const stream, const Zenuity_RSI_RoadSignWarnings *const data);
bool decode_Zenuity_RSI_RoadSignWarnings(qpb_istream_t *const stream, Zenuity_RSI_RoadSignWarnings *const data);

bool encode_Zenuity_RSI_RsiDebug_Raw(qpb_ostream_t *const stream, const Zenuity_RSI_RsiDebug_Raw *const data);
bool decode_Zenuity_RSI_RsiDebug_Raw(qpb_istream_t *const stream, Zenuity_RSI_RsiDebug_Raw *const data);
#define encode_Zenuity_RSI_RsiDebug encode_Zenuity_RSI_RsiDebug_Raw
#define decode_Zenuity_RSI_RsiDebug decode_Zenuity_RSI_RsiDebug_Raw

bool encode_Zenuity_RSI_SpeedLimit_Raw(qpb_ostream_t *const stream, const Zenuity_RSI_SpeedLimit_Raw *const data);
bool decode_Zenuity_RSI_SpeedLimit_Raw(qpb_istream_t *const stream, Zenuity_RSI_SpeedLimit_Raw *const data);
#define encode_Zenuity_RSI_SpeedLimit encode_Zenuity_RSI_SpeedLimit_Raw
#define decode_Zenuity_RSI_SpeedLimit decode_Zenuity_RSI_SpeedLimit_Raw

bool encode_Zenuity_RSI_RsiOutput_Raw(qpb_ostream_t *const stream, const Zenuity_RSI_RsiOutput_Raw *const data);
bool decode_Zenuity_RSI_RsiOutput_Raw(qpb_istream_t *const stream, Zenuity_RSI_RsiOutput_Raw *const data);
bool encode_Zenuity_RSI_RsiOutput(qpb_ostream_t *const stream, const Zenuity_RSI_RsiOutput *const data);
bool decode_Zenuity_RSI_RsiOutput(qpb_istream_t *const stream, Zenuity_RSI_RsiOutput *const data);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* ZENUITY_RSI_OUTPUT_INCLUDED */
