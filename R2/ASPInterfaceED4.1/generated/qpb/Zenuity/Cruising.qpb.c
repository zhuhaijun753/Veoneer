/* Automatically generated qpb constant definitions */
/* Generated by Quick Protocol Buffers - 2 */

#include "Zenuity/Cruising.qpb.h"
#include "Tools/QuickProtobuf/qpb_decode.h"
#include "Tools/QuickProtobuf/qpb_encode.h"
#include "Tools/CSupport/ConversionSupport.h"

#if QPB_PROTO_HEADER_VERSION != 2
#error Regenerate this file with the current version of qpb generator.
#endif

#define F_0_01               0.01f
#define F_0_1                0.1f

static inline void encode_Zenuity_Crusing_AccelerationRequest_Raw_requestActive(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Crusing_AccelerationRequest_Raw_requestActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_AccelerationRequest_Raw_nominalAcceleration(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_Zenuity_Crusing_AccelerationRequest_Raw_nominalAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_AccelerationRequest_Raw_minJerk(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_Zenuity_Crusing_AccelerationRequest_Raw_minJerk(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_AccelerationRequest_Raw_maxJerk(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_Zenuity_Crusing_AccelerationRequest_Raw_maxJerk(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_AccelerationRequest_Raw_standstillRequest(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Crusing_AccelerationRequest_Raw_standstillRequest(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_AccelerationRequest_requestActive(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Crusing_AccelerationRequest_requestActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_AccelerationRequest_nominalAcceleration(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Crusing_AccelerationRequest_nominalAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_AccelerationRequest_minJerk(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Crusing_AccelerationRequest_minJerk(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_AccelerationRequest_maxJerk(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Crusing_AccelerationRequest_maxJerk(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_AccelerationRequest_standstillRequest(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Crusing_AccelerationRequest_standstillRequest(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_CancelReasonAcc_Raw_noLeadVehicle(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Crusing_CancelReasonAcc_Raw_noLeadVehicle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_CancelReasonAcc_Raw_endBrakeOnly(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Crusing_CancelReasonAcc_Raw_endBrakeOnly(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_handsOffWarning(qpb_ostream_t *const stream, const Zenuity_Crusing_HandsOffWarning *const data);
static bool decode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_handsOffWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeType(qpb_ostream_t *const stream, const Zenuity_Crusing_LaneChangeType *const data);
static bool decode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeReason(qpb_ostream_t *const stream, const Zenuity_Crusing_LaneChangeReason *const data);
static bool decode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeReason(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangePossibleDirection(qpb_ostream_t *const stream, const Zenuity_Crusing_LaneChangePossibleDirection *const data);
static bool decode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangePossibleDirection(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeStatus(qpb_ostream_t *const stream, const Zenuity_Crusing_LaneChangeStatus *const data);
static bool decode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_SelectedTarget_Raw_isSelected(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Crusing_SelectedTarget_Raw_isSelected(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_SelectedTarget_Raw_isControlledTowards(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Crusing_SelectedTarget_Raw_isControlledTowards(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_SelectedTarget_Raw_latPosition(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_Zenuity_Crusing_SelectedTarget_Raw_latPosition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_SelectedTarget_Raw_lonPosition(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_Zenuity_Crusing_SelectedTarget_Raw_lonPosition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_SelectedTarget_Raw_speed(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_Zenuity_Crusing_SelectedTarget_Raw_speed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_SelectedTarget_isSelected(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Crusing_SelectedTarget_isSelected(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_SelectedTarget_isControlledTowards(qpb_ostream_t *const stream, const bool *const data);
static bool decode_Zenuity_Crusing_SelectedTarget_isControlledTowards(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_SelectedTarget_latPosition(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Crusing_SelectedTarget_latPosition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_SelectedTarget_lonPosition(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Crusing_SelectedTarget_lonPosition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_SelectedTarget_speed(qpb_ostream_t *const stream, const float *const data);
static bool decode_Zenuity_Crusing_SelectedTarget_speed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_TrafficAssistOutput_Raw_turnIndicatorRequest(qpb_ostream_t *const stream, const Zenuity_Crusing_TurnIndicatorRequest *const data);
static bool decode_Zenuity_Crusing_TrafficAssistOutput_Raw_turnIndicatorRequest(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInLane(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget_Raw *const data);
static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_secondClosestInLane(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget_Raw *const data);
static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_secondClosestInLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_cutIn(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget_Raw *const data);
static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_cutIn(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInLeftLane(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget_Raw *const data);
static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInLeftLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInRightLane(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget_Raw *const data);
static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInRightLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_closestInLane(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget *const data);
static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_closestInLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_secondClosestInLane(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget *const data);
static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_secondClosestInLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_cutIn(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget *const data);
static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_cutIn(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_closestInLeftLane(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget *const data);
static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_closestInLeftLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_closestInRightLane(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget *const data);
static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_closestInRightLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);

#define Zenuity_Crusing_AccelerationRequest_Raw_DECODERS_COUNT 6
const qpb_decoder_entry_t Zenuity_Crusing_AccelerationRequest_Raw_decoders[Zenuity_Crusing_AccelerationRequest_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Crusing_AccelerationRequest_Raw_requestActive },
   { &decode_Zenuity_Crusing_AccelerationRequest_Raw_nominalAcceleration },
   { &decode_Zenuity_Crusing_AccelerationRequest_Raw_minJerk },
   { &decode_Zenuity_Crusing_AccelerationRequest_Raw_maxJerk },
   { &decode_Zenuity_Crusing_AccelerationRequest_Raw_standstillRequest }
};

#define Zenuity_Crusing_AccelerationRequest_DECODERS_COUNT 6
const qpb_decoder_entry_t Zenuity_Crusing_AccelerationRequest_decoders[Zenuity_Crusing_AccelerationRequest_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Crusing_AccelerationRequest_requestActive },
   { &decode_Zenuity_Crusing_AccelerationRequest_nominalAcceleration },
   { &decode_Zenuity_Crusing_AccelerationRequest_minJerk },
   { &decode_Zenuity_Crusing_AccelerationRequest_maxJerk },
   { &decode_Zenuity_Crusing_AccelerationRequest_standstillRequest }
};

#define Zenuity_Crusing_CancelReasonAcc_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t Zenuity_Crusing_CancelReasonAcc_Raw_decoders[Zenuity_Crusing_CancelReasonAcc_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Crusing_CancelReasonAcc_Raw_noLeadVehicle },
   { &decode_Zenuity_Crusing_CancelReasonAcc_Raw_endBrakeOnly }
};

#define Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_DECODERS_COUNT 6
const qpb_decoder_entry_t Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_decoders[Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_handsOffWarning },
   { &decode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeType },
   { &decode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeReason },
   { &decode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangePossibleDirection },
   { &decode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeStatus }
};

#define Zenuity_Crusing_SelectedTarget_Raw_DECODERS_COUNT 6
const qpb_decoder_entry_t Zenuity_Crusing_SelectedTarget_Raw_decoders[Zenuity_Crusing_SelectedTarget_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Crusing_SelectedTarget_Raw_isSelected },
   { &decode_Zenuity_Crusing_SelectedTarget_Raw_isControlledTowards },
   { &decode_Zenuity_Crusing_SelectedTarget_Raw_latPosition },
   { &decode_Zenuity_Crusing_SelectedTarget_Raw_lonPosition },
   { &decode_Zenuity_Crusing_SelectedTarget_Raw_speed }
};

#define Zenuity_Crusing_SelectedTarget_DECODERS_COUNT 6
const qpb_decoder_entry_t Zenuity_Crusing_SelectedTarget_decoders[Zenuity_Crusing_SelectedTarget_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Crusing_SelectedTarget_isSelected },
   { &decode_Zenuity_Crusing_SelectedTarget_isControlledTowards },
   { &decode_Zenuity_Crusing_SelectedTarget_latPosition },
   { &decode_Zenuity_Crusing_SelectedTarget_lonPosition },
   { &decode_Zenuity_Crusing_SelectedTarget_speed }
};

#define Zenuity_Crusing_TrafficAssistOutput_Raw_DECODERS_COUNT 2
const qpb_decoder_entry_t Zenuity_Crusing_TrafficAssistOutput_Raw_decoders[Zenuity_Crusing_TrafficAssistOutput_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Crusing_TrafficAssistOutput_Raw_turnIndicatorRequest }
};

#define Zenuity_Crusing_TargetsSelectedByAcc_Raw_DECODERS_COUNT 6
const qpb_decoder_entry_t Zenuity_Crusing_TargetsSelectedByAcc_Raw_decoders[Zenuity_Crusing_TargetsSelectedByAcc_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInLane },
   { &decode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_secondClosestInLane },
   { &decode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_cutIn },
   { &decode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInLeftLane },
   { &decode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInRightLane }
};

#define Zenuity_Crusing_TargetsSelectedByAcc_DECODERS_COUNT 6
const qpb_decoder_entry_t Zenuity_Crusing_TargetsSelectedByAcc_decoders[Zenuity_Crusing_TargetsSelectedByAcc_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_Zenuity_Crusing_TargetsSelectedByAcc_closestInLane },
   { &decode_Zenuity_Crusing_TargetsSelectedByAcc_secondClosestInLane },
   { &decode_Zenuity_Crusing_TargetsSelectedByAcc_cutIn },
   { &decode_Zenuity_Crusing_TargetsSelectedByAcc_closestInLeftLane },
   { &decode_Zenuity_Crusing_TargetsSelectedByAcc_closestInRightLane }
};

static inline void encode_Zenuity_Crusing_AccelerationRequest_Raw_requestActive(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_AccelerationRequest_Raw_requestActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Crusing_AccelerationRequest_Raw*)data)->requestActive, sizeof(bool));
}

static inline void encode_Zenuity_Crusing_AccelerationRequest_Raw_nominalAcceleration(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_AccelerationRequest_Raw_nominalAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((Zenuity_Crusing_AccelerationRequest_Raw*)data)->nominalAcceleration, sizeof(int16_t));
}

static inline void encode_Zenuity_Crusing_AccelerationRequest_Raw_minJerk(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_AccelerationRequest_Raw_minJerk(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((Zenuity_Crusing_AccelerationRequest_Raw*)data)->minJerk, sizeof(int16_t));
}

static inline void encode_Zenuity_Crusing_AccelerationRequest_Raw_maxJerk(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_AccelerationRequest_Raw_maxJerk(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((Zenuity_Crusing_AccelerationRequest_Raw*)data)->maxJerk, sizeof(int16_t));
}

static inline void encode_Zenuity_Crusing_AccelerationRequest_Raw_standstillRequest(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_AccelerationRequest_Raw_standstillRequest(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Crusing_AccelerationRequest_Raw*)data)->standstillRequest, sizeof(bool));
}

static inline void encode_Zenuity_Crusing_AccelerationRequest_requestActive(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_AccelerationRequest_requestActive(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Crusing_AccelerationRequest*)data)->requestActive, sizeof(bool));
}

static inline void encode_Zenuity_Crusing_AccelerationRequest_nominalAcceleration(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_Zenuity_Crusing_AccelerationRequest_Raw_nominalAcceleration(stream, &value);
}

static bool decode_Zenuity_Crusing_AccelerationRequest_nominalAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((Zenuity_Crusing_AccelerationRequest*)data)->nominalAcceleration = value * F_0_01;
   return result;
}

static inline void encode_Zenuity_Crusing_AccelerationRequest_minJerk(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_Zenuity_Crusing_AccelerationRequest_Raw_minJerk(stream, &value);
}

static bool decode_Zenuity_Crusing_AccelerationRequest_minJerk(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((Zenuity_Crusing_AccelerationRequest*)data)->minJerk = value * F_0_01;
   return result;
}

static inline void encode_Zenuity_Crusing_AccelerationRequest_maxJerk(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_01, INT16_MIN, INT16_MAX);
   encode_Zenuity_Crusing_AccelerationRequest_Raw_maxJerk(stream, &value);
}

static bool decode_Zenuity_Crusing_AccelerationRequest_maxJerk(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((Zenuity_Crusing_AccelerationRequest*)data)->maxJerk = value * F_0_01;
   return result;
}

static inline void encode_Zenuity_Crusing_AccelerationRequest_standstillRequest(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_AccelerationRequest_standstillRequest(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Crusing_AccelerationRequest*)data)->standstillRequest, sizeof(bool));
}

static inline void encode_Zenuity_Crusing_CancelReasonAcc_Raw_noLeadVehicle(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_CancelReasonAcc_Raw_noLeadVehicle(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Crusing_CancelReasonAcc_Raw*)data)->noLeadVehicle, sizeof(bool));
}

static inline void encode_Zenuity_Crusing_CancelReasonAcc_Raw_endBrakeOnly(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_CancelReasonAcc_Raw_endBrakeOnly(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Crusing_CancelReasonAcc_Raw*)data)->endBrakeOnly, sizeof(bool));
}

static inline void encode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_handsOffWarning(qpb_ostream_t *const stream, const Zenuity_Crusing_HandsOffWarning *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_handsOffWarning(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw*)data)->handsOffWarning, qpb_membersize(Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw, handsOffWarning));
}

static inline void encode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeType(qpb_ostream_t *const stream, const Zenuity_Crusing_LaneChangeType *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeType(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw*)data)->laneChangeType, qpb_membersize(Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw, laneChangeType));
}

static inline void encode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeReason(qpb_ostream_t *const stream, const Zenuity_Crusing_LaneChangeReason *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeReason(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw*)data)->laneChangeReason, qpb_membersize(Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw, laneChangeReason));
}

static inline void encode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangePossibleDirection(qpb_ostream_t *const stream, const Zenuity_Crusing_LaneChangePossibleDirection *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangePossibleDirection(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw*)data)->laneChangePossibleDirection, qpb_membersize(Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw, laneChangePossibleDirection));
}

static inline void encode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeStatus(qpb_ostream_t *const stream, const Zenuity_Crusing_LaneChangeStatus *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeStatus(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw*)data)->laneChangeStatus, qpb_membersize(Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw, laneChangeStatus));
}

static inline void encode_Zenuity_Crusing_SelectedTarget_Raw_isSelected(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_SelectedTarget_Raw_isSelected(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Crusing_SelectedTarget_Raw*)data)->isSelected, sizeof(bool));
}

static inline void encode_Zenuity_Crusing_SelectedTarget_Raw_isControlledTowards(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_SelectedTarget_Raw_isControlledTowards(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Crusing_SelectedTarget_Raw*)data)->isControlledTowards, sizeof(bool));
}

static inline void encode_Zenuity_Crusing_SelectedTarget_Raw_latPosition(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_SelectedTarget_Raw_latPosition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((Zenuity_Crusing_SelectedTarget_Raw*)data)->latPosition, sizeof(int16_t));
}

static inline void encode_Zenuity_Crusing_SelectedTarget_Raw_lonPosition(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_SelectedTarget_Raw_lonPosition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((Zenuity_Crusing_SelectedTarget_Raw*)data)->lonPosition, sizeof(int16_t));
}

static inline void encode_Zenuity_Crusing_SelectedTarget_Raw_speed(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_SelectedTarget_Raw_speed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((Zenuity_Crusing_SelectedTarget_Raw*)data)->speed, sizeof(int16_t));
}

static inline void encode_Zenuity_Crusing_SelectedTarget_isSelected(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_SelectedTarget_isSelected(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Crusing_SelectedTarget*)data)->isSelected, sizeof(bool));
}

static inline void encode_Zenuity_Crusing_SelectedTarget_isControlledTowards(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_SelectedTarget_isControlledTowards(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Crusing_SelectedTarget*)data)->isControlledTowards, sizeof(bool));
}

static inline void encode_Zenuity_Crusing_SelectedTarget_latPosition(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_1, INT16_MIN, INT16_MAX);
   encode_Zenuity_Crusing_SelectedTarget_Raw_latPosition(stream, &value);
}

static bool decode_Zenuity_Crusing_SelectedTarget_latPosition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((Zenuity_Crusing_SelectedTarget*)data)->latPosition = value * F_0_1;
   return result;
}

static inline void encode_Zenuity_Crusing_SelectedTarget_lonPosition(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_1, INT16_MIN, INT16_MAX);
   encode_Zenuity_Crusing_SelectedTarget_Raw_lonPosition(stream, &value);
}

static bool decode_Zenuity_Crusing_SelectedTarget_lonPosition(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((Zenuity_Crusing_SelectedTarget*)data)->lonPosition = value * F_0_1;
   return result;
}

static inline void encode_Zenuity_Crusing_SelectedTarget_speed(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_1, INT16_MIN, INT16_MAX);
   encode_Zenuity_Crusing_SelectedTarget_Raw_speed(stream, &value);
}

static bool decode_Zenuity_Crusing_SelectedTarget_speed(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((Zenuity_Crusing_SelectedTarget*)data)->speed = value * F_0_1;
   return result;
}

static inline void encode_Zenuity_Crusing_TrafficAssistOutput_Raw_turnIndicatorRequest(qpb_ostream_t *const stream, const Zenuity_Crusing_TurnIndicatorRequest *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_Zenuity_Crusing_TrafficAssistOutput_Raw_turnIndicatorRequest(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((Zenuity_Crusing_TrafficAssistOutput_Raw*)data)->turnIndicatorRequest, qpb_membersize(Zenuity_Crusing_TrafficAssistOutput_Raw, turnIndicatorRequest));
}

static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInLane(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Crusing_SelectedTarget_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Crusing_SelectedTarget_Raw(&substream, &((Zenuity_Crusing_TargetsSelectedByAcc_Raw*)data)->closestInLane);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_secondClosestInLane(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Crusing_SelectedTarget_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_secondClosestInLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Crusing_SelectedTarget_Raw(&substream, &((Zenuity_Crusing_TargetsSelectedByAcc_Raw*)data)->secondClosestInLane);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_cutIn(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Crusing_SelectedTarget_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_cutIn(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Crusing_SelectedTarget_Raw(&substream, &((Zenuity_Crusing_TargetsSelectedByAcc_Raw*)data)->cutIn);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInLeftLane(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Crusing_SelectedTarget_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInLeftLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Crusing_SelectedTarget_Raw(&substream, &((Zenuity_Crusing_TargetsSelectedByAcc_Raw*)data)->closestInLeftLane);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInRightLane(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 42;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Crusing_SelectedTarget_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInRightLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Crusing_SelectedTarget_Raw(&substream, &((Zenuity_Crusing_TargetsSelectedByAcc_Raw*)data)->closestInRightLane);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_closestInLane(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Crusing_SelectedTarget(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_closestInLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Crusing_SelectedTarget(&substream, &((Zenuity_Crusing_TargetsSelectedByAcc*)data)->closestInLane);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_secondClosestInLane(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Crusing_SelectedTarget(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_secondClosestInLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Crusing_SelectedTarget(&substream, &((Zenuity_Crusing_TargetsSelectedByAcc*)data)->secondClosestInLane);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_cutIn(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Crusing_SelectedTarget(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_cutIn(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Crusing_SelectedTarget(&substream, &((Zenuity_Crusing_TargetsSelectedByAcc*)data)->cutIn);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_closestInLeftLane(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Crusing_SelectedTarget(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_closestInLeftLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Crusing_SelectedTarget(&substream, &((Zenuity_Crusing_TargetsSelectedByAcc*)data)->closestInLeftLane);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_Zenuity_Crusing_TargetsSelectedByAcc_closestInRightLane(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 42;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_Zenuity_Crusing_SelectedTarget(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_Zenuity_Crusing_TargetsSelectedByAcc_closestInRightLane(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_Zenuity_Crusing_SelectedTarget(&substream, &((Zenuity_Crusing_TargetsSelectedByAcc*)data)->closestInRightLane);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

/* Encoding / decoding functions */
bool encode_Zenuity_Crusing_AccelerationRequest_Raw(qpb_ostream_t *const stream, const Zenuity_Crusing_AccelerationRequest_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Crusing_AccelerationRequest_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Crusing_AccelerationRequest_Raw_requestActive(stream, &data->requestActive);
   encode_Zenuity_Crusing_AccelerationRequest_Raw_nominalAcceleration(stream, &data->nominalAcceleration);
   encode_Zenuity_Crusing_AccelerationRequest_Raw_minJerk(stream, &data->minJerk);
   encode_Zenuity_Crusing_AccelerationRequest_Raw_maxJerk(stream, &data->maxJerk);
   encode_Zenuity_Crusing_AccelerationRequest_Raw_standstillRequest(stream, &data->standstillRequest);
   return true;
}

bool decode_Zenuity_Crusing_AccelerationRequest_Raw(qpb_istream_t *const stream, Zenuity_Crusing_AccelerationRequest_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Crusing_AccelerationRequest_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Crusing_AccelerationRequest_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Crusing_AccelerationRequest(qpb_ostream_t *const stream, const Zenuity_Crusing_AccelerationRequest *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Crusing_AccelerationRequest_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Crusing_AccelerationRequest_Raw_requestActive(stream, &data->requestActive);
   encode_Zenuity_Crusing_AccelerationRequest_nominalAcceleration(stream, &data->nominalAcceleration);
   encode_Zenuity_Crusing_AccelerationRequest_minJerk(stream, &data->minJerk);
   encode_Zenuity_Crusing_AccelerationRequest_maxJerk(stream, &data->maxJerk);
   encode_Zenuity_Crusing_AccelerationRequest_Raw_standstillRequest(stream, &data->standstillRequest);
   return true;
}

bool decode_Zenuity_Crusing_AccelerationRequest(qpb_istream_t *const stream, Zenuity_Crusing_AccelerationRequest *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Crusing_AccelerationRequest_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Crusing_AccelerationRequest_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Crusing_CancelReasonAcc_Raw(qpb_ostream_t *const stream, const Zenuity_Crusing_CancelReasonAcc_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Crusing_CancelReasonAcc_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Crusing_CancelReasonAcc_Raw_noLeadVehicle(stream, &data->noLeadVehicle);
   encode_Zenuity_Crusing_CancelReasonAcc_Raw_endBrakeOnly(stream, &data->endBrakeOnly);
   return true;
}

bool decode_Zenuity_Crusing_CancelReasonAcc_Raw(qpb_istream_t *const stream, Zenuity_Crusing_CancelReasonAcc_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Crusing_CancelReasonAcc_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Crusing_CancelReasonAcc_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw(qpb_ostream_t *const stream, const Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Crusing_InformationToDriverFromTrafficAssist_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_handsOffWarning(stream, &data->handsOffWarning);
   encode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeType(stream, &data->laneChangeType);
   encode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeReason(stream, &data->laneChangeReason);
   encode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangePossibleDirection(stream, &data->laneChangePossibleDirection);
   encode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_laneChangeStatus(stream, &data->laneChangeStatus);
   return true;
}

bool decode_Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw(qpb_istream_t *const stream, Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Crusing_InformationToDriverFromTrafficAssist_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Crusing_SelectedTarget_Raw(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Crusing_SelectedTarget_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Crusing_SelectedTarget_Raw_isSelected(stream, &data->isSelected);
   encode_Zenuity_Crusing_SelectedTarget_Raw_isControlledTowards(stream, &data->isControlledTowards);
   encode_Zenuity_Crusing_SelectedTarget_Raw_latPosition(stream, &data->latPosition);
   encode_Zenuity_Crusing_SelectedTarget_Raw_lonPosition(stream, &data->lonPosition);
   encode_Zenuity_Crusing_SelectedTarget_Raw_speed(stream, &data->speed);
   return true;
}

bool decode_Zenuity_Crusing_SelectedTarget_Raw(qpb_istream_t *const stream, Zenuity_Crusing_SelectedTarget_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Crusing_SelectedTarget_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Crusing_SelectedTarget_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Crusing_SelectedTarget(qpb_ostream_t *const stream, const Zenuity_Crusing_SelectedTarget *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Crusing_SelectedTarget_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Crusing_SelectedTarget_Raw_isSelected(stream, &data->isSelected);
   encode_Zenuity_Crusing_SelectedTarget_Raw_isControlledTowards(stream, &data->isControlledTowards);
   encode_Zenuity_Crusing_SelectedTarget_latPosition(stream, &data->latPosition);
   encode_Zenuity_Crusing_SelectedTarget_lonPosition(stream, &data->lonPosition);
   encode_Zenuity_Crusing_SelectedTarget_speed(stream, &data->speed);
   return true;
}

bool decode_Zenuity_Crusing_SelectedTarget(qpb_istream_t *const stream, Zenuity_Crusing_SelectedTarget *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Crusing_SelectedTarget_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Crusing_SelectedTarget_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Crusing_TrafficAssistOutput_Raw(qpb_ostream_t *const stream, const Zenuity_Crusing_TrafficAssistOutput_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Crusing_TrafficAssistOutput_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Crusing_TrafficAssistOutput_Raw_turnIndicatorRequest(stream, &data->turnIndicatorRequest);
   return true;
}

bool decode_Zenuity_Crusing_TrafficAssistOutput_Raw(qpb_istream_t *const stream, Zenuity_Crusing_TrafficAssistOutput_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Crusing_TrafficAssistOutput_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Crusing_TrafficAssistOutput_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Crusing_TargetsSelectedByAcc_Raw(qpb_ostream_t *const stream, const Zenuity_Crusing_TargetsSelectedByAcc_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Crusing_TargetsSelectedByAcc_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInLane(stream, &data->closestInLane);
   encode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_secondClosestInLane(stream, &data->secondClosestInLane);
   encode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_cutIn(stream, &data->cutIn);
   encode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInLeftLane(stream, &data->closestInLeftLane);
   encode_Zenuity_Crusing_TargetsSelectedByAcc_Raw_closestInRightLane(stream, &data->closestInRightLane);
   return true;
}

bool decode_Zenuity_Crusing_TargetsSelectedByAcc_Raw(qpb_istream_t *const stream, Zenuity_Crusing_TargetsSelectedByAcc_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Crusing_TargetsSelectedByAcc_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Crusing_TargetsSelectedByAcc_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_Zenuity_Crusing_TargetsSelectedByAcc(qpb_ostream_t *const stream, const Zenuity_Crusing_TargetsSelectedByAcc *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < Zenuity_Crusing_TargetsSelectedByAcc_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_Zenuity_Crusing_TargetsSelectedByAcc_closestInLane(stream, &data->closestInLane);
   encode_Zenuity_Crusing_TargetsSelectedByAcc_secondClosestInLane(stream, &data->secondClosestInLane);
   encode_Zenuity_Crusing_TargetsSelectedByAcc_cutIn(stream, &data->cutIn);
   encode_Zenuity_Crusing_TargetsSelectedByAcc_closestInLeftLane(stream, &data->closestInLeftLane);
   encode_Zenuity_Crusing_TargetsSelectedByAcc_closestInRightLane(stream, &data->closestInRightLane);
   return true;
}

bool decode_Zenuity_Crusing_TargetsSelectedByAcc(qpb_istream_t *const stream, Zenuity_Crusing_TargetsSelectedByAcc *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < Zenuity_Crusing_TargetsSelectedByAcc_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = Zenuity_Crusing_TargetsSelectedByAcc_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

