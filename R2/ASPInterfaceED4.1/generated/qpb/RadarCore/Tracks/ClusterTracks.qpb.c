/* Automatically generated qpb constant definitions */
/* Generated by Quick Protocol Buffers - 2 */

#include "RadarCore/Tracks/ClusterTracks.qpb.h"
#include "Tools/QuickProtobuf/qpb_decode.h"
#include "Tools/QuickProtobuf/qpb_encode.h"
#include "Tools/CSupport/ConversionSupport.h"

#if QPB_PROTO_HEADER_VERSION != 2
#error Regenerate this file with the current version of qpb generator.
#endif

#define F_0_0001             0.0001f
#define F_0_01               0.01f
#define F_0_05               0.05f
#define F_0_1                0.1f

static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_x(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrackModelBox_Raw_x(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_y(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrackModelBox_Raw_y(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_width(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrackModelBox_Raw_width(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_length(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrackModelBox_Raw_length(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_heading(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrackModelBox_Raw_heading(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_x(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_ClusterTrackModelBox_x(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_y(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_ClusterTrackModelBox_y(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_width(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_ClusterTrackModelBox_width(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_length(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_ClusterTrackModelBox_length(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_heading(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_ClusterTrackModelBox_heading(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackMovement_Raw_xVelocity(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrackMovement_Raw_xVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackMovement_Raw_yVelocity(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrackMovement_Raw_yVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackMovement_Raw_xVelocityStdDev(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrackMovement_Raw_xVelocityStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackMovement_Raw_yVelocityStdDev(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrackMovement_Raw_yVelocityStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackMovement_Raw_xAcceleration(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrackMovement_Raw_xAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackMovement_Raw_yAcceleration(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrackMovement_Raw_yAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackMovement_xVelocity(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_ClusterTrackMovement_xVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackMovement_yVelocity(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_ClusterTrackMovement_yVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackMovement_xVelocityStdDev(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_ClusterTrackMovement_xVelocityStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackMovement_yVelocityStdDev(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_ClusterTrackMovement_yVelocityStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackMovement_xAcceleration(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_ClusterTrackMovement_xAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackMovement_yAcceleration(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_ClusterTrackMovement_yAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackPosition_Raw_x(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrackPosition_Raw_x(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackPosition_Raw_y(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrackPosition_Raw_y(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackPosition_Raw_xStdDev(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrackPosition_Raw_xStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackPosition_Raw_yStdDev(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrackPosition_Raw_yStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackPosition_x(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_ClusterTrackPosition_x(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackPosition_y(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_ClusterTrackPosition_y(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackPosition_xStdDev(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_ClusterTrackPosition_xStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackPosition_yStdDev(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_ClusterTrackPosition_yStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_id(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_Raw_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_closestPoint(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackPosition_Raw *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_Raw_closestPoint(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_boxModel(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackModelBox_Raw *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_Raw_boxModel(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_movement(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackMovement_Raw *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_Raw_movement(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_lifetime(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_Raw_lifetime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_stationaryCounter(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_Raw_stationaryCounter(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_observationHistory(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_Raw_observationHistory(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_motionClass(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackMotionClass *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_Raw_motionClass(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_type(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackObjectType *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_Raw_type(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_confidence(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_Raw_confidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_existanceProbability(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_Raw_existanceProbability(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_objectClassConfidence(qpb_ostream_t *const stream, const uint8_t arrayData[], const qpb_size_t arraySize);
static bool decode_RadarCore_Tracks_ClusterTrack_Raw_objectClassConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_elevation(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackElevation *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_Raw_elevation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_elevationConfidence(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackConfidence *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_Raw_elevationConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_qualityBits(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_Raw_qualityBits(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_id(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_closestPoint(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackPosition *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_closestPoint(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_boxModel(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackModelBox *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_boxModel(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_movement(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackMovement *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_movement(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_lifetime(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_lifetime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_stationaryCounter(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_stationaryCounter(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_observationHistory(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_observationHistory(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_motionClass(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackMotionClass *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_motionClass(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_type(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackObjectType *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_type(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_confidence(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_confidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_existanceProbability(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_existanceProbability(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_objectClassConfidence(qpb_ostream_t *const stream, const uint8_t arrayData[], const qpb_size_t arraySize);
static bool decode_RadarCore_Tracks_ClusterTrack_objectClassConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_elevation(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackElevation *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_elevation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_elevationConfidence(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackConfidence *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_elevationConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrack_qualityBits(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_RadarCore_Tracks_ClusterTrack_qualityBits(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackList_Raw_tracks(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrack_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_RadarCore_Tracks_ClusterTrackList_Raw_tracks(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_ClusterTrackList_tracks(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrack arrayData[], const qpb_size_t arraySize);
static bool decode_RadarCore_Tracks_ClusterTrackList_tracks(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);

#define RadarCore_Tracks_ClusterTrackModelBox_Raw_DECODERS_COUNT 6
const qpb_decoder_entry_t RadarCore_Tracks_ClusterTrackModelBox_Raw_decoders[RadarCore_Tracks_ClusterTrackModelBox_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_ClusterTrackModelBox_Raw_x },
   { &decode_RadarCore_Tracks_ClusterTrackModelBox_Raw_y },
   { &decode_RadarCore_Tracks_ClusterTrackModelBox_Raw_width },
   { &decode_RadarCore_Tracks_ClusterTrackModelBox_Raw_length },
   { &decode_RadarCore_Tracks_ClusterTrackModelBox_Raw_heading }
};

#define RadarCore_Tracks_ClusterTrackModelBox_DECODERS_COUNT 6
const qpb_decoder_entry_t RadarCore_Tracks_ClusterTrackModelBox_decoders[RadarCore_Tracks_ClusterTrackModelBox_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_ClusterTrackModelBox_x },
   { &decode_RadarCore_Tracks_ClusterTrackModelBox_y },
   { &decode_RadarCore_Tracks_ClusterTrackModelBox_width },
   { &decode_RadarCore_Tracks_ClusterTrackModelBox_length },
   { &decode_RadarCore_Tracks_ClusterTrackModelBox_heading }
};

#define RadarCore_Tracks_ClusterTrackMovement_Raw_DECODERS_COUNT 7
const qpb_decoder_entry_t RadarCore_Tracks_ClusterTrackMovement_Raw_decoders[RadarCore_Tracks_ClusterTrackMovement_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_ClusterTrackMovement_Raw_xVelocity },
   { &decode_RadarCore_Tracks_ClusterTrackMovement_Raw_yVelocity },
   { &decode_RadarCore_Tracks_ClusterTrackMovement_Raw_xVelocityStdDev },
   { &decode_RadarCore_Tracks_ClusterTrackMovement_Raw_yVelocityStdDev },
   { &decode_RadarCore_Tracks_ClusterTrackMovement_Raw_xAcceleration },
   { &decode_RadarCore_Tracks_ClusterTrackMovement_Raw_yAcceleration }
};

#define RadarCore_Tracks_ClusterTrackMovement_DECODERS_COUNT 7
const qpb_decoder_entry_t RadarCore_Tracks_ClusterTrackMovement_decoders[RadarCore_Tracks_ClusterTrackMovement_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_ClusterTrackMovement_xVelocity },
   { &decode_RadarCore_Tracks_ClusterTrackMovement_yVelocity },
   { &decode_RadarCore_Tracks_ClusterTrackMovement_xVelocityStdDev },
   { &decode_RadarCore_Tracks_ClusterTrackMovement_yVelocityStdDev },
   { &decode_RadarCore_Tracks_ClusterTrackMovement_xAcceleration },
   { &decode_RadarCore_Tracks_ClusterTrackMovement_yAcceleration }
};

#define RadarCore_Tracks_ClusterTrackPosition_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t RadarCore_Tracks_ClusterTrackPosition_Raw_decoders[RadarCore_Tracks_ClusterTrackPosition_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_ClusterTrackPosition_Raw_x },
   { &decode_RadarCore_Tracks_ClusterTrackPosition_Raw_y },
   { &decode_RadarCore_Tracks_ClusterTrackPosition_Raw_xStdDev },
   { &decode_RadarCore_Tracks_ClusterTrackPosition_Raw_yStdDev }
};

#define RadarCore_Tracks_ClusterTrackPosition_DECODERS_COUNT 5
const qpb_decoder_entry_t RadarCore_Tracks_ClusterTrackPosition_decoders[RadarCore_Tracks_ClusterTrackPosition_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_ClusterTrackPosition_x },
   { &decode_RadarCore_Tracks_ClusterTrackPosition_y },
   { &decode_RadarCore_Tracks_ClusterTrackPosition_xStdDev },
   { &decode_RadarCore_Tracks_ClusterTrackPosition_yStdDev }
};

#define RadarCore_Tracks_ClusterTrack_Raw_DECODERS_COUNT 16
const qpb_decoder_entry_t RadarCore_Tracks_ClusterTrack_Raw_decoders[RadarCore_Tracks_ClusterTrack_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_ClusterTrack_Raw_id },
   { &decode_RadarCore_Tracks_ClusterTrack_Raw_closestPoint },
   { &decode_RadarCore_Tracks_ClusterTrack_Raw_boxModel },
   { &decode_RadarCore_Tracks_ClusterTrack_Raw_movement },
   { &decode_RadarCore_Tracks_ClusterTrack_Raw_lifetime },
   { &decode_RadarCore_Tracks_ClusterTrack_Raw_stationaryCounter },
   { &decode_RadarCore_Tracks_ClusterTrack_Raw_observationHistory },
   { &decode_RadarCore_Tracks_ClusterTrack_Raw_motionClass },
   { &decode_RadarCore_Tracks_ClusterTrack_Raw_type },
   { &decode_RadarCore_Tracks_ClusterTrack_Raw_confidence },
   { &decode_RadarCore_Tracks_ClusterTrack_Raw_existanceProbability },
   { &decode_RadarCore_Tracks_ClusterTrack_Raw_objectClassConfidence },
   { &decode_RadarCore_Tracks_ClusterTrack_Raw_elevation },
   { &decode_RadarCore_Tracks_ClusterTrack_Raw_elevationConfidence },
   { &decode_RadarCore_Tracks_ClusterTrack_Raw_qualityBits }
};

#define RadarCore_Tracks_ClusterTrack_DECODERS_COUNT 16
const qpb_decoder_entry_t RadarCore_Tracks_ClusterTrack_decoders[RadarCore_Tracks_ClusterTrack_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_ClusterTrack_id },
   { &decode_RadarCore_Tracks_ClusterTrack_closestPoint },
   { &decode_RadarCore_Tracks_ClusterTrack_boxModel },
   { &decode_RadarCore_Tracks_ClusterTrack_movement },
   { &decode_RadarCore_Tracks_ClusterTrack_lifetime },
   { &decode_RadarCore_Tracks_ClusterTrack_stationaryCounter },
   { &decode_RadarCore_Tracks_ClusterTrack_observationHistory },
   { &decode_RadarCore_Tracks_ClusterTrack_motionClass },
   { &decode_RadarCore_Tracks_ClusterTrack_type },
   { &decode_RadarCore_Tracks_ClusterTrack_confidence },
   { &decode_RadarCore_Tracks_ClusterTrack_existanceProbability },
   { &decode_RadarCore_Tracks_ClusterTrack_objectClassConfidence },
   { &decode_RadarCore_Tracks_ClusterTrack_elevation },
   { &decode_RadarCore_Tracks_ClusterTrack_elevationConfidence },
   { &decode_RadarCore_Tracks_ClusterTrack_qualityBits }
};

#define RadarCore_Tracks_ClusterTrackList_Raw_DECODERS_COUNT 2
const qpb_decoder_entry_t RadarCore_Tracks_ClusterTrackList_Raw_decoders[RadarCore_Tracks_ClusterTrackList_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_ClusterTrackList_Raw_tracks }
};

#define RadarCore_Tracks_ClusterTrackList_DECODERS_COUNT 2
const qpb_decoder_entry_t RadarCore_Tracks_ClusterTrackList_decoders[RadarCore_Tracks_ClusterTrackList_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_ClusterTrackList_tracks }
};

static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_x(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrackModelBox_Raw_x(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((RadarCore_Tracks_ClusterTrackModelBox_Raw*)data)->x, sizeof(int32_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_y(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrackModelBox_Raw_y(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((RadarCore_Tracks_ClusterTrackModelBox_Raw*)data)->y, sizeof(int32_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_width(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrackModelBox_Raw_width(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrackModelBox_Raw*)data)->width, sizeof(uint16_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_length(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrackModelBox_Raw_length(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrackModelBox_Raw*)data)->length, sizeof(uint16_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_heading(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrackModelBox_Raw_heading(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((RadarCore_Tracks_ClusterTrackModelBox_Raw*)data)->heading, sizeof(int16_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_x(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_01, INT32_MIN, INT32_MAX);
   encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_x(stream, &value);
}

static bool decode_RadarCore_Tracks_ClusterTrackModelBox_x(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((RadarCore_Tracks_ClusterTrackModelBox*)data)->x = value * F_0_01;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_y(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_01, INT32_MIN, INT32_MAX);
   encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_y(stream, &value);
}

static bool decode_RadarCore_Tracks_ClusterTrackModelBox_y(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((RadarCore_Tracks_ClusterTrackModelBox*)data)->y = value * F_0_01;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_width(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_1, 0, UINT16_MAX);
   encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_width(stream, &value);
}

static bool decode_RadarCore_Tracks_ClusterTrackModelBox_width(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((RadarCore_Tracks_ClusterTrackModelBox*)data)->width = value * F_0_1;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_length(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_1, 0, UINT16_MAX);
   encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_length(stream, &value);
}

static bool decode_RadarCore_Tracks_ClusterTrackModelBox_length(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((RadarCore_Tracks_ClusterTrackModelBox*)data)->length = value * F_0_1;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrackModelBox_heading(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_0_0001, INT16_MIN, INT16_MAX);
   encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_heading(stream, &value);
}

static bool decode_RadarCore_Tracks_ClusterTrackModelBox_heading(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int16_t));
   ((RadarCore_Tracks_ClusterTrackModelBox*)data)->heading = value * F_0_0001;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrackMovement_Raw_xVelocity(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrackMovement_Raw_xVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((RadarCore_Tracks_ClusterTrackMovement_Raw*)data)->xVelocity, sizeof(int32_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrackMovement_Raw_yVelocity(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrackMovement_Raw_yVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((RadarCore_Tracks_ClusterTrackMovement_Raw*)data)->yVelocity, sizeof(int32_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrackMovement_Raw_xVelocityStdDev(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrackMovement_Raw_xVelocityStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrackMovement_Raw*)data)->xVelocityStdDev, sizeof(uint32_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrackMovement_Raw_yVelocityStdDev(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrackMovement_Raw_yVelocityStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrackMovement_Raw*)data)->yVelocityStdDev, sizeof(uint32_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrackMovement_Raw_xAcceleration(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrackMovement_Raw_xAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((RadarCore_Tracks_ClusterTrackMovement_Raw*)data)->xAcceleration, sizeof(int32_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrackMovement_Raw_yAcceleration(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrackMovement_Raw_yAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((RadarCore_Tracks_ClusterTrackMovement_Raw*)data)->yAcceleration, sizeof(int32_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrackMovement_xVelocity(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_01, INT32_MIN, INT32_MAX);
   encode_RadarCore_Tracks_ClusterTrackMovement_Raw_xVelocity(stream, &value);
}

static bool decode_RadarCore_Tracks_ClusterTrackMovement_xVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((RadarCore_Tracks_ClusterTrackMovement*)data)->xVelocity = value * F_0_01;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrackMovement_yVelocity(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_01, INT32_MIN, INT32_MAX);
   encode_RadarCore_Tracks_ClusterTrackMovement_Raw_yVelocity(stream, &value);
}

static bool decode_RadarCore_Tracks_ClusterTrackMovement_yVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((RadarCore_Tracks_ClusterTrackMovement*)data)->yVelocity = value * F_0_01;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrackMovement_xVelocityStdDev(qpb_ostream_t *const stream, const float *const data)
{
   uint32_t value = (uint32_t)convertToUint32(*data, F_0_05, 0, UINT32_MAX);
   encode_RadarCore_Tracks_ClusterTrackMovement_Raw_xVelocityStdDev(stream, &value);
}

static bool decode_RadarCore_Tracks_ClusterTrackMovement_xVelocityStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint32_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint32_t));
   ((RadarCore_Tracks_ClusterTrackMovement*)data)->xVelocityStdDev = value * F_0_05;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrackMovement_yVelocityStdDev(qpb_ostream_t *const stream, const float *const data)
{
   uint32_t value = (uint32_t)convertToUint32(*data, F_0_05, 0, UINT32_MAX);
   encode_RadarCore_Tracks_ClusterTrackMovement_Raw_yVelocityStdDev(stream, &value);
}

static bool decode_RadarCore_Tracks_ClusterTrackMovement_yVelocityStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint32_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint32_t));
   ((RadarCore_Tracks_ClusterTrackMovement*)data)->yVelocityStdDev = value * F_0_05;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrackMovement_xAcceleration(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_01, INT32_MIN, INT32_MAX);
   encode_RadarCore_Tracks_ClusterTrackMovement_Raw_xAcceleration(stream, &value);
}

static bool decode_RadarCore_Tracks_ClusterTrackMovement_xAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((RadarCore_Tracks_ClusterTrackMovement*)data)->xAcceleration = value * F_0_01;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrackMovement_yAcceleration(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_01, INT32_MIN, INT32_MAX);
   encode_RadarCore_Tracks_ClusterTrackMovement_Raw_yAcceleration(stream, &value);
}

static bool decode_RadarCore_Tracks_ClusterTrackMovement_yAcceleration(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((RadarCore_Tracks_ClusterTrackMovement*)data)->yAcceleration = value * F_0_01;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrackPosition_Raw_x(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrackPosition_Raw_x(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((RadarCore_Tracks_ClusterTrackPosition_Raw*)data)->x, sizeof(int32_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrackPosition_Raw_y(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrackPosition_Raw_y(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((RadarCore_Tracks_ClusterTrackPosition_Raw*)data)->y, sizeof(int32_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrackPosition_Raw_xStdDev(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrackPosition_Raw_xStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrackPosition_Raw*)data)->xStdDev, sizeof(uint16_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrackPosition_Raw_yStdDev(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrackPosition_Raw_yStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrackPosition_Raw*)data)->yStdDev, sizeof(uint16_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrackPosition_x(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_01, INT32_MIN, INT32_MAX);
   encode_RadarCore_Tracks_ClusterTrackPosition_Raw_x(stream, &value);
}

static bool decode_RadarCore_Tracks_ClusterTrackPosition_x(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((RadarCore_Tracks_ClusterTrackPosition*)data)->x = value * F_0_01;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrackPosition_y(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_01, INT32_MIN, INT32_MAX);
   encode_RadarCore_Tracks_ClusterTrackPosition_Raw_y(stream, &value);
}

static bool decode_RadarCore_Tracks_ClusterTrackPosition_y(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((RadarCore_Tracks_ClusterTrackPosition*)data)->y = value * F_0_01;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrackPosition_xStdDev(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_RadarCore_Tracks_ClusterTrackPosition_Raw_xStdDev(stream, &value);
}

static bool decode_RadarCore_Tracks_ClusterTrackPosition_xStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((RadarCore_Tracks_ClusterTrackPosition*)data)->xStdDev = value * F_0_01;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrackPosition_yStdDev(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_01, 0, UINT16_MAX);
   encode_RadarCore_Tracks_ClusterTrackPosition_Raw_yStdDev(stream, &value);
}

static bool decode_RadarCore_Tracks_ClusterTrackPosition_yStdDev(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((RadarCore_Tracks_ClusterTrackPosition*)data)->yStdDev = value * F_0_01;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_id(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_Raw_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack_Raw*)data)->id, sizeof(uint16_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_closestPoint(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackPosition_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_RadarCore_Tracks_ClusterTrackPosition_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_Raw_closestPoint(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_RadarCore_Tracks_ClusterTrackPosition_Raw(&substream, &((RadarCore_Tracks_ClusterTrack_Raw*)data)->closestPoint);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_boxModel(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackModelBox_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_RadarCore_Tracks_ClusterTrackModelBox_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_Raw_boxModel(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_RadarCore_Tracks_ClusterTrackModelBox_Raw(&substream, &((RadarCore_Tracks_ClusterTrack_Raw*)data)->boxModel);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_movement(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackMovement_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_RadarCore_Tracks_ClusterTrackMovement_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_Raw_movement(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_RadarCore_Tracks_ClusterTrackMovement_Raw(&substream, &((RadarCore_Tracks_ClusterTrack_Raw*)data)->movement);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_lifetime(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_Raw_lifetime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack_Raw*)data)->lifetime, sizeof(uint32_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_stationaryCounter(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_Raw_stationaryCounter(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack_Raw*)data)->stationaryCounter, sizeof(uint16_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_observationHistory(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_Raw_observationHistory(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack_Raw*)data)->observationHistory, sizeof(uint32_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_motionClass(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackMotionClass *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_Raw_motionClass(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((RadarCore_Tracks_ClusterTrack_Raw*)data)->motionClass, qpb_membersize(RadarCore_Tracks_ClusterTrack_Raw, motionClass));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_type(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackObjectType *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 72;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_Raw_type(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((RadarCore_Tracks_ClusterTrack_Raw*)data)->type, qpb_membersize(RadarCore_Tracks_ClusterTrack_Raw, type));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_confidence(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 80;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_Raw_confidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack_Raw*)data)->confidence, sizeof(uint8_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_existanceProbability(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 88;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_Raw_existanceProbability(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack_Raw*)data)->existanceProbability, sizeof(uint8_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_objectClassConfidence(qpb_ostream_t *const stream, const uint8_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 98;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_Raw_objectClassConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((RadarCore_Tracks_ClusterTrack_Raw*)data)->objectClassConfidence_count + 1 > 9)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack_Raw*)data)->objectClassConfidence[((RadarCore_Tracks_ClusterTrack_Raw*)data)->objectClassConfidence_count++], sizeof(uint8_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((RadarCore_Tracks_ClusterTrack_Raw*)data)->objectClassConfidence_count + 1) > 9)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack_Raw*)data)->objectClassConfidence[((RadarCore_Tracks_ClusterTrack_Raw*)data)->objectClassConfidence_count++], sizeof(uint8_t));
   }
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_elevation(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackElevation *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 104;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_Raw_elevation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((RadarCore_Tracks_ClusterTrack_Raw*)data)->elevation, qpb_membersize(RadarCore_Tracks_ClusterTrack_Raw, elevation));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_elevationConfidence(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackConfidence *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 112;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_Raw_elevationConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((RadarCore_Tracks_ClusterTrack_Raw*)data)->elevationConfidence, qpb_membersize(RadarCore_Tracks_ClusterTrack_Raw, elevationConfidence));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_Raw_qualityBits(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 120;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_Raw_qualityBits(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack_Raw*)data)->qualityBits, sizeof(uint32_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_id(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack*)data)->id, sizeof(uint16_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_closestPoint(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackPosition *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_RadarCore_Tracks_ClusterTrackPosition(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_closestPoint(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_RadarCore_Tracks_ClusterTrackPosition(&substream, &((RadarCore_Tracks_ClusterTrack*)data)->closestPoint);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrack_boxModel(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackModelBox *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 26;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_RadarCore_Tracks_ClusterTrackModelBox(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_boxModel(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_RadarCore_Tracks_ClusterTrackModelBox(&substream, &((RadarCore_Tracks_ClusterTrack*)data)->boxModel);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrack_movement(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackMovement *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_RadarCore_Tracks_ClusterTrackMovement(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_movement(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_RadarCore_Tracks_ClusterTrackMovement(&substream, &((RadarCore_Tracks_ClusterTrack*)data)->movement);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrack_lifetime(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_lifetime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack*)data)->lifetime, sizeof(uint32_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_stationaryCounter(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_stationaryCounter(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack*)data)->stationaryCounter, sizeof(uint16_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_observationHistory(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_observationHistory(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack*)data)->observationHistory, sizeof(uint32_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_motionClass(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackMotionClass *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_motionClass(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((RadarCore_Tracks_ClusterTrack*)data)->motionClass, qpb_membersize(RadarCore_Tracks_ClusterTrack, motionClass));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_type(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackObjectType *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 72;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_type(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((RadarCore_Tracks_ClusterTrack*)data)->type, qpb_membersize(RadarCore_Tracks_ClusterTrack, type));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_confidence(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 80;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_confidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack*)data)->confidence, sizeof(uint8_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_existanceProbability(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 88;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_existanceProbability(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack*)data)->existanceProbability, sizeof(uint8_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_objectClassConfidence(qpb_ostream_t *const stream, const uint8_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 98;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_objectClassConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((RadarCore_Tracks_ClusterTrack*)data)->objectClassConfidence_count + 1 > 9)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack*)data)->objectClassConfidence[((RadarCore_Tracks_ClusterTrack*)data)->objectClassConfidence_count++], sizeof(uint8_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((RadarCore_Tracks_ClusterTrack*)data)->objectClassConfidence_count + 1) > 9)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack*)data)->objectClassConfidence[((RadarCore_Tracks_ClusterTrack*)data)->objectClassConfidence_count++], sizeof(uint8_t));
   }
   return result;
}

static inline void encode_RadarCore_Tracks_ClusterTrack_elevation(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackElevation *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 104;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_elevation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((RadarCore_Tracks_ClusterTrack*)data)->elevation, qpb_membersize(RadarCore_Tracks_ClusterTrack, elevation));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_elevationConfidence(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackConfidence *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 112;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_elevationConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((RadarCore_Tracks_ClusterTrack*)data)->elevationConfidence, qpb_membersize(RadarCore_Tracks_ClusterTrack, elevationConfidence));
}

static inline void encode_RadarCore_Tracks_ClusterTrack_qualityBits(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 120;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_ClusterTrack_qualityBits(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_ClusterTrack*)data)->qualityBits, sizeof(uint32_t));
}

static inline void encode_RadarCore_Tracks_ClusterTrackList_Raw_tracks(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrack_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 10;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_RadarCore_Tracks_ClusterTrack_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_RadarCore_Tracks_ClusterTrackList_Raw_tracks(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((RadarCore_Tracks_ClusterTrackList_Raw*)data)->tracks_count + 1) > 30)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_RadarCore_Tracks_ClusterTrack_Raw(&substream, &((RadarCore_Tracks_ClusterTrackList_Raw*)data)->tracks[((RadarCore_Tracks_ClusterTrackList_Raw*)data)->tracks_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_RadarCore_Tracks_ClusterTrackList_tracks(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrack arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 10;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_RadarCore_Tracks_ClusterTrack(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_RadarCore_Tracks_ClusterTrackList_tracks(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((RadarCore_Tracks_ClusterTrackList*)data)->tracks_count + 1) > 30)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_RadarCore_Tracks_ClusterTrack(&substream, &((RadarCore_Tracks_ClusterTrackList*)data)->tracks[((RadarCore_Tracks_ClusterTrackList*)data)->tracks_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

/* Encoding / decoding functions */
bool encode_RadarCore_Tracks_ClusterTrackModelBox_Raw(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackModelBox_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_ClusterTrackModelBox_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_x(stream, &data->x);
   encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_y(stream, &data->y);
   encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_width(stream, &data->width);
   encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_length(stream, &data->length);
   encode_RadarCore_Tracks_ClusterTrackModelBox_Raw_heading(stream, &data->heading);
   return true;
}

bool decode_RadarCore_Tracks_ClusterTrackModelBox_Raw(qpb_istream_t *const stream, RadarCore_Tracks_ClusterTrackModelBox_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_ClusterTrackModelBox_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_ClusterTrackModelBox_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_RadarCore_Tracks_ClusterTrackModelBox(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackModelBox *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_ClusterTrackModelBox_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_ClusterTrackModelBox_x(stream, &data->x);
   encode_RadarCore_Tracks_ClusterTrackModelBox_y(stream, &data->y);
   encode_RadarCore_Tracks_ClusterTrackModelBox_width(stream, &data->width);
   encode_RadarCore_Tracks_ClusterTrackModelBox_length(stream, &data->length);
   encode_RadarCore_Tracks_ClusterTrackModelBox_heading(stream, &data->heading);
   return true;
}

bool decode_RadarCore_Tracks_ClusterTrackModelBox(qpb_istream_t *const stream, RadarCore_Tracks_ClusterTrackModelBox *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_ClusterTrackModelBox_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_ClusterTrackModelBox_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_RadarCore_Tracks_ClusterTrackMovement_Raw(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackMovement_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_ClusterTrackMovement_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_ClusterTrackMovement_Raw_xVelocity(stream, &data->xVelocity);
   encode_RadarCore_Tracks_ClusterTrackMovement_Raw_yVelocity(stream, &data->yVelocity);
   encode_RadarCore_Tracks_ClusterTrackMovement_Raw_xVelocityStdDev(stream, &data->xVelocityStdDev);
   encode_RadarCore_Tracks_ClusterTrackMovement_Raw_yVelocityStdDev(stream, &data->yVelocityStdDev);
   encode_RadarCore_Tracks_ClusterTrackMovement_Raw_xAcceleration(stream, &data->xAcceleration);
   encode_RadarCore_Tracks_ClusterTrackMovement_Raw_yAcceleration(stream, &data->yAcceleration);
   return true;
}

bool decode_RadarCore_Tracks_ClusterTrackMovement_Raw(qpb_istream_t *const stream, RadarCore_Tracks_ClusterTrackMovement_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_ClusterTrackMovement_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_ClusterTrackMovement_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_RadarCore_Tracks_ClusterTrackMovement(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackMovement *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_ClusterTrackMovement_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_ClusterTrackMovement_xVelocity(stream, &data->xVelocity);
   encode_RadarCore_Tracks_ClusterTrackMovement_yVelocity(stream, &data->yVelocity);
   encode_RadarCore_Tracks_ClusterTrackMovement_xVelocityStdDev(stream, &data->xVelocityStdDev);
   encode_RadarCore_Tracks_ClusterTrackMovement_yVelocityStdDev(stream, &data->yVelocityStdDev);
   encode_RadarCore_Tracks_ClusterTrackMovement_xAcceleration(stream, &data->xAcceleration);
   encode_RadarCore_Tracks_ClusterTrackMovement_yAcceleration(stream, &data->yAcceleration);
   return true;
}

bool decode_RadarCore_Tracks_ClusterTrackMovement(qpb_istream_t *const stream, RadarCore_Tracks_ClusterTrackMovement *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_ClusterTrackMovement_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_ClusterTrackMovement_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_RadarCore_Tracks_ClusterTrackPosition_Raw(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackPosition_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_ClusterTrackPosition_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_ClusterTrackPosition_Raw_x(stream, &data->x);
   encode_RadarCore_Tracks_ClusterTrackPosition_Raw_y(stream, &data->y);
   encode_RadarCore_Tracks_ClusterTrackPosition_Raw_xStdDev(stream, &data->xStdDev);
   encode_RadarCore_Tracks_ClusterTrackPosition_Raw_yStdDev(stream, &data->yStdDev);
   return true;
}

bool decode_RadarCore_Tracks_ClusterTrackPosition_Raw(qpb_istream_t *const stream, RadarCore_Tracks_ClusterTrackPosition_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_ClusterTrackPosition_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_ClusterTrackPosition_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_RadarCore_Tracks_ClusterTrackPosition(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackPosition *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_ClusterTrackPosition_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_ClusterTrackPosition_x(stream, &data->x);
   encode_RadarCore_Tracks_ClusterTrackPosition_y(stream, &data->y);
   encode_RadarCore_Tracks_ClusterTrackPosition_xStdDev(stream, &data->xStdDev);
   encode_RadarCore_Tracks_ClusterTrackPosition_yStdDev(stream, &data->yStdDev);
   return true;
}

bool decode_RadarCore_Tracks_ClusterTrackPosition(qpb_istream_t *const stream, RadarCore_Tracks_ClusterTrackPosition *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_ClusterTrackPosition_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_ClusterTrackPosition_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_RadarCore_Tracks_ClusterTrack_Raw(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrack_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_ClusterTrack_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_ClusterTrack_Raw_id(stream, &data->id);
   encode_RadarCore_Tracks_ClusterTrack_Raw_closestPoint(stream, &data->closestPoint);
   encode_RadarCore_Tracks_ClusterTrack_Raw_boxModel(stream, &data->boxModel);
   encode_RadarCore_Tracks_ClusterTrack_Raw_movement(stream, &data->movement);
   encode_RadarCore_Tracks_ClusterTrack_Raw_lifetime(stream, &data->lifetime);
   encode_RadarCore_Tracks_ClusterTrack_Raw_stationaryCounter(stream, &data->stationaryCounter);
   encode_RadarCore_Tracks_ClusterTrack_Raw_observationHistory(stream, &data->observationHistory);
   encode_RadarCore_Tracks_ClusterTrack_Raw_motionClass(stream, &data->motionClass);
   encode_RadarCore_Tracks_ClusterTrack_Raw_type(stream, &data->type);
   encode_RadarCore_Tracks_ClusterTrack_Raw_confidence(stream, &data->confidence);
   encode_RadarCore_Tracks_ClusterTrack_Raw_existanceProbability(stream, &data->existanceProbability);
   encode_RadarCore_Tracks_ClusterTrack_Raw_objectClassConfidence(stream, data->objectClassConfidence, data->objectClassConfidence_count);
   encode_RadarCore_Tracks_ClusterTrack_Raw_elevation(stream, &data->elevation);
   encode_RadarCore_Tracks_ClusterTrack_Raw_elevationConfidence(stream, &data->elevationConfidence);
   encode_RadarCore_Tracks_ClusterTrack_Raw_qualityBits(stream, &data->qualityBits);
   return true;
}

bool decode_RadarCore_Tracks_ClusterTrack_Raw(qpb_istream_t *const stream, RadarCore_Tracks_ClusterTrack_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_ClusterTrack_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_ClusterTrack_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_RadarCore_Tracks_ClusterTrack(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrack *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_ClusterTrack_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_ClusterTrack_Raw_id(stream, &data->id);
   encode_RadarCore_Tracks_ClusterTrack_closestPoint(stream, &data->closestPoint);
   encode_RadarCore_Tracks_ClusterTrack_boxModel(stream, &data->boxModel);
   encode_RadarCore_Tracks_ClusterTrack_movement(stream, &data->movement);
   encode_RadarCore_Tracks_ClusterTrack_Raw_lifetime(stream, &data->lifetime);
   encode_RadarCore_Tracks_ClusterTrack_Raw_stationaryCounter(stream, &data->stationaryCounter);
   encode_RadarCore_Tracks_ClusterTrack_Raw_observationHistory(stream, &data->observationHistory);
   encode_RadarCore_Tracks_ClusterTrack_Raw_motionClass(stream, &data->motionClass);
   encode_RadarCore_Tracks_ClusterTrack_Raw_type(stream, &data->type);
   encode_RadarCore_Tracks_ClusterTrack_Raw_confidence(stream, &data->confidence);
   encode_RadarCore_Tracks_ClusterTrack_Raw_existanceProbability(stream, &data->existanceProbability);
   encode_RadarCore_Tracks_ClusterTrack_Raw_objectClassConfidence(stream, data->objectClassConfidence, data->objectClassConfidence_count);
   encode_RadarCore_Tracks_ClusterTrack_Raw_elevation(stream, &data->elevation);
   encode_RadarCore_Tracks_ClusterTrack_Raw_elevationConfidence(stream, &data->elevationConfidence);
   encode_RadarCore_Tracks_ClusterTrack_Raw_qualityBits(stream, &data->qualityBits);
   return true;
}

bool decode_RadarCore_Tracks_ClusterTrack(qpb_istream_t *const stream, RadarCore_Tracks_ClusterTrack *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_ClusterTrack_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_ClusterTrack_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_RadarCore_Tracks_ClusterTrackList_Raw(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackList_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_ClusterTrackList_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_ClusterTrackList_Raw_tracks(stream, data->tracks, data->tracks_count);
   return true;
}

bool decode_RadarCore_Tracks_ClusterTrackList_Raw(qpb_istream_t *const stream, RadarCore_Tracks_ClusterTrackList_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_ClusterTrackList_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_ClusterTrackList_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_RadarCore_Tracks_ClusterTrackList(qpb_ostream_t *const stream, const RadarCore_Tracks_ClusterTrackList *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_ClusterTrackList_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_ClusterTrackList_tracks(stream, data->tracks, data->tracks_count);
   return true;
}

bool decode_RadarCore_Tracks_ClusterTrackList(qpb_istream_t *const stream, RadarCore_Tracks_ClusterTrackList *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_ClusterTrackList_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_ClusterTrackList_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

