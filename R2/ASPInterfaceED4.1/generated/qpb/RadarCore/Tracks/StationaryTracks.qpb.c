/* Automatically generated qpb constant definitions */
/* Generated by Quick Protocol Buffers - 2 */

#include "RadarCore/Tracks/StationaryTracks.qpb.h"
#include "Tools/QuickProtobuf/qpb_decode.h"
#include "Tools/QuickProtobuf/qpb_encode.h"
#include "Tools/CSupport/ConversionSupport.h"

#if QPB_PROTO_HEADER_VERSION != 2
#error Regenerate this file with the current version of qpb generator.
#endif

#define F_0_01               0.01f

static inline void encode_RadarCore_Tracks_StationaryTrackMovement_Raw_xVelocity(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_RadarCore_Tracks_StationaryTrackMovement_Raw_xVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrackMovement_Raw_yVelocity(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_RadarCore_Tracks_StationaryTrackMovement_Raw_yVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrackMovement_xVelocity(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_StationaryTrackMovement_xVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrackMovement_yVelocity(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_StationaryTrackMovement_yVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrackPosition_Raw_x(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_RadarCore_Tracks_StationaryTrackPosition_Raw_x(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrackPosition_Raw_y(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_RadarCore_Tracks_StationaryTrackPosition_Raw_y(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrackPosition_x(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_StationaryTrackPosition_x(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrackPosition_y(qpb_ostream_t *const stream, const float *const data);
static bool decode_RadarCore_Tracks_StationaryTrackPosition_y(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_id(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_Raw_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_position(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackPosition_Raw *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_Raw_position(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_movement(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackMovement_Raw *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_Raw_movement(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_lifetime(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_Raw_lifetime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_predictionCounter(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_Raw_predictionCounter(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_propertyBits(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_Raw_propertyBits(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_quality(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackQuality *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_Raw_quality(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_elevation(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackElevation *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_Raw_elevation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_elevationConfidence(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackQuality *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_Raw_elevationConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_id(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_position(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackPosition *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_position(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_movement(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackMovement *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_movement(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_lifetime(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_lifetime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_predictionCounter(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_predictionCounter(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_propertyBits(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_propertyBits(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_quality(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackQuality *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_quality(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_elevation(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackElevation *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_elevation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrack_elevationConfidence(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackQuality *const data);
static bool decode_RadarCore_Tracks_StationaryTrack_elevationConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrackList_Raw_tracks(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrack_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_RadarCore_Tracks_StationaryTrackList_Raw_tracks(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_RadarCore_Tracks_StationaryTrackList_tracks(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrack arrayData[], const qpb_size_t arraySize);
static bool decode_RadarCore_Tracks_StationaryTrackList_tracks(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);

#define RadarCore_Tracks_StationaryTrackMovement_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t RadarCore_Tracks_StationaryTrackMovement_Raw_decoders[RadarCore_Tracks_StationaryTrackMovement_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_StationaryTrackMovement_Raw_xVelocity },
   { &decode_RadarCore_Tracks_StationaryTrackMovement_Raw_yVelocity }
};

#define RadarCore_Tracks_StationaryTrackMovement_DECODERS_COUNT 3
const qpb_decoder_entry_t RadarCore_Tracks_StationaryTrackMovement_decoders[RadarCore_Tracks_StationaryTrackMovement_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_StationaryTrackMovement_xVelocity },
   { &decode_RadarCore_Tracks_StationaryTrackMovement_yVelocity }
};

#define RadarCore_Tracks_StationaryTrackPosition_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t RadarCore_Tracks_StationaryTrackPosition_Raw_decoders[RadarCore_Tracks_StationaryTrackPosition_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_StationaryTrackPosition_Raw_x },
   { &decode_RadarCore_Tracks_StationaryTrackPosition_Raw_y }
};

#define RadarCore_Tracks_StationaryTrackPosition_DECODERS_COUNT 3
const qpb_decoder_entry_t RadarCore_Tracks_StationaryTrackPosition_decoders[RadarCore_Tracks_StationaryTrackPosition_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_StationaryTrackPosition_x },
   { &decode_RadarCore_Tracks_StationaryTrackPosition_y }
};

#define RadarCore_Tracks_StationaryTrack_Raw_DECODERS_COUNT 11
const qpb_decoder_entry_t RadarCore_Tracks_StationaryTrack_Raw_decoders[RadarCore_Tracks_StationaryTrack_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_StationaryTrack_Raw_id },
   { &decode_RadarCore_Tracks_StationaryTrack_Raw_position },
   { &qpb_skip_field },
   { &decode_RadarCore_Tracks_StationaryTrack_Raw_movement },
   { &decode_RadarCore_Tracks_StationaryTrack_Raw_lifetime },
   { &decode_RadarCore_Tracks_StationaryTrack_Raw_predictionCounter },
   { &decode_RadarCore_Tracks_StationaryTrack_Raw_propertyBits },
   { &decode_RadarCore_Tracks_StationaryTrack_Raw_quality },
   { &decode_RadarCore_Tracks_StationaryTrack_Raw_elevation },
   { &decode_RadarCore_Tracks_StationaryTrack_Raw_elevationConfidence }
};

#define RadarCore_Tracks_StationaryTrack_DECODERS_COUNT 11
const qpb_decoder_entry_t RadarCore_Tracks_StationaryTrack_decoders[RadarCore_Tracks_StationaryTrack_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_StationaryTrack_id },
   { &decode_RadarCore_Tracks_StationaryTrack_position },
   { &qpb_skip_field },
   { &decode_RadarCore_Tracks_StationaryTrack_movement },
   { &decode_RadarCore_Tracks_StationaryTrack_lifetime },
   { &decode_RadarCore_Tracks_StationaryTrack_predictionCounter },
   { &decode_RadarCore_Tracks_StationaryTrack_propertyBits },
   { &decode_RadarCore_Tracks_StationaryTrack_quality },
   { &decode_RadarCore_Tracks_StationaryTrack_elevation },
   { &decode_RadarCore_Tracks_StationaryTrack_elevationConfidence }
};

#define RadarCore_Tracks_StationaryTrackList_Raw_DECODERS_COUNT 2
const qpb_decoder_entry_t RadarCore_Tracks_StationaryTrackList_Raw_decoders[RadarCore_Tracks_StationaryTrackList_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_StationaryTrackList_Raw_tracks }
};

#define RadarCore_Tracks_StationaryTrackList_DECODERS_COUNT 2
const qpb_decoder_entry_t RadarCore_Tracks_StationaryTrackList_decoders[RadarCore_Tracks_StationaryTrackList_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_RadarCore_Tracks_StationaryTrackList_tracks }
};

static inline void encode_RadarCore_Tracks_StationaryTrackMovement_Raw_xVelocity(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrackMovement_Raw_xVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((RadarCore_Tracks_StationaryTrackMovement_Raw*)data)->xVelocity, sizeof(int32_t));
}

static inline void encode_RadarCore_Tracks_StationaryTrackMovement_Raw_yVelocity(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrackMovement_Raw_yVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((RadarCore_Tracks_StationaryTrackMovement_Raw*)data)->yVelocity, sizeof(int32_t));
}

static inline void encode_RadarCore_Tracks_StationaryTrackMovement_xVelocity(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_01, INT32_MIN, INT32_MAX);
   encode_RadarCore_Tracks_StationaryTrackMovement_Raw_xVelocity(stream, &value);
}

static bool decode_RadarCore_Tracks_StationaryTrackMovement_xVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((RadarCore_Tracks_StationaryTrackMovement*)data)->xVelocity = value * F_0_01;
   return result;
}

static inline void encode_RadarCore_Tracks_StationaryTrackMovement_yVelocity(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_01, INT32_MIN, INT32_MAX);
   encode_RadarCore_Tracks_StationaryTrackMovement_Raw_yVelocity(stream, &value);
}

static bool decode_RadarCore_Tracks_StationaryTrackMovement_yVelocity(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((RadarCore_Tracks_StationaryTrackMovement*)data)->yVelocity = value * F_0_01;
   return result;
}

static inline void encode_RadarCore_Tracks_StationaryTrackPosition_Raw_x(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrackPosition_Raw_x(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((RadarCore_Tracks_StationaryTrackPosition_Raw*)data)->x, sizeof(int32_t));
}

static inline void encode_RadarCore_Tracks_StationaryTrackPosition_Raw_y(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrackPosition_Raw_y(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((RadarCore_Tracks_StationaryTrackPosition_Raw*)data)->y, sizeof(int32_t));
}

static inline void encode_RadarCore_Tracks_StationaryTrackPosition_x(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_01, INT32_MIN, INT32_MAX);
   encode_RadarCore_Tracks_StationaryTrackPosition_Raw_x(stream, &value);
}

static bool decode_RadarCore_Tracks_StationaryTrackPosition_x(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((RadarCore_Tracks_StationaryTrackPosition*)data)->x = value * F_0_01;
   return result;
}

static inline void encode_RadarCore_Tracks_StationaryTrackPosition_y(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_01, INT32_MIN, INT32_MAX);
   encode_RadarCore_Tracks_StationaryTrackPosition_Raw_y(stream, &value);
}

static bool decode_RadarCore_Tracks_StationaryTrackPosition_y(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((RadarCore_Tracks_StationaryTrackPosition*)data)->y = value * F_0_01;
   return result;
}

static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_id(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_Raw_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_StationaryTrack_Raw*)data)->id, sizeof(uint16_t));
}

static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_position(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackPosition_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_RadarCore_Tracks_StationaryTrackPosition_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_Raw_position(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_RadarCore_Tracks_StationaryTrackPosition_Raw(&substream, &((RadarCore_Tracks_StationaryTrack_Raw*)data)->position);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_movement(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackMovement_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_RadarCore_Tracks_StationaryTrackMovement_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_Raw_movement(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_RadarCore_Tracks_StationaryTrackMovement_Raw(&substream, &((RadarCore_Tracks_StationaryTrack_Raw*)data)->movement);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_lifetime(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_Raw_lifetime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_StationaryTrack_Raw*)data)->lifetime, sizeof(uint8_t));
}

static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_predictionCounter(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_Raw_predictionCounter(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_StationaryTrack_Raw*)data)->predictionCounter, sizeof(uint8_t));
}

static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_propertyBits(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_Raw_propertyBits(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_StationaryTrack_Raw*)data)->propertyBits, sizeof(uint8_t));
}

static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_quality(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackQuality *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_Raw_quality(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((RadarCore_Tracks_StationaryTrack_Raw*)data)->quality, qpb_membersize(RadarCore_Tracks_StationaryTrack_Raw, quality));
}

static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_elevation(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackElevation *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 72;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_Raw_elevation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((RadarCore_Tracks_StationaryTrack_Raw*)data)->elevation, qpb_membersize(RadarCore_Tracks_StationaryTrack_Raw, elevation));
}

static inline void encode_RadarCore_Tracks_StationaryTrack_Raw_elevationConfidence(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackQuality *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 80;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_Raw_elevationConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((RadarCore_Tracks_StationaryTrack_Raw*)data)->elevationConfidence, qpb_membersize(RadarCore_Tracks_StationaryTrack_Raw, elevationConfidence));
}

static inline void encode_RadarCore_Tracks_StationaryTrack_id(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_id(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_StationaryTrack*)data)->id, sizeof(uint16_t));
}

static inline void encode_RadarCore_Tracks_StationaryTrack_position(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackPosition *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_RadarCore_Tracks_StationaryTrackPosition(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_position(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_RadarCore_Tracks_StationaryTrackPosition(&substream, &((RadarCore_Tracks_StationaryTrack*)data)->position);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_RadarCore_Tracks_StationaryTrack_movement(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackMovement *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 34;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_RadarCore_Tracks_StationaryTrackMovement(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_movement(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_RadarCore_Tracks_StationaryTrackMovement(&substream, &((RadarCore_Tracks_StationaryTrack*)data)->movement);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_RadarCore_Tracks_StationaryTrack_lifetime(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_lifetime(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_StationaryTrack*)data)->lifetime, sizeof(uint8_t));
}

static inline void encode_RadarCore_Tracks_StationaryTrack_predictionCounter(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_predictionCounter(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_StationaryTrack*)data)->predictionCounter, sizeof(uint8_t));
}

static inline void encode_RadarCore_Tracks_StationaryTrack_propertyBits(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_propertyBits(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((RadarCore_Tracks_StationaryTrack*)data)->propertyBits, sizeof(uint8_t));
}

static inline void encode_RadarCore_Tracks_StationaryTrack_quality(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackQuality *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_quality(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((RadarCore_Tracks_StationaryTrack*)data)->quality, qpb_membersize(RadarCore_Tracks_StationaryTrack, quality));
}

static inline void encode_RadarCore_Tracks_StationaryTrack_elevation(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackElevation *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 72;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_elevation(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((RadarCore_Tracks_StationaryTrack*)data)->elevation, qpb_membersize(RadarCore_Tracks_StationaryTrack, elevation));
}

static inline void encode_RadarCore_Tracks_StationaryTrack_elevationConfidence(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackQuality *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 80;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_RadarCore_Tracks_StationaryTrack_elevationConfidence(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((RadarCore_Tracks_StationaryTrack*)data)->elevationConfidence, qpb_membersize(RadarCore_Tracks_StationaryTrack, elevationConfidence));
}

static inline void encode_RadarCore_Tracks_StationaryTrackList_Raw_tracks(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrack_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 10;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_RadarCore_Tracks_StationaryTrack_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_RadarCore_Tracks_StationaryTrackList_Raw_tracks(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((RadarCore_Tracks_StationaryTrackList_Raw*)data)->tracks_count + 1) > 40)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_RadarCore_Tracks_StationaryTrack_Raw(&substream, &((RadarCore_Tracks_StationaryTrackList_Raw*)data)->tracks[((RadarCore_Tracks_StationaryTrackList_Raw*)data)->tracks_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_RadarCore_Tracks_StationaryTrackList_tracks(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrack arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 10;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_RadarCore_Tracks_StationaryTrack(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_RadarCore_Tracks_StationaryTrackList_tracks(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((RadarCore_Tracks_StationaryTrackList*)data)->tracks_count + 1) > 40)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_RadarCore_Tracks_StationaryTrack(&substream, &((RadarCore_Tracks_StationaryTrackList*)data)->tracks[((RadarCore_Tracks_StationaryTrackList*)data)->tracks_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

/* Encoding / decoding functions */
bool encode_RadarCore_Tracks_StationaryTrackMovement_Raw(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackMovement_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_StationaryTrackMovement_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_StationaryTrackMovement_Raw_xVelocity(stream, &data->xVelocity);
   encode_RadarCore_Tracks_StationaryTrackMovement_Raw_yVelocity(stream, &data->yVelocity);
   return true;
}

bool decode_RadarCore_Tracks_StationaryTrackMovement_Raw(qpb_istream_t *const stream, RadarCore_Tracks_StationaryTrackMovement_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_StationaryTrackMovement_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_StationaryTrackMovement_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_RadarCore_Tracks_StationaryTrackMovement(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackMovement *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_StationaryTrackMovement_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_StationaryTrackMovement_xVelocity(stream, &data->xVelocity);
   encode_RadarCore_Tracks_StationaryTrackMovement_yVelocity(stream, &data->yVelocity);
   return true;
}

bool decode_RadarCore_Tracks_StationaryTrackMovement(qpb_istream_t *const stream, RadarCore_Tracks_StationaryTrackMovement *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_StationaryTrackMovement_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_StationaryTrackMovement_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_RadarCore_Tracks_StationaryTrackPosition_Raw(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackPosition_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_StationaryTrackPosition_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_StationaryTrackPosition_Raw_x(stream, &data->x);
   encode_RadarCore_Tracks_StationaryTrackPosition_Raw_y(stream, &data->y);
   return true;
}

bool decode_RadarCore_Tracks_StationaryTrackPosition_Raw(qpb_istream_t *const stream, RadarCore_Tracks_StationaryTrackPosition_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_StationaryTrackPosition_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_StationaryTrackPosition_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_RadarCore_Tracks_StationaryTrackPosition(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackPosition *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_StationaryTrackPosition_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_StationaryTrackPosition_x(stream, &data->x);
   encode_RadarCore_Tracks_StationaryTrackPosition_y(stream, &data->y);
   return true;
}

bool decode_RadarCore_Tracks_StationaryTrackPosition(qpb_istream_t *const stream, RadarCore_Tracks_StationaryTrackPosition *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_StationaryTrackPosition_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_StationaryTrackPosition_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_RadarCore_Tracks_StationaryTrack_Raw(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrack_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_StationaryTrack_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_StationaryTrack_Raw_id(stream, &data->id);
   encode_RadarCore_Tracks_StationaryTrack_Raw_position(stream, &data->position);
   encode_RadarCore_Tracks_StationaryTrack_Raw_movement(stream, &data->movement);
   encode_RadarCore_Tracks_StationaryTrack_Raw_lifetime(stream, &data->lifetime);
   encode_RadarCore_Tracks_StationaryTrack_Raw_predictionCounter(stream, &data->predictionCounter);
   encode_RadarCore_Tracks_StationaryTrack_Raw_propertyBits(stream, &data->propertyBits);
   encode_RadarCore_Tracks_StationaryTrack_Raw_quality(stream, &data->quality);
   encode_RadarCore_Tracks_StationaryTrack_Raw_elevation(stream, &data->elevation);
   encode_RadarCore_Tracks_StationaryTrack_Raw_elevationConfidence(stream, &data->elevationConfidence);
   return true;
}

bool decode_RadarCore_Tracks_StationaryTrack_Raw(qpb_istream_t *const stream, RadarCore_Tracks_StationaryTrack_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_StationaryTrack_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_StationaryTrack_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_RadarCore_Tracks_StationaryTrack(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrack *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_StationaryTrack_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_StationaryTrack_Raw_id(stream, &data->id);
   encode_RadarCore_Tracks_StationaryTrack_position(stream, &data->position);
   encode_RadarCore_Tracks_StationaryTrack_movement(stream, &data->movement);
   encode_RadarCore_Tracks_StationaryTrack_Raw_lifetime(stream, &data->lifetime);
   encode_RadarCore_Tracks_StationaryTrack_Raw_predictionCounter(stream, &data->predictionCounter);
   encode_RadarCore_Tracks_StationaryTrack_Raw_propertyBits(stream, &data->propertyBits);
   encode_RadarCore_Tracks_StationaryTrack_Raw_quality(stream, &data->quality);
   encode_RadarCore_Tracks_StationaryTrack_Raw_elevation(stream, &data->elevation);
   encode_RadarCore_Tracks_StationaryTrack_Raw_elevationConfidence(stream, &data->elevationConfidence);
   return true;
}

bool decode_RadarCore_Tracks_StationaryTrack(qpb_istream_t *const stream, RadarCore_Tracks_StationaryTrack *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_StationaryTrack_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_StationaryTrack_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_RadarCore_Tracks_StationaryTrackList_Raw(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackList_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_StationaryTrackList_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_StationaryTrackList_Raw_tracks(stream, data->tracks, data->tracks_count);
   return true;
}

bool decode_RadarCore_Tracks_StationaryTrackList_Raw(qpb_istream_t *const stream, RadarCore_Tracks_StationaryTrackList_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_StationaryTrackList_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_StationaryTrackList_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_RadarCore_Tracks_StationaryTrackList(qpb_ostream_t *const stream, const RadarCore_Tracks_StationaryTrackList *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < RadarCore_Tracks_StationaryTrackList_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_RadarCore_Tracks_StationaryTrackList_tracks(stream, data->tracks, data->tracks_count);
   return true;
}

bool decode_RadarCore_Tracks_StationaryTrackList(qpb_istream_t *const stream, RadarCore_Tracks_StationaryTrackList *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < RadarCore_Tracks_StationaryTrackList_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = RadarCore_Tracks_StationaryTrackList_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

