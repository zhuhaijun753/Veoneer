/* Automatically generated qpb constant definitions */
/* Generated by Quick Protocol Buffers - 2 */

#include "Tools/Test/TestAll_32bit.qpb.h"
#include "Tools/QuickProtobuf/qpb_decode.h"
#include "Tools/QuickProtobuf/qpb_encode.h"
#include "Tools/CSupport/ConversionSupport.h"

#if QPB_PROTO_HEADER_VERSION != 2
#error Regenerate this file with the current version of qpb generator.
#endif

#define F_0_1                0.1f
#define F_0_2                0.2f
#define F_0_5                0.5f
#define F_0_9                0.9f
#define F_10_0               10.0f

static inline void encode_InterfacesTest_TestAllTypesPointers32Bit_Raw_stringPointerValue(qpb_ostream_t *const stream, const char *const data);
static inline void encode_InterfacesTest_TestAllTypesPointers32Bit_Raw_bytesPointerValue(qpb_ostream_t *const stream, const qpb_bytes_pointer_t *const data);
static bool decode_InterfacesTest_TestAllTypesPointers32Bit_Raw_bytesPointerValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesPointers32Bit_Raw_stringPointerValueArray(qpb_ostream_t *const stream, const char *const arrayData[],const qpb_size_t arraySize);
static inline void encode_InterfacesTest_TestAllTypesPointers32Bit_Raw_bytesPointerValueArray(qpb_ostream_t *const stream, const qpb_bytes_pointer_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesPointers32Bit_Raw_bytesPointerValueArray(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw_subMessageInSubMessageBool(qpb_ostream_t *const stream, const bool *const data);
static bool decode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw_subMessageInSubMessageBool(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_SubSubMessage32Bit_Raw_subSubUint32(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_InterfacesTest_SubSubMessage32Bit_Raw_subSubUint32(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value16(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value8(qpb_ostream_t *const stream, const int8_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value16(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value8(qpb_ostream_t *const stream, const int8_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value16(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value8(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_boolValue(qpb_ostream_t *const stream, const bool *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_boolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_floatValue(qpb_ostream_t *const stream, const float *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_floatValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_stringValue(qpb_ostream_t *const stream, const char *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_stringValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_bytesValue(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypes32Bit_Raw_bytesValue_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_bytesValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_fixed32Value(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_fixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_sfixed32Value(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_sfixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_enumValue(qpb_ostream_t *const stream, const InterfacesTest_TestEnum32Bit *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_enumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_negEnumValue(qpb_ostream_t *const stream, const InterfacesTest_TestNegEnum32Bit *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_negEnumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_sint32Value(qpb_ostream_t *const stream, const float *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_sint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_sint32Value16(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_sint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_sint32Value8(qpb_ostream_t *const stream, const float *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_sint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_int32Value(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_int32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_int32Value16(qpb_ostream_t *const stream, const float *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_int32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_int32Value8(qpb_ostream_t *const stream, const int8_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_int32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_uint32Value(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_uint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_uint32Value16(qpb_ostream_t *const stream, const float *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_uint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_uint32Value8(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_uint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_boolValue(qpb_ostream_t *const stream, const bool *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_boolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_floatValue(qpb_ostream_t *const stream, const float *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_floatValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_stringValue(qpb_ostream_t *const stream, const char *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_stringValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_bytesValue(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypes32Bit_bytesValue_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_bytesValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_fixed32Value(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_fixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_sfixed32Value(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_sfixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_enumValue(qpb_ostream_t *const stream, const InterfacesTest_TestEnum32Bit *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_enumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes32Bit_negEnumValue(qpb_ostream_t *const stream, const InterfacesTest_TestNegEnum32Bit *const data);
static bool decode_InterfacesTest_TestAllTypes32Bit_negEnumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value16(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value8(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value16(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value8(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value(qpb_ostream_t *const stream, const uint32_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value16(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value8(qpb_ostream_t *const stream, const uint8_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_boolValue(qpb_ostream_t *const stream, const bool arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_boolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_floatValue(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_floatValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_stringValue(qpb_ostream_t *const stream, const char arrayData[10][10],const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_stringValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_bytesValue(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypesArray32Bit_Raw_bytesValue_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_bytesValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_fixed32Value(qpb_ostream_t *const stream, const uint32_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_fixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_sfixed32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_sfixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_enumValue(qpb_ostream_t *const stream, const InterfacesTest_TestEnum32Bit arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_enumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_negEnumValue(qpb_ostream_t *const stream, const InterfacesTest_TestNegEnum32Bit arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_negEnumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_sint32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_sint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_sint32Value16(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_sint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_sint32Value8(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_sint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_int32Value(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_int32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_int32Value16(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_int32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_int32Value8(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_int32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_uint32Value(qpb_ostream_t *const stream, const uint32_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_uint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_uint32Value16(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_uint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_uint32Value8(qpb_ostream_t *const stream, const uint8_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_uint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_boolValue(qpb_ostream_t *const stream, const bool arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_boolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_floatValue(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_floatValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_stringValue(qpb_ostream_t *const stream, const char arrayData[10][10],const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_stringValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_bytesValue(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypesArray32Bit_bytesValue_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_bytesValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_fixed32Value(qpb_ostream_t *const stream, const uint32_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_fixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_sfixed32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_sfixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_enumValue(qpb_ostream_t *const stream, const InterfacesTest_TestEnum32Bit arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_enumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray32Bit_negEnumValue(qpb_ostream_t *const stream, const InterfacesTest_TestNegEnum32Bit arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray32Bit_negEnumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw_messageInMessageSint32(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw_messageInMessageSint32(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw_subMessageInMessageInMessage(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw *const data);
static bool decode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw_subMessageInMessageInMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_SubMessage32Bit_Raw_subString(qpb_ostream_t *const stream, const char *const data);
static bool decode_InterfacesTest_SubMessage32Bit_Raw_subString(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_SubMessage32Bit_Raw_subSubMessage(qpb_ostream_t *const stream, const InterfacesTest_SubSubMessage32Bit_Raw *const data);
static bool decode_InterfacesTest_SubMessage32Bit_Raw_subSubMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_DeepSubMessage32Bit_Raw_subSint32Value(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_InterfacesTest_DeepSubMessage32Bit_Raw_subSint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_DeepSubMessage32Bit_Raw_subBoolValue(qpb_ostream_t *const stream, const bool *const data);
static bool decode_InterfacesTest_DeepSubMessage32Bit_Raw_subBoolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_DeepSubMessage32Bit_Raw_subMessage(qpb_ostream_t *const stream, const InterfacesTest_SubMessage32Bit_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_DeepSubMessage32Bit_Raw_subMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_DeepSubMessage32Bit_Raw_internalSubMessage(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw *const data);
static bool decode_InterfacesTest_DeepSubMessage32Bit_Raw_internalSubMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_DeepSubMessage32Bit_Raw_enumInMessageValue(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage32Bit_EnumInMessage32Bit *const data);
static bool decode_InterfacesTest_DeepSubMessage32Bit_Raw_enumInMessageValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_MainMessage32Bit_Raw_subMessage(qpb_ostream_t *const stream, const InterfacesTest_SubMessage32Bit_Raw *const data);
static bool decode_InterfacesTest_MainMessage32Bit_Raw_subMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_MainMessage32Bit_Raw_deepSubMessage(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage32Bit_Raw *const data);
static bool decode_InterfacesTest_MainMessage32Bit_Raw_deepSubMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);

#define InterfacesTest_TestAllTypesPointers32Bit_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t InterfacesTest_TestAllTypesPointers32Bit_Raw_decoders[InterfacesTest_TestAllTypesPointers32Bit_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypesPointers32Bit_Raw_bytesPointerValue },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypesPointers32Bit_Raw_bytesPointerValueArray }
};

#define InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw_DECODERS_COUNT 2
const qpb_decoder_entry_t InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw_decoders[InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw_subMessageInSubMessageBool }
};

#define InterfacesTest_SubSubMessage32Bit_Raw_DECODERS_COUNT 2
const qpb_decoder_entry_t InterfacesTest_SubSubMessage32Bit_Raw_decoders[InterfacesTest_SubSubMessage32Bit_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_SubSubMessage32Bit_Raw_subSubUint32 }
};

#define InterfacesTest_TestAllTypes32Bit_Raw_DECODERS_COUNT 24
const qpb_decoder_entry_t InterfacesTest_TestAllTypes32Bit_Raw_decoders[InterfacesTest_TestAllTypes32Bit_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value },
   { &decode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value16 },
   { &decode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value8 },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value },
   { &decode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value16 },
   { &decode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value8 },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value },
   { &decode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value16 },
   { &decode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value8 },
   { &decode_InterfacesTest_TestAllTypes32Bit_Raw_boolValue },
   { &decode_InterfacesTest_TestAllTypes32Bit_Raw_floatValue },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypes32Bit_Raw_stringValue },
   { &decode_InterfacesTest_TestAllTypes32Bit_Raw_bytesValue },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypes32Bit_Raw_fixed32Value },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypes32Bit_Raw_sfixed32Value },
   { &decode_InterfacesTest_TestAllTypes32Bit_Raw_enumValue },
   { &decode_InterfacesTest_TestAllTypes32Bit_Raw_negEnumValue }
};

#define InterfacesTest_TestAllTypes32Bit_DECODERS_COUNT 24
const qpb_decoder_entry_t InterfacesTest_TestAllTypes32Bit_decoders[InterfacesTest_TestAllTypes32Bit_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypes32Bit_sint32Value },
   { &decode_InterfacesTest_TestAllTypes32Bit_sint32Value16 },
   { &decode_InterfacesTest_TestAllTypes32Bit_sint32Value8 },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypes32Bit_int32Value },
   { &decode_InterfacesTest_TestAllTypes32Bit_int32Value16 },
   { &decode_InterfacesTest_TestAllTypes32Bit_int32Value8 },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypes32Bit_uint32Value },
   { &decode_InterfacesTest_TestAllTypes32Bit_uint32Value16 },
   { &decode_InterfacesTest_TestAllTypes32Bit_uint32Value8 },
   { &decode_InterfacesTest_TestAllTypes32Bit_boolValue },
   { &decode_InterfacesTest_TestAllTypes32Bit_floatValue },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypes32Bit_stringValue },
   { &decode_InterfacesTest_TestAllTypes32Bit_bytesValue },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypes32Bit_fixed32Value },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypes32Bit_sfixed32Value },
   { &decode_InterfacesTest_TestAllTypes32Bit_enumValue },
   { &decode_InterfacesTest_TestAllTypes32Bit_negEnumValue }
};

#define InterfacesTest_TestAllTypesArray32Bit_Raw_DECODERS_COUNT 24
const qpb_decoder_entry_t InterfacesTest_TestAllTypesArray32Bit_Raw_decoders[InterfacesTest_TestAllTypesArray32Bit_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value16 },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value8 },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value16 },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value8 },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value16 },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value8 },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_Raw_boolValue },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_Raw_floatValue },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_Raw_stringValue },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_Raw_bytesValue },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_Raw_fixed32Value },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_Raw_sfixed32Value },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_Raw_enumValue },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_Raw_negEnumValue }
};

#define InterfacesTest_TestAllTypesArray32Bit_DECODERS_COUNT 24
const qpb_decoder_entry_t InterfacesTest_TestAllTypesArray32Bit_decoders[InterfacesTest_TestAllTypesArray32Bit_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_sint32Value },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_sint32Value16 },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_sint32Value8 },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_int32Value },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_int32Value16 },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_int32Value8 },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_uint32Value },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_uint32Value16 },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_uint32Value8 },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_boolValue },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_floatValue },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_stringValue },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_bytesValue },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_fixed32Value },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_sfixed32Value },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_enumValue },
   { &decode_InterfacesTest_TestAllTypesArray32Bit_negEnumValue }
};

#define InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw_decoders[InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw_messageInMessageSint32 },
   { &decode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw_subMessageInMessageInMessage }
};

#define InterfacesTest_SubMessage32Bit_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t InterfacesTest_SubMessage32Bit_Raw_decoders[InterfacesTest_SubMessage32Bit_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_SubMessage32Bit_Raw_subString },
   { &decode_InterfacesTest_SubMessage32Bit_Raw_subSubMessage }
};

#define InterfacesTest_DeepSubMessage32Bit_Raw_DECODERS_COUNT 8
const qpb_decoder_entry_t InterfacesTest_DeepSubMessage32Bit_Raw_decoders[InterfacesTest_DeepSubMessage32Bit_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_DeepSubMessage32Bit_Raw_subSint32Value },
   { &decode_InterfacesTest_DeepSubMessage32Bit_Raw_subBoolValue },
   { &qpb_skip_field },
   { &qpb_skip_field },
   { &decode_InterfacesTest_DeepSubMessage32Bit_Raw_subMessage },
   { &decode_InterfacesTest_DeepSubMessage32Bit_Raw_internalSubMessage },
   { &decode_InterfacesTest_DeepSubMessage32Bit_Raw_enumInMessageValue }
};

#define InterfacesTest_MainMessage32Bit_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t InterfacesTest_MainMessage32Bit_Raw_decoders[InterfacesTest_MainMessage32Bit_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_MainMessage32Bit_Raw_subMessage },
   { &decode_InterfacesTest_MainMessage32Bit_Raw_deepSubMessage }
};

static inline void encode_InterfacesTest_TestAllTypesPointers32Bit_Raw_stringPointerValue(qpb_ostream_t *const stream, const char *const data)
{
   qpb_size_t strSize = (data != 0 ? strlen(data) : 0);
   if (strSize != 0)
   {
      *stream->buffer = 10;
      ++stream->buffer;
      qpb_encode_bytes(stream, (qpb_byte_t*)data, strSize);
   }
}

static inline void encode_InterfacesTest_TestAllTypesPointers32Bit_Raw_bytesPointerValue(qpb_ostream_t *const stream, const qpb_bytes_pointer_t *const data)
{
   if (data->size != 0)
   {
      *stream->buffer = 18;
      ++stream->buffer;
      qpb_encode_bytes(stream, data->bytes, data->size);
   }
}

static bool decode_InterfacesTest_TestAllTypesPointers32Bit_Raw_bytesPointerValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_bytes_pointer(stream, &((InterfacesTest_TestAllTypesPointers32Bit_Raw*)data)->bytesPointerValue);
}

static inline void encode_InterfacesTest_TestAllTypesPointers32Bit_Raw_stringPointerValueArray(qpb_ostream_t *const stream, const char *const arrayData[],const qpb_size_t arraySize)
{
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      *stream->buffer = 26;
      ++stream->buffer;
      const char *const data = arrayData[i];
      qpb_encode_bytes(stream, (qpb_byte_t*)data, (data != 0 ? strlen(data) : 0));
   }
}

static inline void encode_InterfacesTest_TestAllTypesPointers32Bit_Raw_bytesPointerValueArray(qpb_ostream_t *const stream, const qpb_bytes_pointer_t arrayData[], const qpb_size_t arraySize)
{
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      *stream->buffer = 34;
      ++stream->buffer;
      const qpb_bytes_pointer_t *const data = &arrayData[i];
      qpb_encode_bytes(stream, data->bytes, data->size);
   }
}

static bool decode_InterfacesTest_TestAllTypesPointers32Bit_Raw_bytesPointerValueArray(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((InterfacesTest_TestAllTypesPointers32Bit_Raw*)data)->bytesPointerValueArray_count + 1) > 5)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   return qpb_decode_bytes_pointer(stream, &((InterfacesTest_TestAllTypesPointers32Bit_Raw*)data)->bytesPointerValueArray[((InterfacesTest_TestAllTypesPointers32Bit_Raw*)data)->bytesPointerValueArray_count++]);
}

static inline void encode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw_subMessageInSubMessageBool(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw_subMessageInSubMessageBool(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw*)data)->subMessageInSubMessageBool, sizeof(bool));
}

static inline void encode_InterfacesTest_SubSubMessage32Bit_Raw_subSubUint32(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_InterfacesTest_SubSubMessage32Bit_Raw_subSubUint32(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((InterfacesTest_SubSubMessage32Bit_Raw*)data)->subSubUint32, sizeof(uint32_t));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit_Raw*)data)->sint32Value, sizeof(int32_t));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value16(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit_Raw*)data)->sint32Value16, sizeof(int16_t));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value8(qpb_ostream_t *const stream, const int8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit_Raw*)data)->sint32Value8, sizeof(int8_t));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit_Raw*)data)->int32Value, sizeof(int32_t));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value16(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit_Raw*)data)->int32Value16, sizeof(int16_t));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value8(qpb_ostream_t *const stream, const int8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit_Raw*)data)->int32Value8, sizeof(int8_t));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 80;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit_Raw*)data)->uint32Value, sizeof(uint32_t));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value16(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 88;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit_Raw*)data)->uint32Value16, sizeof(uint16_t));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value8(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 96;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit_Raw*)data)->uint32Value8, sizeof(uint8_t));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_boolValue(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 104;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_boolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit_Raw*)data)->boolValue, sizeof(bool));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_floatValue(qpb_ostream_t *const stream, const float *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 117;
      ++stream->buffer;
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_floatValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypes32Bit_Raw*)data)->floatValue);
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_stringValue(qpb_ostream_t *const stream, const char *const data)
{
   qpb_size_t strSize = strlen(data);
   if (strSize != 0)
   {
      qpb_encode_varint(stream, 130);
      qpb_encode_bytes(stream, (qpb_byte_t*)data, strSize);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_stringValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_string_static(stream, ((InterfacesTest_TestAllTypes32Bit_Raw*)data)->stringValue, 9);
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_bytesValue(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypes32Bit_Raw_bytesValue_t *const data)
{
   if (data->size != 0)
   {
      qpb_encode_varint(stream, 138);
      qpb_encode_bytes(stream, data->bytes, data->size);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_bytesValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_bytes_static(stream, (qpb_bytes_array_t*)&((InterfacesTest_TestAllTypes32Bit_Raw*)data)->bytesValue, 10);
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_fixed32Value(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 157);
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_fixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypes32Bit_Raw*)data)->fixed32Value);
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_sfixed32Value(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 173);
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_sfixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypes32Bit_Raw*)data)->sfixed32Value);
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_enumValue(qpb_ostream_t *const stream, const InterfacesTest_TestEnum32Bit *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 176);
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_enumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit_Raw*)data)->enumValue, qpb_membersize(InterfacesTest_TestAllTypes32Bit_Raw, enumValue));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_Raw_negEnumValue(qpb_ostream_t *const stream, const InterfacesTest_TestNegEnum32Bit *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 184);
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_Raw_negEnumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   qpb_int64_t value;
   bool result;
   QPB_UNUSED(wiretype);
   result = qpb_decode_varint(stream, &value, sizeof(qpb_int64_t));
   if (result)
   {
#ifndef QPB_WITHOUT_64BIT
      /* Protobuf only supports int32 values for enums */
      result = INT32_MIN <= value && value <= INT32_MAX;
      if (result)
      {
         ((InterfacesTest_TestAllTypes32Bit_Raw*)data)->negEnumValue = (InterfacesTest_TestNegEnum32Bit)value;
      }
#else
      ((InterfacesTest_TestAllTypes32Bit_Raw*)data)->negEnumValue = (InterfacesTest_TestNegEnum32Bit)value;
#endif
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_sint32Value(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_1, INT32_MIN, INT32_MAX);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value(stream, &value);
}

static bool decode_InterfacesTest_TestAllTypes32Bit_sint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((InterfacesTest_TestAllTypes32Bit*)data)->sint32Value = value * F_0_1;
   return result;
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_sint32Value16(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_sint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit*)data)->sint32Value16, sizeof(int16_t));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_sint32Value8(qpb_ostream_t *const stream, const float *const data)
{
   int8_t value = (int8_t)convertToInt32(*data, F_0_2, INT8_MIN, INT8_MAX);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value8(stream, &value);
}

static bool decode_InterfacesTest_TestAllTypes32Bit_sint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int8_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int8_t));
   ((InterfacesTest_TestAllTypes32Bit*)data)->sint32Value8 = value * F_0_2;
   return result;
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_int32Value(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_int32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit*)data)->int32Value, sizeof(int32_t));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_int32Value16(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_10_0, INT16_MIN, INT16_MAX);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value16(stream, &value);
}

static bool decode_InterfacesTest_TestAllTypes32Bit_int32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_varint(stream, (void*)&value, sizeof(int16_t));
   ((InterfacesTest_TestAllTypes32Bit*)data)->int32Value16 = value * F_10_0;
   return result;
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_int32Value8(qpb_ostream_t *const stream, const int8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_int32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit*)data)->int32Value8, sizeof(int8_t));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_uint32Value(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 80;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_uint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit*)data)->uint32Value, sizeof(uint32_t));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_uint32Value16(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_5, 0, UINT16_MAX);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value16(stream, &value);
}

static bool decode_InterfacesTest_TestAllTypes32Bit_uint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((InterfacesTest_TestAllTypes32Bit*)data)->uint32Value16 = value * F_0_5;
   return result;
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_uint32Value8(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 96;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_uint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit*)data)->uint32Value8, sizeof(uint8_t));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_boolValue(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 104;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_boolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit*)data)->boolValue, sizeof(bool));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_floatValue(qpb_ostream_t *const stream, const float *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 117;
      ++stream->buffer;
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_floatValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypes32Bit*)data)->floatValue);
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_stringValue(qpb_ostream_t *const stream, const char *const data)
{
   qpb_size_t strSize = strlen(data);
   if (strSize != 0)
   {
      qpb_encode_varint(stream, 130);
      qpb_encode_bytes(stream, (qpb_byte_t*)data, strSize);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_stringValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_string_static(stream, ((InterfacesTest_TestAllTypes32Bit*)data)->stringValue, 9);
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_bytesValue(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypes32Bit_bytesValue_t *const data)
{
   if (data->size != 0)
   {
      qpb_encode_varint(stream, 138);
      qpb_encode_bytes(stream, data->bytes, data->size);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_bytesValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_bytes_static(stream, (qpb_bytes_array_t*)&((InterfacesTest_TestAllTypes32Bit*)data)->bytesValue, 10);
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_fixed32Value(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 157);
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_fixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypes32Bit*)data)->fixed32Value);
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_sfixed32Value(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 173);
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_sfixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypes32Bit*)data)->sfixed32Value);
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_enumValue(qpb_ostream_t *const stream, const InterfacesTest_TestEnum32Bit *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 176);
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_enumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes32Bit*)data)->enumValue, qpb_membersize(InterfacesTest_TestAllTypes32Bit, enumValue));
}

static inline void encode_InterfacesTest_TestAllTypes32Bit_negEnumValue(qpb_ostream_t *const stream, const InterfacesTest_TestNegEnum32Bit *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 184);
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes32Bit_negEnumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   qpb_int64_t value;
   bool result;
   QPB_UNUSED(wiretype);
   result = qpb_decode_varint(stream, &value, sizeof(qpb_int64_t));
   if (result)
   {
#ifndef QPB_WITHOUT_64BIT
      /* Protobuf only supports int32 values for enums */
      result = INT32_MIN <= value && value <= INT32_MAX;
      if (result)
      {
         ((InterfacesTest_TestAllTypes32Bit*)data)->negEnumValue = (InterfacesTest_TestNegEnum32Bit)value;
      }
#else
      ((InterfacesTest_TestAllTypes32Bit*)data)->negEnumValue = (InterfacesTest_TestNegEnum32Bit)value;
#endif
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 18;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value_count++], sizeof(int32_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value_count++], sizeof(int32_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value16(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 26;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value16_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value16[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value16_count++], sizeof(int16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value16_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value16[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value16_count++], sizeof(int16_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value8(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 34;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value8_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value8[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value8_count++], sizeof(int8_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value8_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value8[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sint32Value8_count++], sizeof(int8_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 50;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value_count++], sizeof(int32_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value_count++], sizeof(int32_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value16(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 58;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value16_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value16[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value16_count++], sizeof(int16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value16_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value16[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value16_count++], sizeof(int16_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value8(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 66;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value8_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value8[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value8_count++], sizeof(int8_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value8_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value8[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->int32Value8_count++], sizeof(int8_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value(qpb_ostream_t *const stream, const uint32_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 82;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value_count++], sizeof(uint32_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value_count++], sizeof(uint32_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value16(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 90;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value16_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value16[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value16_count++], sizeof(uint16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value16_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value16[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value16_count++], sizeof(uint16_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value8(qpb_ostream_t *const stream, const uint8_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 98;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value8_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value8[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value8_count++], sizeof(uint8_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value8_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value8[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->uint32Value8_count++], sizeof(uint8_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_boolValue(qpb_ostream_t *const stream, const bool arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 106;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_boolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->boolValue_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->boolValue[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->boolValue_count++], sizeof(bool));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->boolValue_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->boolValue[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->boolValue_count++], sizeof(bool));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_floatValue(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 114;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed32(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_floatValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->floatValue_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->floatValue[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->floatValue_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->floatValue_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->floatValue[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->floatValue_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_stringValue(qpb_ostream_t *const stream, const char arrayData[10][10],const qpb_size_t arraySize)
{
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      qpb_encode_varint(stream, 130);
      const char *const data = &arrayData[i][0];
      qpb_encode_bytes(stream, (qpb_byte_t*)data, strlen(data));
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_stringValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->stringValue_count + 1) > 5)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   return qpb_decode_string_static(stream, ((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->stringValue[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->stringValue_count++], 9);
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_bytesValue(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypesArray32Bit_Raw_bytesValue_t arrayData[], const qpb_size_t arraySize)
{
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      qpb_encode_varint(stream, 138);
      const InterfacesTest_TestAllTypesArray32Bit_Raw_bytesValue_t *const data = &arrayData[i];
      qpb_encode_bytes(stream, data->bytes, data->size);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_bytesValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->bytesValue_count + 1) > 5)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   return qpb_decode_bytes_static(stream, (qpb_bytes_array_t*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->bytesValue[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->bytesValue_count++], 10);
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_fixed32Value(qpb_ostream_t *const stream, const uint32_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 154);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed32(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_fixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->fixed32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->fixed32Value[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->fixed32Value_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->fixed32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->fixed32Value[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->fixed32Value_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_sfixed32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 170);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed32(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_sfixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sfixed32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sfixed32Value[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sfixed32Value_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sfixed32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sfixed32Value[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->sfixed32Value_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_enumValue(qpb_ostream_t *const stream, const InterfacesTest_TestEnum32Bit arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 178);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_enumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->enumValue_count + 1 > 3)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->enumValue[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->enumValue_count++], qpb_membersize(InterfacesTest_TestAllTypesArray32Bit_Raw, enumValue[0]));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->enumValue_count + 1) > 3)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->enumValue[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->enumValue_count++], qpb_membersize(InterfacesTest_TestAllTypesArray32Bit_Raw, enumValue[0]));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_Raw_negEnumValue(qpb_ostream_t *const stream, const InterfacesTest_TestNegEnum32Bit arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 186);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw_negEnumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->negEnumValue_count + 1 > 3)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         qpb_int64_t value;
         result = qpb_decode_varint(stream, &value, sizeof(qpb_int64_t));
         if (result)
         {
#ifndef QPB_WITHOUT_64BIT
            /* Protobuf only supports int32 values for enums */
            result = INT32_MIN <= value && value <= INT32_MAX;
            if (result)
            {
               ((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->negEnumValue[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->negEnumValue_count++] = (InterfacesTest_TestNegEnum32Bit)value;
            }
#else
            ((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->negEnumValue[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->negEnumValue_count++] = (InterfacesTest_TestNegEnum32Bit)value;
#endif
         }
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->negEnumValue_count + 1) > 3)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      qpb_int64_t value;
      result = qpb_decode_varint(stream, &value, sizeof(qpb_int64_t));
      if (result)
      {
#ifndef QPB_WITHOUT_64BIT
         /* Protobuf only supports int32 values for enums */
         result = INT32_MIN <= value && value <= INT32_MAX;
         if (result)
         {
            ((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->negEnumValue[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->negEnumValue_count++] = (InterfacesTest_TestNegEnum32Bit)value;
         }
#else
         ((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->negEnumValue[((InterfacesTest_TestAllTypesArray32Bit_Raw*)data)->negEnumValue_count++] = (InterfacesTest_TestNegEnum32Bit)value;
#endif
      }
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_sint32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 18;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_sint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value[((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value_count++], sizeof(int32_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value[((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value_count++], sizeof(int32_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_sint32Value16(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 26;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_sint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value16_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value16[((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value16_count++], sizeof(int16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value16_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value16[((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value16_count++], sizeof(int16_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_sint32Value8(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 34;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_sint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value8_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value8[((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value8_count++], sizeof(int8_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value8_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value8[((InterfacesTest_TestAllTypesArray32Bit*)data)->sint32Value8_count++], sizeof(int8_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_int32Value(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   int32_t values[5];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (int32_t)convertToInt32(arrayData[i], F_0_9, INT32_MIN, INT32_MAX);
   }
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value(stream, values, arraySize);
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_int32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         int32_t value;
         result = qpb_decode_varint(stream, (void*)&value, sizeof(int32_t));
         ((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value[((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value_count++] = value * F_0_9;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      int32_t value;
      result = qpb_decode_varint(stream, (void*)&value, sizeof(int32_t));
      ((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value[((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value_count++] = value * F_0_9;
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_int32Value16(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 58;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_int32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value16_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value16[((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value16_count++], sizeof(int16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value16_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value16[((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value16_count++], sizeof(int16_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_int32Value8(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 66;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_int32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value8_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value8[((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value8_count++], sizeof(int8_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value8_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value8[((InterfacesTest_TestAllTypesArray32Bit*)data)->int32Value8_count++], sizeof(int8_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_uint32Value(qpb_ostream_t *const stream, const uint32_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 82;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_uint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value[((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value_count++], sizeof(uint32_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value[((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value_count++], sizeof(uint32_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_uint32Value16(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 90;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_uint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value16_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value16[((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value16_count++], sizeof(uint16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value16_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value16[((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value16_count++], sizeof(uint16_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_uint32Value8(qpb_ostream_t *const stream, const uint8_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 98;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_uint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value8_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value8[((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value8_count++], sizeof(uint8_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value8_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value8[((InterfacesTest_TestAllTypesArray32Bit*)data)->uint32Value8_count++], sizeof(uint8_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_boolValue(qpb_ostream_t *const stream, const bool arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 106;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_boolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit*)data)->boolValue_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->boolValue[((InterfacesTest_TestAllTypesArray32Bit*)data)->boolValue_count++], sizeof(bool));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit*)data)->boolValue_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->boolValue[((InterfacesTest_TestAllTypesArray32Bit*)data)->boolValue_count++], sizeof(bool));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_floatValue(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 114;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed32(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_floatValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit*)data)->floatValue_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->floatValue[((InterfacesTest_TestAllTypesArray32Bit*)data)->floatValue_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit*)data)->floatValue_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->floatValue[((InterfacesTest_TestAllTypesArray32Bit*)data)->floatValue_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_stringValue(qpb_ostream_t *const stream, const char arrayData[10][10],const qpb_size_t arraySize)
{
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      qpb_encode_varint(stream, 130);
      const char *const data = &arrayData[i][0];
      qpb_encode_bytes(stream, (qpb_byte_t*)data, strlen(data));
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_stringValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((InterfacesTest_TestAllTypesArray32Bit*)data)->stringValue_count + 1) > 5)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   return qpb_decode_string_static(stream, ((InterfacesTest_TestAllTypesArray32Bit*)data)->stringValue[((InterfacesTest_TestAllTypesArray32Bit*)data)->stringValue_count++], 9);
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_bytesValue(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypesArray32Bit_bytesValue_t arrayData[], const qpb_size_t arraySize)
{
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      qpb_encode_varint(stream, 138);
      const InterfacesTest_TestAllTypesArray32Bit_bytesValue_t *const data = &arrayData[i];
      qpb_encode_bytes(stream, data->bytes, data->size);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_bytesValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((InterfacesTest_TestAllTypesArray32Bit*)data)->bytesValue_count + 1) > 5)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   return qpb_decode_bytes_static(stream, (qpb_bytes_array_t*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->bytesValue[((InterfacesTest_TestAllTypesArray32Bit*)data)->bytesValue_count++], 10);
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_fixed32Value(qpb_ostream_t *const stream, const uint32_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 154);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed32(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_fixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit*)data)->fixed32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->fixed32Value[((InterfacesTest_TestAllTypesArray32Bit*)data)->fixed32Value_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit*)data)->fixed32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->fixed32Value[((InterfacesTest_TestAllTypesArray32Bit*)data)->fixed32Value_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_sfixed32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 170);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed32(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_sfixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit*)data)->sfixed32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->sfixed32Value[((InterfacesTest_TestAllTypesArray32Bit*)data)->sfixed32Value_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit*)data)->sfixed32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->sfixed32Value[((InterfacesTest_TestAllTypesArray32Bit*)data)->sfixed32Value_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_enumValue(qpb_ostream_t *const stream, const InterfacesTest_TestEnum32Bit arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 178);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_enumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit*)data)->enumValue_count + 1 > 3)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->enumValue[((InterfacesTest_TestAllTypesArray32Bit*)data)->enumValue_count++], qpb_membersize(InterfacesTest_TestAllTypesArray32Bit, enumValue[0]));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit*)data)->enumValue_count + 1) > 3)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray32Bit*)data)->enumValue[((InterfacesTest_TestAllTypesArray32Bit*)data)->enumValue_count++], qpb_membersize(InterfacesTest_TestAllTypesArray32Bit, enumValue[0]));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray32Bit_negEnumValue(qpb_ostream_t *const stream, const InterfacesTest_TestNegEnum32Bit arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 186);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray32Bit_negEnumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray32Bit*)data)->negEnumValue_count + 1 > 3)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         qpb_int64_t value;
         result = qpb_decode_varint(stream, &value, sizeof(qpb_int64_t));
         if (result)
         {
#ifndef QPB_WITHOUT_64BIT
            /* Protobuf only supports int32 values for enums */
            result = INT32_MIN <= value && value <= INT32_MAX;
            if (result)
            {
               ((InterfacesTest_TestAllTypesArray32Bit*)data)->negEnumValue[((InterfacesTest_TestAllTypesArray32Bit*)data)->negEnumValue_count++] = (InterfacesTest_TestNegEnum32Bit)value;
            }
#else
            ((InterfacesTest_TestAllTypesArray32Bit*)data)->negEnumValue[((InterfacesTest_TestAllTypesArray32Bit*)data)->negEnumValue_count++] = (InterfacesTest_TestNegEnum32Bit)value;
#endif
         }
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray32Bit*)data)->negEnumValue_count + 1) > 3)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      qpb_int64_t value;
      result = qpb_decode_varint(stream, &value, sizeof(qpb_int64_t));
      if (result)
      {
#ifndef QPB_WITHOUT_64BIT
         /* Protobuf only supports int32 values for enums */
         result = INT32_MIN <= value && value <= INT32_MAX;
         if (result)
         {
            ((InterfacesTest_TestAllTypesArray32Bit*)data)->negEnumValue[((InterfacesTest_TestAllTypesArray32Bit*)data)->negEnumValue_count++] = (InterfacesTest_TestNegEnum32Bit)value;
         }
#else
         ((InterfacesTest_TestAllTypesArray32Bit*)data)->negEnumValue[((InterfacesTest_TestAllTypesArray32Bit*)data)->negEnumValue_count++] = (InterfacesTest_TestNegEnum32Bit)value;
#endif
      }
   }
   return result;
}

static inline void encode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw_messageInMessageSint32(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw_messageInMessageSint32(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw*)data)->messageInMessageSint32, sizeof(int32_t));
}

static inline void encode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw_subMessageInMessageInMessage(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw_subMessageInMessageInMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw(&substream, &((InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw*)data)->subMessageInMessageInMessage);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_InterfacesTest_SubMessage32Bit_Raw_subString(qpb_ostream_t *const stream, const char *const data)
{
   qpb_size_t strSize = strlen(data);
   if (strSize != 0)
   {
      *stream->buffer = 10;
      ++stream->buffer;
      qpb_encode_bytes(stream, (qpb_byte_t*)data, strSize);
   }
}

static bool decode_InterfacesTest_SubMessage32Bit_Raw_subString(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_string_static(stream, ((InterfacesTest_SubMessage32Bit_Raw*)data)->subString, 19);
}

static inline void encode_InterfacesTest_SubMessage32Bit_Raw_subSubMessage(qpb_ostream_t *const stream, const InterfacesTest_SubSubMessage32Bit_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_InterfacesTest_SubSubMessage32Bit_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_InterfacesTest_SubMessage32Bit_Raw_subSubMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_InterfacesTest_SubSubMessage32Bit_Raw(&substream, &((InterfacesTest_SubMessage32Bit_Raw*)data)->subSubMessage);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_InterfacesTest_DeepSubMessage32Bit_Raw_subSint32Value(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_InterfacesTest_DeepSubMessage32Bit_Raw_subSint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((InterfacesTest_DeepSubMessage32Bit_Raw*)data)->subSint32Value, sizeof(int32_t));
}

static inline void encode_InterfacesTest_DeepSubMessage32Bit_Raw_subBoolValue(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_DeepSubMessage32Bit_Raw_subBoolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_DeepSubMessage32Bit_Raw*)data)->subBoolValue, sizeof(bool));
}

static inline void encode_InterfacesTest_DeepSubMessage32Bit_Raw_subMessage(qpb_ostream_t *const stream, const InterfacesTest_SubMessage32Bit_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 42;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_InterfacesTest_SubMessage32Bit_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_InterfacesTest_DeepSubMessage32Bit_Raw_subMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((InterfacesTest_DeepSubMessage32Bit_Raw*)data)->subMessage_count + 1) > 8)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_InterfacesTest_SubMessage32Bit_Raw(&substream, &((InterfacesTest_DeepSubMessage32Bit_Raw*)data)->subMessage[((InterfacesTest_DeepSubMessage32Bit_Raw*)data)->subMessage_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_InterfacesTest_DeepSubMessage32Bit_Raw_internalSubMessage(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 50;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_InterfacesTest_DeepSubMessage32Bit_Raw_internalSubMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw(&substream, &((InterfacesTest_DeepSubMessage32Bit_Raw*)data)->internalSubMessage);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_InterfacesTest_DeepSubMessage32Bit_Raw_enumInMessageValue(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage32Bit_EnumInMessage32Bit *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_DeepSubMessage32Bit_Raw_enumInMessageValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_DeepSubMessage32Bit_Raw*)data)->enumInMessageValue, qpb_membersize(InterfacesTest_DeepSubMessage32Bit_Raw, enumInMessageValue));
}

static inline void encode_InterfacesTest_MainMessage32Bit_Raw_subMessage(qpb_ostream_t *const stream, const InterfacesTest_SubMessage32Bit_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_InterfacesTest_SubMessage32Bit_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_InterfacesTest_MainMessage32Bit_Raw_subMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_InterfacesTest_SubMessage32Bit_Raw(&substream, &((InterfacesTest_MainMessage32Bit_Raw*)data)->subMessage);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_InterfacesTest_MainMessage32Bit_Raw_deepSubMessage(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage32Bit_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_InterfacesTest_DeepSubMessage32Bit_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_InterfacesTest_MainMessage32Bit_Raw_deepSubMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_InterfacesTest_DeepSubMessage32Bit_Raw(&substream, &((InterfacesTest_MainMessage32Bit_Raw*)data)->deepSubMessage);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

/* Encoding / decoding functions */
bool encode_InterfacesTest_TestAllTypesPointers32Bit_Raw(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypesPointers32Bit_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < (InterfacesTest_TestAllTypesPointers32Bit_static_size + (data->stringPointerValue != 0 ? strlen(data->stringPointerValue) + qpb_varint_max(strlen(data->stringPointerValue)) : 0) + (data->bytesPointerValue.size + qpb_varint_max(data->bytesPointerValue.size)) + (data->stringPointerValueArray[0] != 0 ? strlen(data->stringPointerValueArray[0]) + qpb_varint_max(strlen(data->stringPointerValueArray[0])) : 0) + (data->stringPointerValueArray[1] != 0 ? strlen(data->stringPointerValueArray[1]) + qpb_varint_max(strlen(data->stringPointerValueArray[1])) : 0) + (data->stringPointerValueArray[2] != 0 ? strlen(data->stringPointerValueArray[2]) + qpb_varint_max(strlen(data->stringPointerValueArray[2])) : 0) + (data->stringPointerValueArray[3] != 0 ? strlen(data->stringPointerValueArray[3]) + qpb_varint_max(strlen(data->stringPointerValueArray[3])) : 0) + (data->stringPointerValueArray[4] != 0 ? strlen(data->stringPointerValueArray[4]) + qpb_varint_max(strlen(data->stringPointerValueArray[4])) : 0) + (data->bytesPointerValueArray[0].size + qpb_varint_max(data->bytesPointerValueArray[0].size)) + (data->bytesPointerValueArray[1].size + qpb_varint_max(data->bytesPointerValueArray[1].size)) + (data->bytesPointerValueArray[2].size + qpb_varint_max(data->bytesPointerValueArray[2].size)) + (data->bytesPointerValueArray[3].size + qpb_varint_max(data->bytesPointerValueArray[3].size)) + (data->bytesPointerValueArray[4].size + qpb_varint_max(data->bytesPointerValueArray[4].size))))
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_TestAllTypesPointers32Bit_Raw_stringPointerValue(stream, data->stringPointerValue);
   encode_InterfacesTest_TestAllTypesPointers32Bit_Raw_bytesPointerValue(stream, &data->bytesPointerValue);
   encode_InterfacesTest_TestAllTypesPointers32Bit_Raw_stringPointerValueArray(stream, data->stringPointerValueArray, data->stringPointerValueArray_count);
   encode_InterfacesTest_TestAllTypesPointers32Bit_Raw_bytesPointerValueArray(stream, data->bytesPointerValueArray, data->bytesPointerValueArray_count);
   return true;
}

bool decode_InterfacesTest_TestAllTypesPointers32Bit_Raw(qpb_istream_t *const stream, InterfacesTest_TestAllTypesPointers32Bit_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_TestAllTypesPointers32Bit_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_TestAllTypesPointers32Bit_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw_subMessageInSubMessageBool(stream, &data->subMessageInSubMessageBool);
   return true;
}

bool decode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw(qpb_istream_t *const stream, InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_SubMessageInSubMessage32Bit_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_SubSubMessage32Bit_Raw(qpb_ostream_t *const stream, const InterfacesTest_SubSubMessage32Bit_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_SubSubMessage32Bit_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_SubSubMessage32Bit_Raw_subSubUint32(stream, &data->subSubUint32);
   return true;
}

bool decode_InterfacesTest_SubSubMessage32Bit_Raw(qpb_istream_t *const stream, InterfacesTest_SubSubMessage32Bit_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_SubSubMessage32Bit_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_SubSubMessage32Bit_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_TestAllTypes32Bit_Raw(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypes32Bit_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_TestAllTypes32Bit_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value(stream, &data->sint32Value);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value16(stream, &data->sint32Value16);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value8(stream, &data->sint32Value8);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value(stream, &data->int32Value);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value16(stream, &data->int32Value16);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value8(stream, &data->int32Value8);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value(stream, &data->uint32Value);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value16(stream, &data->uint32Value16);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value8(stream, &data->uint32Value8);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_boolValue(stream, &data->boolValue);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_floatValue(stream, &data->floatValue);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_stringValue(stream, data->stringValue);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_bytesValue(stream, &data->bytesValue);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_fixed32Value(stream, &data->fixed32Value);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_sfixed32Value(stream, &data->sfixed32Value);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_enumValue(stream, &data->enumValue);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_negEnumValue(stream, &data->negEnumValue);
   return true;
}

bool decode_InterfacesTest_TestAllTypes32Bit_Raw(qpb_istream_t *const stream, InterfacesTest_TestAllTypes32Bit_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_TestAllTypes32Bit_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_TestAllTypes32Bit_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_TestAllTypes32Bit(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypes32Bit *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_TestAllTypes32Bit_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_TestAllTypes32Bit_sint32Value(stream, &data->sint32Value);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_sint32Value16(stream, &data->sint32Value16);
   encode_InterfacesTest_TestAllTypes32Bit_sint32Value8(stream, &data->sint32Value8);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value(stream, &data->int32Value);
   encode_InterfacesTest_TestAllTypes32Bit_int32Value16(stream, &data->int32Value16);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_int32Value8(stream, &data->int32Value8);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value(stream, &data->uint32Value);
   encode_InterfacesTest_TestAllTypes32Bit_uint32Value16(stream, &data->uint32Value16);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_uint32Value8(stream, &data->uint32Value8);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_boolValue(stream, &data->boolValue);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_floatValue(stream, &data->floatValue);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_stringValue(stream, data->stringValue);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_bytesValue(stream, &data->bytesValue);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_fixed32Value(stream, &data->fixed32Value);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_sfixed32Value(stream, &data->sfixed32Value);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_enumValue(stream, &data->enumValue);
   encode_InterfacesTest_TestAllTypes32Bit_Raw_negEnumValue(stream, &data->negEnumValue);
   return true;
}

bool decode_InterfacesTest_TestAllTypes32Bit(qpb_istream_t *const stream, InterfacesTest_TestAllTypes32Bit *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_TestAllTypes32Bit_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_TestAllTypes32Bit_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_TestAllTypesArray32Bit_Raw(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypesArray32Bit_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_TestAllTypesArray32Bit_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value(stream, data->sint32Value, data->sint32Value_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value16(stream, data->sint32Value16, data->sint32Value16_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value8(stream, data->sint32Value8, data->sint32Value8_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value(stream, data->int32Value, data->int32Value_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value16(stream, data->int32Value16, data->int32Value16_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value8(stream, data->int32Value8, data->int32Value8_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value(stream, data->uint32Value, data->uint32Value_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value16(stream, data->uint32Value16, data->uint32Value16_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value8(stream, data->uint32Value8, data->uint32Value8_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_boolValue(stream, data->boolValue, data->boolValue_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_floatValue(stream, data->floatValue, data->floatValue_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_stringValue(stream, data->stringValue, data->stringValue_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_bytesValue(stream, data->bytesValue, data->bytesValue_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_fixed32Value(stream, data->fixed32Value, data->fixed32Value_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_sfixed32Value(stream, data->sfixed32Value, data->sfixed32Value_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_enumValue(stream, data->enumValue, data->enumValue_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_negEnumValue(stream, data->negEnumValue, data->negEnumValue_count);
   return true;
}

bool decode_InterfacesTest_TestAllTypesArray32Bit_Raw(qpb_istream_t *const stream, InterfacesTest_TestAllTypesArray32Bit_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_TestAllTypesArray32Bit_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_TestAllTypesArray32Bit_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_TestAllTypesArray32Bit(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypesArray32Bit *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_TestAllTypesArray32Bit_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value(stream, data->sint32Value, data->sint32Value_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value16(stream, data->sint32Value16, data->sint32Value16_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_sint32Value8(stream, data->sint32Value8, data->sint32Value8_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_int32Value(stream, data->int32Value, data->int32Value_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value16(stream, data->int32Value16, data->int32Value16_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_int32Value8(stream, data->int32Value8, data->int32Value8_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value(stream, data->uint32Value, data->uint32Value_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value16(stream, data->uint32Value16, data->uint32Value16_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_uint32Value8(stream, data->uint32Value8, data->uint32Value8_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_boolValue(stream, data->boolValue, data->boolValue_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_floatValue(stream, data->floatValue, data->floatValue_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_stringValue(stream, data->stringValue, data->stringValue_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_bytesValue(stream, data->bytesValue, data->bytesValue_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_fixed32Value(stream, data->fixed32Value, data->fixed32Value_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_sfixed32Value(stream, data->sfixed32Value, data->sfixed32Value_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_enumValue(stream, data->enumValue, data->enumValue_count);
   encode_InterfacesTest_TestAllTypesArray32Bit_Raw_negEnumValue(stream, data->negEnumValue, data->negEnumValue_count);
   return true;
}

bool decode_InterfacesTest_TestAllTypesArray32Bit(qpb_istream_t *const stream, InterfacesTest_TestAllTypesArray32Bit *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_TestAllTypesArray32Bit_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_TestAllTypesArray32Bit_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw_messageInMessageSint32(stream, &data->messageInMessageSint32);
   encode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw_subMessageInMessageInMessage(stream, &data->subMessageInMessageInMessage);
   return true;
}

bool decode_InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw(qpb_istream_t *const stream, InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_DeepSubMessage32Bit_MessageInSubMessage32Bit_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_SubMessage32Bit_Raw(qpb_ostream_t *const stream, const InterfacesTest_SubMessage32Bit_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_SubMessage32Bit_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_SubMessage32Bit_Raw_subString(stream, data->subString);
   encode_InterfacesTest_SubMessage32Bit_Raw_subSubMessage(stream, &data->subSubMessage);
   return true;
}

bool decode_InterfacesTest_SubMessage32Bit_Raw(qpb_istream_t *const stream, InterfacesTest_SubMessage32Bit_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_SubMessage32Bit_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_SubMessage32Bit_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_DeepSubMessage32Bit_Raw(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage32Bit_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_DeepSubMessage32Bit_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_DeepSubMessage32Bit_Raw_subSint32Value(stream, &data->subSint32Value);
   encode_InterfacesTest_DeepSubMessage32Bit_Raw_subBoolValue(stream, &data->subBoolValue);
   encode_InterfacesTest_DeepSubMessage32Bit_Raw_subMessage(stream, data->subMessage, data->subMessage_count);
   encode_InterfacesTest_DeepSubMessage32Bit_Raw_internalSubMessage(stream, &data->internalSubMessage);
   encode_InterfacesTest_DeepSubMessage32Bit_Raw_enumInMessageValue(stream, &data->enumInMessageValue);
   return true;
}

bool decode_InterfacesTest_DeepSubMessage32Bit_Raw(qpb_istream_t *const stream, InterfacesTest_DeepSubMessage32Bit_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_DeepSubMessage32Bit_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_DeepSubMessage32Bit_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_MainMessage32Bit_Raw(qpb_ostream_t *const stream, const InterfacesTest_MainMessage32Bit_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_MainMessage32Bit_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_MainMessage32Bit_Raw_subMessage(stream, &data->subMessage);
   encode_InterfacesTest_MainMessage32Bit_Raw_deepSubMessage(stream, &data->deepSubMessage);
   return true;
}

bool decode_InterfacesTest_MainMessage32Bit_Raw(qpb_istream_t *const stream, InterfacesTest_MainMessage32Bit_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_MainMessage32Bit_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_MainMessage32Bit_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

