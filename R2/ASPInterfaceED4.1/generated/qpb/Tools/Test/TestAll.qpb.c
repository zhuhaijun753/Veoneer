/* Automatically generated qpb constant definitions */
/* Generated by Quick Protocol Buffers - 2 */

#include "Tools/Test/TestAll.qpb.h"
#include "Tools/QuickProtobuf/qpb_decode.h"
#include "Tools/QuickProtobuf/qpb_encode.h"
#include "Tools/CSupport/ConversionSupport.h"

#if QPB_PROTO_HEADER_VERSION != 2
#error Regenerate this file with the current version of qpb generator.
#endif

#define F_0_1                0.1f
#define F_0_2                0.2f
#define F_0_3                0.3f
#define F_0_5                0.5f
#define F_0_8                0.8f
#define F_0_9                0.9f
#define F_1_5                1.5f
#define F_2_0                2.0f
#define F_10_0               10.0f

static inline void encode_InterfacesTest_TestAllTypesPointers_Raw_stringPointerValue(qpb_ostream_t *const stream, const char *const data);
static inline void encode_InterfacesTest_TestAllTypesPointers_Raw_bytesPointerValue(qpb_ostream_t *const stream, const qpb_bytes_pointer_t *const data);
static bool decode_InterfacesTest_TestAllTypesPointers_Raw_bytesPointerValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesPointers_Raw_stringPointerValueArray(qpb_ostream_t *const stream, const char *const arrayData[],const qpb_size_t arraySize);
static inline void encode_InterfacesTest_TestAllTypesPointers_Raw_bytesPointerValueArray(qpb_ostream_t *const stream, const qpb_bytes_pointer_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesPointers_Raw_bytesPointerValueArray(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw_subMessageInSubMessageBool(qpb_ostream_t *const stream, const bool *const data);
static bool decode_InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw_subMessageInSubMessageBool(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_ProcessedTypes_Raw_sint64ScaledValue(qpb_ostream_t *const stream, const int64_t *const data);
static bool decode_InterfacesTest_ProcessedTypes_Raw_sint64ScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_ProcessedTypes_Raw_int64ScaledValue(qpb_ostream_t *const stream, const int64_t *const data);
static bool decode_InterfacesTest_ProcessedTypes_Raw_int64ScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_ProcessedTypes_Raw_uint64ScaledValue(qpb_ostream_t *const stream, const uint64_t *const data);
static bool decode_InterfacesTest_ProcessedTypes_Raw_uint64ScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_ProcessedTypes_Raw_sint64ArrayScaledValue(qpb_ostream_t *const stream, const int64_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_ProcessedTypes_Raw_sint64ArrayScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_ProcessedTypes_Raw_int64ArrayScaledValue(qpb_ostream_t *const stream, const int64_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_ProcessedTypes_Raw_int64ArrayScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_ProcessedTypes_Raw_uint64ArrayScaledValue(qpb_ostream_t *const stream, const uint64_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_ProcessedTypes_Raw_uint64ArrayScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_ProcessedTypes_sint64ScaledValue(qpb_ostream_t *const stream, const float *const data);
static bool decode_InterfacesTest_ProcessedTypes_sint64ScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_ProcessedTypes_int64ScaledValue(qpb_ostream_t *const stream, const float *const data);
static bool decode_InterfacesTest_ProcessedTypes_int64ScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_ProcessedTypes_uint64ScaledValue(qpb_ostream_t *const stream, const float *const data);
static bool decode_InterfacesTest_ProcessedTypes_uint64ScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_ProcessedTypes_sint64ArrayScaledValue(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_ProcessedTypes_sint64ArrayScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_ProcessedTypes_int64ArrayScaledValue(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_ProcessedTypes_int64ArrayScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_ProcessedTypes_uint64ArrayScaledValue(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_ProcessedTypes_uint64ArrayScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_SubSubMessage_Raw_subSubUint32(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_InterfacesTest_SubSubMessage_Raw_subSubUint32(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_sint64Value(qpb_ostream_t *const stream, const int64_t *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_sint64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_sint32Value(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_sint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_sint32Value16(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_sint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_sint32Value8(qpb_ostream_t *const stream, const int8_t *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_sint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_int64Value(qpb_ostream_t *const stream, const int64_t *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_int64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_int32Value(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_int32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_int32Value16(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_int32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_int32Value8(qpb_ostream_t *const stream, const int8_t *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_int32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_uint64Value(qpb_ostream_t *const stream, const uint64_t *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_uint64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_uint32Value(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_uint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_uint32Value16(qpb_ostream_t *const stream, const uint16_t *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_uint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_uint32Value8(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_uint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_boolValue(qpb_ostream_t *const stream, const bool *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_boolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_floatValue(qpb_ostream_t *const stream, const float *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_floatValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_doubleValue(qpb_ostream_t *const stream, const double *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_doubleValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_stringValue(qpb_ostream_t *const stream, const char *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_stringValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_bytesValue(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypes_Raw_bytesValue_t *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_bytesValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_fixed64Value(qpb_ostream_t *const stream, const uint64_t *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_fixed64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_fixed32Value(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_fixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_sfixed64Value(qpb_ostream_t *const stream, const int64_t *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_sfixed64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_sfixed32Value(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_sfixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_enumValue(qpb_ostream_t *const stream, const InterfacesTest_TestEnum *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_enumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_Raw_negEnumValue(qpb_ostream_t *const stream, const InterfacesTest_TestNegEnum *const data);
static bool decode_InterfacesTest_TestAllTypes_Raw_negEnumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_sint64Value(qpb_ostream_t *const stream, const int64_t *const data);
static bool decode_InterfacesTest_TestAllTypes_sint64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_sint32Value(qpb_ostream_t *const stream, const float *const data);
static bool decode_InterfacesTest_TestAllTypes_sint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_sint32Value16(qpb_ostream_t *const stream, const int16_t *const data);
static bool decode_InterfacesTest_TestAllTypes_sint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_sint32Value8(qpb_ostream_t *const stream, const float *const data);
static bool decode_InterfacesTest_TestAllTypes_sint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_int64Value(qpb_ostream_t *const stream, const int64_t *const data);
static bool decode_InterfacesTest_TestAllTypes_int64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_int32Value(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_InterfacesTest_TestAllTypes_int32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_int32Value16(qpb_ostream_t *const stream, const float *const data);
static bool decode_InterfacesTest_TestAllTypes_int32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_int32Value8(qpb_ostream_t *const stream, const int8_t *const data);
static bool decode_InterfacesTest_TestAllTypes_int32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_uint64Value(qpb_ostream_t *const stream, const uint64_t *const data);
static bool decode_InterfacesTest_TestAllTypes_uint64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_uint32Value(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_InterfacesTest_TestAllTypes_uint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_uint32Value16(qpb_ostream_t *const stream, const float *const data);
static bool decode_InterfacesTest_TestAllTypes_uint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_uint32Value8(qpb_ostream_t *const stream, const uint8_t *const data);
static bool decode_InterfacesTest_TestAllTypes_uint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_boolValue(qpb_ostream_t *const stream, const bool *const data);
static bool decode_InterfacesTest_TestAllTypes_boolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_floatValue(qpb_ostream_t *const stream, const float *const data);
static bool decode_InterfacesTest_TestAllTypes_floatValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_doubleValue(qpb_ostream_t *const stream, const double *const data);
static bool decode_InterfacesTest_TestAllTypes_doubleValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_stringValue(qpb_ostream_t *const stream, const char *const data);
static bool decode_InterfacesTest_TestAllTypes_stringValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_bytesValue(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypes_bytesValue_t *const data);
static bool decode_InterfacesTest_TestAllTypes_bytesValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_fixed64Value(qpb_ostream_t *const stream, const uint64_t *const data);
static bool decode_InterfacesTest_TestAllTypes_fixed64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_fixed32Value(qpb_ostream_t *const stream, const uint32_t *const data);
static bool decode_InterfacesTest_TestAllTypes_fixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_sfixed64Value(qpb_ostream_t *const stream, const int64_t *const data);
static bool decode_InterfacesTest_TestAllTypes_sfixed64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_sfixed32Value(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_InterfacesTest_TestAllTypes_sfixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_enumValue(qpb_ostream_t *const stream, const InterfacesTest_TestEnum *const data);
static bool decode_InterfacesTest_TestAllTypes_enumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypes_negEnumValue(qpb_ostream_t *const stream, const InterfacesTest_TestNegEnum *const data);
static bool decode_InterfacesTest_TestAllTypes_negEnumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_sint64Value(qpb_ostream_t *const stream, const int64_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_sint64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_sint32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_sint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_sint32Value16(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_sint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_sint32Value8(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_sint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_int64Value(qpb_ostream_t *const stream, const int64_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_int64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_int32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_int32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_int32Value16(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_int32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_int32Value8(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_int32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_uint64Value(qpb_ostream_t *const stream, const uint64_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_uint64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_uint32Value(qpb_ostream_t *const stream, const uint32_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_uint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_uint32Value16(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_uint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_uint32Value8(qpb_ostream_t *const stream, const uint8_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_uint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_boolValue(qpb_ostream_t *const stream, const bool arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_boolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_floatValue(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_floatValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_doubleValue(qpb_ostream_t *const stream, const double arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_doubleValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_stringValue(qpb_ostream_t *const stream, const char arrayData[10][10],const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_stringValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_bytesValue(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypesArray_Raw_bytesValue_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_bytesValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_fixed64Value(qpb_ostream_t *const stream, const uint64_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_fixed64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_fixed32Value(qpb_ostream_t *const stream, const uint32_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_fixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_sfixed64Value(qpb_ostream_t *const stream, const int64_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_sfixed64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_sfixed32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_sfixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_enumValue(qpb_ostream_t *const stream, const InterfacesTest_TestEnum arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_enumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_Raw_negEnumValue(qpb_ostream_t *const stream, const InterfacesTest_TestNegEnum arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_Raw_negEnumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_sint64Value(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_sint64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_sint32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_sint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_sint32Value16(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_sint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_sint32Value8(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_sint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_int64Value(qpb_ostream_t *const stream, const int64_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_int64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_int32Value(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_int32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_int32Value16(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_int32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_int32Value8(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_int32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_uint64Value(qpb_ostream_t *const stream, const uint64_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_uint64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_uint32Value(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_uint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_uint32Value16(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_uint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_uint32Value8(qpb_ostream_t *const stream, const uint8_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_uint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_boolValue(qpb_ostream_t *const stream, const bool arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_boolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_floatValue(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_floatValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_doubleValue(qpb_ostream_t *const stream, const double arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_doubleValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_stringValue(qpb_ostream_t *const stream, const char arrayData[10][10],const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_stringValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_bytesValue(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypesArray_bytesValue_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_bytesValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_fixed64Value(qpb_ostream_t *const stream, const uint64_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_fixed64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_fixed32Value(qpb_ostream_t *const stream, const uint32_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_fixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_sfixed64Value(qpb_ostream_t *const stream, const int64_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_sfixed64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_sfixed32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_sfixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_enumValue(qpb_ostream_t *const stream, const InterfacesTest_TestEnum arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_enumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_TestAllTypesArray_negEnumValue(qpb_ostream_t *const stream, const InterfacesTest_TestNegEnum arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_TestAllTypesArray_negEnumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_ArrayOfProcessedTypes_Raw_processedTypesArray(qpb_ostream_t *const stream, const InterfacesTest_ProcessedTypes_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_ArrayOfProcessedTypes_Raw_processedTypesArray(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_ArrayOfProcessedTypes_processedTypesArray(qpb_ostream_t *const stream, const InterfacesTest_ProcessedTypes arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_ArrayOfProcessedTypes_processedTypesArray(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw_messageInMessageSint32(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw_messageInMessageSint32(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw_subMessageInMessageInMessage(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw *const data);
static bool decode_InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw_subMessageInMessageInMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_SubMessage_Raw_subString(qpb_ostream_t *const stream, const char *const data);
static bool decode_InterfacesTest_SubMessage_Raw_subString(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_SubMessage_Raw_subSubMessage(qpb_ostream_t *const stream, const InterfacesTest_SubSubMessage_Raw *const data);
static bool decode_InterfacesTest_SubMessage_Raw_subSubMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_DeepSubMessage_Raw_subSint32Value(qpb_ostream_t *const stream, const int32_t *const data);
static bool decode_InterfacesTest_DeepSubMessage_Raw_subSint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_DeepSubMessage_Raw_subBoolValue(qpb_ostream_t *const stream, const bool *const data);
static bool decode_InterfacesTest_DeepSubMessage_Raw_subBoolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_DeepSubMessage_Raw_subMessage(qpb_ostream_t *const stream, const InterfacesTest_SubMessage_Raw arrayData[], const qpb_size_t arraySize);
static bool decode_InterfacesTest_DeepSubMessage_Raw_subMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_DeepSubMessage_Raw_internalSubMessage(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw *const data);
static bool decode_InterfacesTest_DeepSubMessage_Raw_internalSubMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_DeepSubMessage_Raw_enumInMessageValue(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage_EnumInMessage *const data);
static bool decode_InterfacesTest_DeepSubMessage_Raw_enumInMessageValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_MainMessage_Raw_subMessage(qpb_ostream_t *const stream, const InterfacesTest_SubMessage_Raw *const data);
static bool decode_InterfacesTest_MainMessage_Raw_subMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);
static inline void encode_InterfacesTest_MainMessage_Raw_deepSubMessage(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage_Raw *const data);
static bool decode_InterfacesTest_MainMessage_Raw_deepSubMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype);

#define InterfacesTest_TestAllTypesPointers_Raw_DECODERS_COUNT 5
const qpb_decoder_entry_t InterfacesTest_TestAllTypesPointers_Raw_decoders[InterfacesTest_TestAllTypesPointers_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypesPointers_Raw_bytesPointerValue },
   { &qpb_skip_field },
   { &decode_InterfacesTest_TestAllTypesPointers_Raw_bytesPointerValueArray }
};

#define InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw_DECODERS_COUNT 2
const qpb_decoder_entry_t InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw_decoders[InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw_subMessageInSubMessageBool }
};

#define InterfacesTest_ProcessedTypes_Raw_DECODERS_COUNT 7
const qpb_decoder_entry_t InterfacesTest_ProcessedTypes_Raw_decoders[InterfacesTest_ProcessedTypes_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_ProcessedTypes_Raw_sint64ScaledValue },
   { &decode_InterfacesTest_ProcessedTypes_Raw_int64ScaledValue },
   { &decode_InterfacesTest_ProcessedTypes_Raw_uint64ScaledValue },
   { &decode_InterfacesTest_ProcessedTypes_Raw_sint64ArrayScaledValue },
   { &decode_InterfacesTest_ProcessedTypes_Raw_int64ArrayScaledValue },
   { &decode_InterfacesTest_ProcessedTypes_Raw_uint64ArrayScaledValue }
};

#define InterfacesTest_ProcessedTypes_DECODERS_COUNT 7
const qpb_decoder_entry_t InterfacesTest_ProcessedTypes_decoders[InterfacesTest_ProcessedTypes_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_ProcessedTypes_sint64ScaledValue },
   { &decode_InterfacesTest_ProcessedTypes_int64ScaledValue },
   { &decode_InterfacesTest_ProcessedTypes_uint64ScaledValue },
   { &decode_InterfacesTest_ProcessedTypes_sint64ArrayScaledValue },
   { &decode_InterfacesTest_ProcessedTypes_int64ArrayScaledValue },
   { &decode_InterfacesTest_ProcessedTypes_uint64ArrayScaledValue }
};

#define InterfacesTest_SubSubMessage_Raw_DECODERS_COUNT 2
const qpb_decoder_entry_t InterfacesTest_SubSubMessage_Raw_decoders[InterfacesTest_SubSubMessage_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_SubSubMessage_Raw_subSubUint32 }
};

#define InterfacesTest_TestAllTypes_Raw_DECODERS_COUNT 24
const qpb_decoder_entry_t InterfacesTest_TestAllTypes_Raw_decoders[InterfacesTest_TestAllTypes_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_TestAllTypes_Raw_sint64Value },
   { &decode_InterfacesTest_TestAllTypes_Raw_sint32Value },
   { &decode_InterfacesTest_TestAllTypes_Raw_sint32Value16 },
   { &decode_InterfacesTest_TestAllTypes_Raw_sint32Value8 },
   { &decode_InterfacesTest_TestAllTypes_Raw_int64Value },
   { &decode_InterfacesTest_TestAllTypes_Raw_int32Value },
   { &decode_InterfacesTest_TestAllTypes_Raw_int32Value16 },
   { &decode_InterfacesTest_TestAllTypes_Raw_int32Value8 },
   { &decode_InterfacesTest_TestAllTypes_Raw_uint64Value },
   { &decode_InterfacesTest_TestAllTypes_Raw_uint32Value },
   { &decode_InterfacesTest_TestAllTypes_Raw_uint32Value16 },
   { &decode_InterfacesTest_TestAllTypes_Raw_uint32Value8 },
   { &decode_InterfacesTest_TestAllTypes_Raw_boolValue },
   { &decode_InterfacesTest_TestAllTypes_Raw_floatValue },
   { &decode_InterfacesTest_TestAllTypes_Raw_doubleValue },
   { &decode_InterfacesTest_TestAllTypes_Raw_stringValue },
   { &decode_InterfacesTest_TestAllTypes_Raw_bytesValue },
   { &decode_InterfacesTest_TestAllTypes_Raw_fixed64Value },
   { &decode_InterfacesTest_TestAllTypes_Raw_fixed32Value },
   { &decode_InterfacesTest_TestAllTypes_Raw_sfixed64Value },
   { &decode_InterfacesTest_TestAllTypes_Raw_sfixed32Value },
   { &decode_InterfacesTest_TestAllTypes_Raw_enumValue },
   { &decode_InterfacesTest_TestAllTypes_Raw_negEnumValue }
};

#define InterfacesTest_TestAllTypes_DECODERS_COUNT 24
const qpb_decoder_entry_t InterfacesTest_TestAllTypes_decoders[InterfacesTest_TestAllTypes_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_TestAllTypes_sint64Value },
   { &decode_InterfacesTest_TestAllTypes_sint32Value },
   { &decode_InterfacesTest_TestAllTypes_sint32Value16 },
   { &decode_InterfacesTest_TestAllTypes_sint32Value8 },
   { &decode_InterfacesTest_TestAllTypes_int64Value },
   { &decode_InterfacesTest_TestAllTypes_int32Value },
   { &decode_InterfacesTest_TestAllTypes_int32Value16 },
   { &decode_InterfacesTest_TestAllTypes_int32Value8 },
   { &decode_InterfacesTest_TestAllTypes_uint64Value },
   { &decode_InterfacesTest_TestAllTypes_uint32Value },
   { &decode_InterfacesTest_TestAllTypes_uint32Value16 },
   { &decode_InterfacesTest_TestAllTypes_uint32Value8 },
   { &decode_InterfacesTest_TestAllTypes_boolValue },
   { &decode_InterfacesTest_TestAllTypes_floatValue },
   { &decode_InterfacesTest_TestAllTypes_doubleValue },
   { &decode_InterfacesTest_TestAllTypes_stringValue },
   { &decode_InterfacesTest_TestAllTypes_bytesValue },
   { &decode_InterfacesTest_TestAllTypes_fixed64Value },
   { &decode_InterfacesTest_TestAllTypes_fixed32Value },
   { &decode_InterfacesTest_TestAllTypes_sfixed64Value },
   { &decode_InterfacesTest_TestAllTypes_sfixed32Value },
   { &decode_InterfacesTest_TestAllTypes_enumValue },
   { &decode_InterfacesTest_TestAllTypes_negEnumValue }
};

#define InterfacesTest_TestAllTypesArray_Raw_DECODERS_COUNT 24
const qpb_decoder_entry_t InterfacesTest_TestAllTypesArray_Raw_decoders[InterfacesTest_TestAllTypesArray_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_TestAllTypesArray_Raw_sint64Value },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_sint32Value },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_sint32Value16 },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_sint32Value8 },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_int64Value },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_int32Value },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_int32Value16 },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_int32Value8 },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_uint64Value },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_uint32Value },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_uint32Value16 },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_uint32Value8 },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_boolValue },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_floatValue },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_doubleValue },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_stringValue },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_bytesValue },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_fixed64Value },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_fixed32Value },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_sfixed64Value },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_sfixed32Value },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_enumValue },
   { &decode_InterfacesTest_TestAllTypesArray_Raw_negEnumValue }
};

#define InterfacesTest_TestAllTypesArray_DECODERS_COUNT 24
const qpb_decoder_entry_t InterfacesTest_TestAllTypesArray_decoders[InterfacesTest_TestAllTypesArray_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_TestAllTypesArray_sint64Value },
   { &decode_InterfacesTest_TestAllTypesArray_sint32Value },
   { &decode_InterfacesTest_TestAllTypesArray_sint32Value16 },
   { &decode_InterfacesTest_TestAllTypesArray_sint32Value8 },
   { &decode_InterfacesTest_TestAllTypesArray_int64Value },
   { &decode_InterfacesTest_TestAllTypesArray_int32Value },
   { &decode_InterfacesTest_TestAllTypesArray_int32Value16 },
   { &decode_InterfacesTest_TestAllTypesArray_int32Value8 },
   { &decode_InterfacesTest_TestAllTypesArray_uint64Value },
   { &decode_InterfacesTest_TestAllTypesArray_uint32Value },
   { &decode_InterfacesTest_TestAllTypesArray_uint32Value16 },
   { &decode_InterfacesTest_TestAllTypesArray_uint32Value8 },
   { &decode_InterfacesTest_TestAllTypesArray_boolValue },
   { &decode_InterfacesTest_TestAllTypesArray_floatValue },
   { &decode_InterfacesTest_TestAllTypesArray_doubleValue },
   { &decode_InterfacesTest_TestAllTypesArray_stringValue },
   { &decode_InterfacesTest_TestAllTypesArray_bytesValue },
   { &decode_InterfacesTest_TestAllTypesArray_fixed64Value },
   { &decode_InterfacesTest_TestAllTypesArray_fixed32Value },
   { &decode_InterfacesTest_TestAllTypesArray_sfixed64Value },
   { &decode_InterfacesTest_TestAllTypesArray_sfixed32Value },
   { &decode_InterfacesTest_TestAllTypesArray_enumValue },
   { &decode_InterfacesTest_TestAllTypesArray_negEnumValue }
};

#define InterfacesTest_ArrayOfProcessedTypes_Raw_DECODERS_COUNT 2
const qpb_decoder_entry_t InterfacesTest_ArrayOfProcessedTypes_Raw_decoders[InterfacesTest_ArrayOfProcessedTypes_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_ArrayOfProcessedTypes_Raw_processedTypesArray }
};

#define InterfacesTest_ArrayOfProcessedTypes_DECODERS_COUNT 2
const qpb_decoder_entry_t InterfacesTest_ArrayOfProcessedTypes_decoders[InterfacesTest_ArrayOfProcessedTypes_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_ArrayOfProcessedTypes_processedTypesArray }
};

#define InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw_decoders[InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw_messageInMessageSint32 },
   { &decode_InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw_subMessageInMessageInMessage }
};

#define InterfacesTest_SubMessage_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t InterfacesTest_SubMessage_Raw_decoders[InterfacesTest_SubMessage_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_SubMessage_Raw_subString },
   { &decode_InterfacesTest_SubMessage_Raw_subSubMessage }
};

#define InterfacesTest_DeepSubMessage_Raw_DECODERS_COUNT 8
const qpb_decoder_entry_t InterfacesTest_DeepSubMessage_Raw_decoders[InterfacesTest_DeepSubMessage_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_DeepSubMessage_Raw_subSint32Value },
   { &decode_InterfacesTest_DeepSubMessage_Raw_subBoolValue },
   { &qpb_skip_field },
   { &qpb_skip_field },
   { &decode_InterfacesTest_DeepSubMessage_Raw_subMessage },
   { &decode_InterfacesTest_DeepSubMessage_Raw_internalSubMessage },
   { &decode_InterfacesTest_DeepSubMessage_Raw_enumInMessageValue }
};

#define InterfacesTest_MainMessage_Raw_DECODERS_COUNT 3
const qpb_decoder_entry_t InterfacesTest_MainMessage_Raw_decoders[InterfacesTest_MainMessage_Raw_DECODERS_COUNT] = {
   { &qpb_skip_field } /* Id 0 is not valid and this is skipped one level up */,
   { &decode_InterfacesTest_MainMessage_Raw_subMessage },
   { &decode_InterfacesTest_MainMessage_Raw_deepSubMessage }
};

static inline void encode_InterfacesTest_TestAllTypesPointers_Raw_stringPointerValue(qpb_ostream_t *const stream, const char *const data)
{
   qpb_size_t strSize = (data != 0 ? strlen(data) : 0);
   if (strSize != 0)
   {
      *stream->buffer = 10;
      ++stream->buffer;
      qpb_encode_bytes(stream, (qpb_byte_t*)data, strSize);
   }
}

static inline void encode_InterfacesTest_TestAllTypesPointers_Raw_bytesPointerValue(qpb_ostream_t *const stream, const qpb_bytes_pointer_t *const data)
{
   if (data->size != 0)
   {
      *stream->buffer = 18;
      ++stream->buffer;
      qpb_encode_bytes(stream, data->bytes, data->size);
   }
}

static bool decode_InterfacesTest_TestAllTypesPointers_Raw_bytesPointerValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_bytes_pointer(stream, &((InterfacesTest_TestAllTypesPointers_Raw*)data)->bytesPointerValue);
}

static inline void encode_InterfacesTest_TestAllTypesPointers_Raw_stringPointerValueArray(qpb_ostream_t *const stream, const char *const arrayData[],const qpb_size_t arraySize)
{
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      *stream->buffer = 26;
      ++stream->buffer;
      const char *const data = arrayData[i];
      qpb_encode_bytes(stream, (qpb_byte_t*)data, (data != 0 ? strlen(data) : 0));
   }
}

static inline void encode_InterfacesTest_TestAllTypesPointers_Raw_bytesPointerValueArray(qpb_ostream_t *const stream, const qpb_bytes_pointer_t arrayData[], const qpb_size_t arraySize)
{
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      *stream->buffer = 34;
      ++stream->buffer;
      const qpb_bytes_pointer_t *const data = &arrayData[i];
      qpb_encode_bytes(stream, data->bytes, data->size);
   }
}

static bool decode_InterfacesTest_TestAllTypesPointers_Raw_bytesPointerValueArray(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((InterfacesTest_TestAllTypesPointers_Raw*)data)->bytesPointerValueArray_count + 1) > 5)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   return qpb_decode_bytes_pointer(stream, &((InterfacesTest_TestAllTypesPointers_Raw*)data)->bytesPointerValueArray[((InterfacesTest_TestAllTypesPointers_Raw*)data)->bytesPointerValueArray_count++]);
}

static inline void encode_InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw_subMessageInSubMessageBool(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw_subMessageInSubMessageBool(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw*)data)->subMessageInSubMessageBool, sizeof(bool));
}

static inline void encode_InterfacesTest_ProcessedTypes_Raw_sint64ScaledValue(qpb_ostream_t *const stream, const int64_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_InterfacesTest_ProcessedTypes_Raw_sint64ScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((InterfacesTest_ProcessedTypes_Raw*)data)->sint64ScaledValue, sizeof(int64_t));
}

static inline void encode_InterfacesTest_ProcessedTypes_Raw_int64ScaledValue(qpb_ostream_t *const stream, const int64_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_ProcessedTypes_Raw_int64ScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_ProcessedTypes_Raw*)data)->int64ScaledValue, sizeof(int64_t));
}

static inline void encode_InterfacesTest_ProcessedTypes_Raw_uint64ScaledValue(qpb_ostream_t *const stream, const uint64_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_InterfacesTest_ProcessedTypes_Raw_uint64ScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((InterfacesTest_ProcessedTypes_Raw*)data)->uint64ScaledValue, sizeof(uint64_t));
}

static inline void encode_InterfacesTest_ProcessedTypes_Raw_sint64ArrayScaledValue(qpb_ostream_t *const stream, const int64_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 34;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_ProcessedTypes_Raw_sint64ArrayScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_ProcessedTypes_Raw*)data)->sint64ArrayScaledValue_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_ProcessedTypes_Raw*)data)->sint64ArrayScaledValue[((InterfacesTest_ProcessedTypes_Raw*)data)->sint64ArrayScaledValue_count++], sizeof(int64_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_ProcessedTypes_Raw*)data)->sint64ArrayScaledValue_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_ProcessedTypes_Raw*)data)->sint64ArrayScaledValue[((InterfacesTest_ProcessedTypes_Raw*)data)->sint64ArrayScaledValue_count++], sizeof(int64_t));
   }
   return result;
}

static inline void encode_InterfacesTest_ProcessedTypes_Raw_int64ArrayScaledValue(qpb_ostream_t *const stream, const int64_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 42;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_ProcessedTypes_Raw_int64ArrayScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_ProcessedTypes_Raw*)data)->int64ArrayScaledValue_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_ProcessedTypes_Raw*)data)->int64ArrayScaledValue[((InterfacesTest_ProcessedTypes_Raw*)data)->int64ArrayScaledValue_count++], sizeof(int64_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_ProcessedTypes_Raw*)data)->int64ArrayScaledValue_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_ProcessedTypes_Raw*)data)->int64ArrayScaledValue[((InterfacesTest_ProcessedTypes_Raw*)data)->int64ArrayScaledValue_count++], sizeof(int64_t));
   }
   return result;
}

static inline void encode_InterfacesTest_ProcessedTypes_Raw_uint64ArrayScaledValue(qpb_ostream_t *const stream, const uint64_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 50;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_ProcessedTypes_Raw_uint64ArrayScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_ProcessedTypes_Raw*)data)->uint64ArrayScaledValue_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_ProcessedTypes_Raw*)data)->uint64ArrayScaledValue[((InterfacesTest_ProcessedTypes_Raw*)data)->uint64ArrayScaledValue_count++], sizeof(uint64_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_ProcessedTypes_Raw*)data)->uint64ArrayScaledValue_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_ProcessedTypes_Raw*)data)->uint64ArrayScaledValue[((InterfacesTest_ProcessedTypes_Raw*)data)->uint64ArrayScaledValue_count++], sizeof(uint64_t));
   }
   return result;
}

static inline void encode_InterfacesTest_ProcessedTypes_sint64ScaledValue(qpb_ostream_t *const stream, const float *const data)
{
   int64_t value = (int64_t)convertToInt64(*data, F_0_1, INT64_MIN, INT64_MAX);
   encode_InterfacesTest_ProcessedTypes_Raw_sint64ScaledValue(stream, &value);
}

static bool decode_InterfacesTest_ProcessedTypes_sint64ScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int64_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int64_t));
   ((InterfacesTest_ProcessedTypes*)data)->sint64ScaledValue = value * F_0_1;
   return result;
}

static inline void encode_InterfacesTest_ProcessedTypes_int64ScaledValue(qpb_ostream_t *const stream, const float *const data)
{
   int64_t value = (int64_t)convertToInt64(*data, F_2_0, INT64_MIN, INT64_MAX);
   encode_InterfacesTest_ProcessedTypes_Raw_int64ScaledValue(stream, &value);
}

static bool decode_InterfacesTest_ProcessedTypes_int64ScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int64_t value;
   bool result = qpb_decode_varint(stream, (void*)&value, sizeof(int64_t));
   ((InterfacesTest_ProcessedTypes*)data)->int64ScaledValue = value * F_2_0;
   return result;
}

static inline void encode_InterfacesTest_ProcessedTypes_uint64ScaledValue(qpb_ostream_t *const stream, const float *const data)
{
   uint64_t value = (uint64_t)convertToUint64(*data, F_0_5, 0, UINT64_MAX);
   encode_InterfacesTest_ProcessedTypes_Raw_uint64ScaledValue(stream, &value);
}

static bool decode_InterfacesTest_ProcessedTypes_uint64ScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint64_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint64_t));
   ((InterfacesTest_ProcessedTypes*)data)->uint64ScaledValue = value * F_0_5;
   return result;
}

static inline void encode_InterfacesTest_ProcessedTypes_sint64ArrayScaledValue(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   int64_t values[5];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (int64_t)convertToInt64(arrayData[i], F_10_0, INT64_MIN, INT64_MAX);
   }
   encode_InterfacesTest_ProcessedTypes_Raw_sint64ArrayScaledValue(stream, values, arraySize);
}

static bool decode_InterfacesTest_ProcessedTypes_sint64ArrayScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_ProcessedTypes*)data)->sint64ArrayScaledValue_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         int64_t value;
         result = qpb_decode_svarint(stream, (void*)&value, sizeof(int64_t));
         ((InterfacesTest_ProcessedTypes*)data)->sint64ArrayScaledValue[((InterfacesTest_ProcessedTypes*)data)->sint64ArrayScaledValue_count++] = value * F_10_0;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_ProcessedTypes*)data)->sint64ArrayScaledValue_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      int64_t value;
      result = qpb_decode_svarint(stream, (void*)&value, sizeof(int64_t));
      ((InterfacesTest_ProcessedTypes*)data)->sint64ArrayScaledValue[((InterfacesTest_ProcessedTypes*)data)->sint64ArrayScaledValue_count++] = value * F_10_0;
   }
   return result;
}

static inline void encode_InterfacesTest_ProcessedTypes_int64ArrayScaledValue(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   int64_t values[5];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (int64_t)convertToInt64(arrayData[i], F_0_3, INT64_MIN, INT64_MAX);
   }
   encode_InterfacesTest_ProcessedTypes_Raw_int64ArrayScaledValue(stream, values, arraySize);
}

static bool decode_InterfacesTest_ProcessedTypes_int64ArrayScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_ProcessedTypes*)data)->int64ArrayScaledValue_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         int64_t value;
         result = qpb_decode_varint(stream, (void*)&value, sizeof(int64_t));
         ((InterfacesTest_ProcessedTypes*)data)->int64ArrayScaledValue[((InterfacesTest_ProcessedTypes*)data)->int64ArrayScaledValue_count++] = value * F_0_3;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_ProcessedTypes*)data)->int64ArrayScaledValue_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      int64_t value;
      result = qpb_decode_varint(stream, (void*)&value, sizeof(int64_t));
      ((InterfacesTest_ProcessedTypes*)data)->int64ArrayScaledValue[((InterfacesTest_ProcessedTypes*)data)->int64ArrayScaledValue_count++] = value * F_0_3;
   }
   return result;
}

static inline void encode_InterfacesTest_ProcessedTypes_uint64ArrayScaledValue(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   uint64_t values[5];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (uint64_t)convertToUint64(arrayData[i], F_0_8, 0, UINT64_MAX);
   }
   encode_InterfacesTest_ProcessedTypes_Raw_uint64ArrayScaledValue(stream, values, arraySize);
}

static bool decode_InterfacesTest_ProcessedTypes_uint64ArrayScaledValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_ProcessedTypes*)data)->uint64ArrayScaledValue_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         uint64_t value;
         result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint64_t));
         ((InterfacesTest_ProcessedTypes*)data)->uint64ArrayScaledValue[((InterfacesTest_ProcessedTypes*)data)->uint64ArrayScaledValue_count++] = value * F_0_8;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_ProcessedTypes*)data)->uint64ArrayScaledValue_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      uint64_t value;
      result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint64_t));
      ((InterfacesTest_ProcessedTypes*)data)->uint64ArrayScaledValue[((InterfacesTest_ProcessedTypes*)data)->uint64ArrayScaledValue_count++] = value * F_0_8;
   }
   return result;
}

static inline void encode_InterfacesTest_SubSubMessage_Raw_subSubUint32(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_InterfacesTest_SubSubMessage_Raw_subSubUint32(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((InterfacesTest_SubSubMessage_Raw*)data)->subSubUint32, sizeof(uint32_t));
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_sint64Value(qpb_ostream_t *const stream, const int64_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_sint64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->sint64Value, sizeof(int64_t));
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_sint32Value(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_sint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->sint32Value, sizeof(int32_t));
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_sint32Value16(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_sint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->sint32Value16, sizeof(int16_t));
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_sint32Value8(qpb_ostream_t *const stream, const int8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 32;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_sint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->sint32Value8, sizeof(int8_t));
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_int64Value(qpb_ostream_t *const stream, const int64_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_int64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->int64Value, sizeof(int64_t));
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_int32Value(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_int32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->int32Value, sizeof(int32_t));
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_int32Value16(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_int32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->int32Value16, sizeof(int16_t));
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_int32Value8(qpb_ostream_t *const stream, const int8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_int32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->int32Value8, sizeof(int8_t));
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_uint64Value(qpb_ostream_t *const stream, const uint64_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 72;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_uint64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->uint64Value, sizeof(uint64_t));
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_uint32Value(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 80;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_uint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->uint32Value, sizeof(uint32_t));
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_uint32Value16(qpb_ostream_t *const stream, const uint16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 88;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_uint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->uint32Value16, sizeof(uint16_t));
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_uint32Value8(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 96;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_uint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->uint32Value8, sizeof(uint8_t));
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_boolValue(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 104;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_boolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->boolValue, sizeof(bool));
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_floatValue(qpb_ostream_t *const stream, const float *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 117;
      ++stream->buffer;
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_floatValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->floatValue);
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_doubleValue(qpb_ostream_t *const stream, const double *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 121;
      ++stream->buffer;
      qpb_encode_fixed64(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_doubleValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->doubleValue);
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_stringValue(qpb_ostream_t *const stream, const char *const data)
{
   qpb_size_t strSize = strlen(data);
   if (strSize != 0)
   {
      qpb_encode_varint(stream, 130);
      qpb_encode_bytes(stream, (qpb_byte_t*)data, strSize);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_stringValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_string_static(stream, ((InterfacesTest_TestAllTypes_Raw*)data)->stringValue, 9);
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_bytesValue(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypes_Raw_bytesValue_t *const data)
{
   if (data->size != 0)
   {
      qpb_encode_varint(stream, 138);
      qpb_encode_bytes(stream, data->bytes, data->size);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_bytesValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_bytes_static(stream, (qpb_bytes_array_t*)&((InterfacesTest_TestAllTypes_Raw*)data)->bytesValue, 10);
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_fixed64Value(qpb_ostream_t *const stream, const uint64_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 145);
      qpb_encode_fixed64(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_fixed64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->fixed64Value);
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_fixed32Value(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 157);
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_fixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->fixed32Value);
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_sfixed64Value(qpb_ostream_t *const stream, const int64_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 161);
      qpb_encode_fixed64(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_sfixed64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->sfixed64Value);
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_sfixed32Value(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 173);
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_sfixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->sfixed32Value);
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_enumValue(qpb_ostream_t *const stream, const InterfacesTest_TestEnum *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 176);
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_enumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes_Raw*)data)->enumValue, qpb_membersize(InterfacesTest_TestAllTypes_Raw, enumValue));
}

static inline void encode_InterfacesTest_TestAllTypes_Raw_negEnumValue(qpb_ostream_t *const stream, const InterfacesTest_TestNegEnum *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 184);
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_Raw_negEnumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   qpb_int64_t value;
   bool result;
   QPB_UNUSED(wiretype);
   result = qpb_decode_varint(stream, &value, sizeof(qpb_int64_t));
   if (result)
   {
#ifndef QPB_WITHOUT_64BIT
      /* Protobuf only supports int32 values for enums */
      result = INT32_MIN <= value && value <= INT32_MAX;
      if (result)
      {
         ((InterfacesTest_TestAllTypes_Raw*)data)->negEnumValue = (InterfacesTest_TestNegEnum)value;
      }
#else
      ((InterfacesTest_TestAllTypes_Raw*)data)->negEnumValue = (InterfacesTest_TestNegEnum)value;
#endif
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypes_sint64Value(qpb_ostream_t *const stream, const int64_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_sint64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypes*)data)->sint64Value, sizeof(int64_t));
}

static inline void encode_InterfacesTest_TestAllTypes_sint32Value(qpb_ostream_t *const stream, const float *const data)
{
   int32_t value = (int32_t)convertToInt32(*data, F_0_1, INT32_MIN, INT32_MAX);
   encode_InterfacesTest_TestAllTypes_Raw_sint32Value(stream, &value);
}

static bool decode_InterfacesTest_TestAllTypes_sint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int32_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int32_t));
   ((InterfacesTest_TestAllTypes*)data)->sint32Value = value * F_0_1;
   return result;
}

static inline void encode_InterfacesTest_TestAllTypes_sint32Value16(qpb_ostream_t *const stream, const int16_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 24;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_sint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypes*)data)->sint32Value16, sizeof(int16_t));
}

static inline void encode_InterfacesTest_TestAllTypes_sint32Value8(qpb_ostream_t *const stream, const float *const data)
{
   int8_t value = (int8_t)convertToInt32(*data, F_0_2, INT8_MIN, INT8_MAX);
   encode_InterfacesTest_TestAllTypes_Raw_sint32Value8(stream, &value);
}

static bool decode_InterfacesTest_TestAllTypes_sint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int8_t value;
   bool result = qpb_decode_svarint(stream, (void*)&value, sizeof(int8_t));
   ((InterfacesTest_TestAllTypes*)data)->sint32Value8 = value * F_0_2;
   return result;
}

static inline void encode_InterfacesTest_TestAllTypes_int64Value(qpb_ostream_t *const stream, const int64_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 40;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_int64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes*)data)->int64Value, sizeof(int64_t));
}

static inline void encode_InterfacesTest_TestAllTypes_int32Value(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 48;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_int32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes*)data)->int32Value, sizeof(int32_t));
}

static inline void encode_InterfacesTest_TestAllTypes_int32Value16(qpb_ostream_t *const stream, const float *const data)
{
   int16_t value = (int16_t)convertToInt32(*data, F_10_0, INT16_MIN, INT16_MAX);
   encode_InterfacesTest_TestAllTypes_Raw_int32Value16(stream, &value);
}

static bool decode_InterfacesTest_TestAllTypes_int32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   int16_t value;
   bool result = qpb_decode_varint(stream, (void*)&value, sizeof(int16_t));
   ((InterfacesTest_TestAllTypes*)data)->int32Value16 = value * F_10_0;
   return result;
}

static inline void encode_InterfacesTest_TestAllTypes_int32Value8(qpb_ostream_t *const stream, const int8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 64;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_int32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes*)data)->int32Value8, sizeof(int8_t));
}

static inline void encode_InterfacesTest_TestAllTypes_uint64Value(qpb_ostream_t *const stream, const uint64_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 72;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_uint64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypes*)data)->uint64Value, sizeof(uint64_t));
}

static inline void encode_InterfacesTest_TestAllTypes_uint32Value(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 80;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_uint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypes*)data)->uint32Value, sizeof(uint32_t));
}

static inline void encode_InterfacesTest_TestAllTypes_uint32Value16(qpb_ostream_t *const stream, const float *const data)
{
   uint16_t value = (uint16_t)convertToUint32(*data, F_0_5, 0, UINT16_MAX);
   encode_InterfacesTest_TestAllTypes_Raw_uint32Value16(stream, &value);
}

static bool decode_InterfacesTest_TestAllTypes_uint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   uint16_t value;
   bool result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint16_t));
   ((InterfacesTest_TestAllTypes*)data)->uint32Value16 = value * F_0_5;
   return result;
}

static inline void encode_InterfacesTest_TestAllTypes_uint32Value8(qpb_ostream_t *const stream, const uint8_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 96;
      ++stream->buffer;
      qpb_encode_uvarint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_uint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypes*)data)->uint32Value8, sizeof(uint8_t));
}

static inline void encode_InterfacesTest_TestAllTypes_boolValue(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 104;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_boolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes*)data)->boolValue, sizeof(bool));
}

static inline void encode_InterfacesTest_TestAllTypes_floatValue(qpb_ostream_t *const stream, const float *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 117;
      ++stream->buffer;
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_floatValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypes*)data)->floatValue);
}

static inline void encode_InterfacesTest_TestAllTypes_doubleValue(qpb_ostream_t *const stream, const double *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 121;
      ++stream->buffer;
      qpb_encode_fixed64(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_doubleValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypes*)data)->doubleValue);
}

static inline void encode_InterfacesTest_TestAllTypes_stringValue(qpb_ostream_t *const stream, const char *const data)
{
   qpb_size_t strSize = strlen(data);
   if (strSize != 0)
   {
      qpb_encode_varint(stream, 130);
      qpb_encode_bytes(stream, (qpb_byte_t*)data, strSize);
   }
}

static bool decode_InterfacesTest_TestAllTypes_stringValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_string_static(stream, ((InterfacesTest_TestAllTypes*)data)->stringValue, 9);
}

static inline void encode_InterfacesTest_TestAllTypes_bytesValue(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypes_bytesValue_t *const data)
{
   if (data->size != 0)
   {
      qpb_encode_varint(stream, 138);
      qpb_encode_bytes(stream, data->bytes, data->size);
   }
}

static bool decode_InterfacesTest_TestAllTypes_bytesValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_bytes_static(stream, (qpb_bytes_array_t*)&((InterfacesTest_TestAllTypes*)data)->bytesValue, 10);
}

static inline void encode_InterfacesTest_TestAllTypes_fixed64Value(qpb_ostream_t *const stream, const uint64_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 145);
      qpb_encode_fixed64(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_fixed64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypes*)data)->fixed64Value);
}

static inline void encode_InterfacesTest_TestAllTypes_fixed32Value(qpb_ostream_t *const stream, const uint32_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 157);
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_fixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypes*)data)->fixed32Value);
}

static inline void encode_InterfacesTest_TestAllTypes_sfixed64Value(qpb_ostream_t *const stream, const int64_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 161);
      qpb_encode_fixed64(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_sfixed64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypes*)data)->sfixed64Value);
}

static inline void encode_InterfacesTest_TestAllTypes_sfixed32Value(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 173);
      qpb_encode_fixed32(stream, data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_sfixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypes*)data)->sfixed32Value);
}

static inline void encode_InterfacesTest_TestAllTypes_enumValue(qpb_ostream_t *const stream, const InterfacesTest_TestEnum *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 176);
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_enumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypes*)data)->enumValue, qpb_membersize(InterfacesTest_TestAllTypes, enumValue));
}

static inline void encode_InterfacesTest_TestAllTypes_negEnumValue(qpb_ostream_t *const stream, const InterfacesTest_TestNegEnum *const data)
{
   if (*data != 0)
   {
      qpb_encode_varint(stream, 184);
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_TestAllTypes_negEnumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   qpb_int64_t value;
   bool result;
   QPB_UNUSED(wiretype);
   result = qpb_decode_varint(stream, &value, sizeof(qpb_int64_t));
   if (result)
   {
#ifndef QPB_WITHOUT_64BIT
      /* Protobuf only supports int32 values for enums */
      result = INT32_MIN <= value && value <= INT32_MAX;
      if (result)
      {
         ((InterfacesTest_TestAllTypes*)data)->negEnumValue = (InterfacesTest_TestNegEnum)value;
      }
#else
      ((InterfacesTest_TestAllTypes*)data)->negEnumValue = (InterfacesTest_TestNegEnum)value;
#endif
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_sint64Value(qpb_ostream_t *const stream, const int64_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 10;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_sint64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->sint64Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->sint64Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->sint64Value_count++], sizeof(int64_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->sint64Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->sint64Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->sint64Value_count++], sizeof(int64_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_sint32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 18;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_sint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value_count++], sizeof(int32_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value_count++], sizeof(int32_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_sint32Value16(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 26;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_sint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value16_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value16[((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value16_count++], sizeof(int16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value16_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value16[((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value16_count++], sizeof(int16_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_sint32Value8(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 34;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_sint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value8_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value8[((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value8_count++], sizeof(int8_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value8_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value8[((InterfacesTest_TestAllTypesArray_Raw*)data)->sint32Value8_count++], sizeof(int8_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_int64Value(qpb_ostream_t *const stream, const int64_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 42;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_int64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->int64Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->int64Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->int64Value_count++], sizeof(int64_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->int64Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->int64Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->int64Value_count++], sizeof(int64_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_int32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 50;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_int32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value_count++], sizeof(int32_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value_count++], sizeof(int32_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_int32Value16(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 58;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_int32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value16_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value16[((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value16_count++], sizeof(int16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value16_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value16[((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value16_count++], sizeof(int16_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_int32Value8(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 66;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_int32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value8_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value8[((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value8_count++], sizeof(int8_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value8_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value8[((InterfacesTest_TestAllTypesArray_Raw*)data)->int32Value8_count++], sizeof(int8_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_uint64Value(qpb_ostream_t *const stream, const uint64_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 74;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_uint64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->uint64Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->uint64Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->uint64Value_count++], sizeof(uint64_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->uint64Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->uint64Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->uint64Value_count++], sizeof(uint64_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_uint32Value(qpb_ostream_t *const stream, const uint32_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 82;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_uint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value_count++], sizeof(uint32_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value_count++], sizeof(uint32_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_uint32Value16(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 90;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_uint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value16_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value16[((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value16_count++], sizeof(uint16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value16_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value16[((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value16_count++], sizeof(uint16_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_uint32Value8(qpb_ostream_t *const stream, const uint8_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 98;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_uint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value8_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value8[((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value8_count++], sizeof(uint8_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value8_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value8[((InterfacesTest_TestAllTypesArray_Raw*)data)->uint32Value8_count++], sizeof(uint8_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_boolValue(qpb_ostream_t *const stream, const bool arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 106;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_boolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->boolValue_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->boolValue[((InterfacesTest_TestAllTypesArray_Raw*)data)->boolValue_count++], sizeof(bool));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->boolValue_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->boolValue[((InterfacesTest_TestAllTypesArray_Raw*)data)->boolValue_count++], sizeof(bool));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_floatValue(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 114;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed32(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_floatValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->floatValue_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->floatValue[((InterfacesTest_TestAllTypesArray_Raw*)data)->floatValue_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->floatValue_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->floatValue[((InterfacesTest_TestAllTypesArray_Raw*)data)->floatValue_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_doubleValue(qpb_ostream_t *const stream, const double arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 122;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed64(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_doubleValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->doubleValue_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->doubleValue[((InterfacesTest_TestAllTypesArray_Raw*)data)->doubleValue_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->doubleValue_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->doubleValue[((InterfacesTest_TestAllTypesArray_Raw*)data)->doubleValue_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_stringValue(qpb_ostream_t *const stream, const char arrayData[10][10],const qpb_size_t arraySize)
{
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      qpb_encode_varint(stream, 130);
      const char *const data = &arrayData[i][0];
      qpb_encode_bytes(stream, (qpb_byte_t*)data, strlen(data));
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_stringValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->stringValue_count + 1) > 5)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   return qpb_decode_string_static(stream, ((InterfacesTest_TestAllTypesArray_Raw*)data)->stringValue[((InterfacesTest_TestAllTypesArray_Raw*)data)->stringValue_count++], 9);
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_bytesValue(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypesArray_Raw_bytesValue_t arrayData[], const qpb_size_t arraySize)
{
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      qpb_encode_varint(stream, 138);
      const InterfacesTest_TestAllTypesArray_Raw_bytesValue_t *const data = &arrayData[i];
      qpb_encode_bytes(stream, data->bytes, data->size);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_bytesValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->bytesValue_count + 1) > 5)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   return qpb_decode_bytes_static(stream, (qpb_bytes_array_t*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->bytesValue[((InterfacesTest_TestAllTypesArray_Raw*)data)->bytesValue_count++], 10);
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_fixed64Value(qpb_ostream_t *const stream, const uint64_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 146);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed64(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_fixed64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->fixed64Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->fixed64Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->fixed64Value_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->fixed64Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->fixed64Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->fixed64Value_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_fixed32Value(qpb_ostream_t *const stream, const uint32_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 154);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed32(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_fixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->fixed32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->fixed32Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->fixed32Value_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->fixed32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->fixed32Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->fixed32Value_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_sfixed64Value(qpb_ostream_t *const stream, const int64_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 162);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed64(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_sfixed64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->sfixed64Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->sfixed64Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->sfixed64Value_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->sfixed64Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->sfixed64Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->sfixed64Value_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_sfixed32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 170);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed32(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_sfixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->sfixed32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->sfixed32Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->sfixed32Value_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->sfixed32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->sfixed32Value[((InterfacesTest_TestAllTypesArray_Raw*)data)->sfixed32Value_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_enumValue(qpb_ostream_t *const stream, const InterfacesTest_TestEnum arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 178);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_enumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->enumValue_count + 1 > 3)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->enumValue[((InterfacesTest_TestAllTypesArray_Raw*)data)->enumValue_count++], qpb_membersize(InterfacesTest_TestAllTypesArray_Raw, enumValue[0]));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->enumValue_count + 1) > 3)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray_Raw*)data)->enumValue[((InterfacesTest_TestAllTypesArray_Raw*)data)->enumValue_count++], qpb_membersize(InterfacesTest_TestAllTypesArray_Raw, enumValue[0]));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_Raw_negEnumValue(qpb_ostream_t *const stream, const InterfacesTest_TestNegEnum arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 186);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_Raw_negEnumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray_Raw*)data)->negEnumValue_count + 1 > 3)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         qpb_int64_t value;
         result = qpb_decode_varint(stream, &value, sizeof(qpb_int64_t));
         if (result)
         {
#ifndef QPB_WITHOUT_64BIT
            /* Protobuf only supports int32 values for enums */
            result = INT32_MIN <= value && value <= INT32_MAX;
            if (result)
            {
               ((InterfacesTest_TestAllTypesArray_Raw*)data)->negEnumValue[((InterfacesTest_TestAllTypesArray_Raw*)data)->negEnumValue_count++] = (InterfacesTest_TestNegEnum)value;
            }
#else
            ((InterfacesTest_TestAllTypesArray_Raw*)data)->negEnumValue[((InterfacesTest_TestAllTypesArray_Raw*)data)->negEnumValue_count++] = (InterfacesTest_TestNegEnum)value;
#endif
         }
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray_Raw*)data)->negEnumValue_count + 1) > 3)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      qpb_int64_t value;
      result = qpb_decode_varint(stream, &value, sizeof(qpb_int64_t));
      if (result)
      {
#ifndef QPB_WITHOUT_64BIT
         /* Protobuf only supports int32 values for enums */
         result = INT32_MIN <= value && value <= INT32_MAX;
         if (result)
         {
            ((InterfacesTest_TestAllTypesArray_Raw*)data)->negEnumValue[((InterfacesTest_TestAllTypesArray_Raw*)data)->negEnumValue_count++] = (InterfacesTest_TestNegEnum)value;
         }
#else
         ((InterfacesTest_TestAllTypesArray_Raw*)data)->negEnumValue[((InterfacesTest_TestAllTypesArray_Raw*)data)->negEnumValue_count++] = (InterfacesTest_TestNegEnum)value;
#endif
      }
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_sint64Value(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   int64_t values[5];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (int64_t)convertToInt64(arrayData[i], F_1_5, INT64_MIN, INT64_MAX);
   }
   encode_InterfacesTest_TestAllTypesArray_Raw_sint64Value(stream, values, arraySize);
}

static bool decode_InterfacesTest_TestAllTypesArray_sint64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->sint64Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         int64_t value;
         result = qpb_decode_svarint(stream, (void*)&value, sizeof(int64_t));
         ((InterfacesTest_TestAllTypesArray*)data)->sint64Value[((InterfacesTest_TestAllTypesArray*)data)->sint64Value_count++] = value * F_1_5;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->sint64Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      int64_t value;
      result = qpb_decode_svarint(stream, (void*)&value, sizeof(int64_t));
      ((InterfacesTest_TestAllTypesArray*)data)->sint64Value[((InterfacesTest_TestAllTypesArray*)data)->sint64Value_count++] = value * F_1_5;
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_sint32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 18;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_sint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->sint32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->sint32Value[((InterfacesTest_TestAllTypesArray*)data)->sint32Value_count++], sizeof(int32_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->sint32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->sint32Value[((InterfacesTest_TestAllTypesArray*)data)->sint32Value_count++], sizeof(int32_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_sint32Value16(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 26;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_sint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->sint32Value16_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->sint32Value16[((InterfacesTest_TestAllTypesArray*)data)->sint32Value16_count++], sizeof(int16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->sint32Value16_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->sint32Value16[((InterfacesTest_TestAllTypesArray*)data)->sint32Value16_count++], sizeof(int16_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_sint32Value8(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 34;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_svarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_sint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->sint32Value8_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->sint32Value8[((InterfacesTest_TestAllTypesArray*)data)->sint32Value8_count++], sizeof(int8_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->sint32Value8_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_svarint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->sint32Value8[((InterfacesTest_TestAllTypesArray*)data)->sint32Value8_count++], sizeof(int8_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_int64Value(qpb_ostream_t *const stream, const int64_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 42;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_int64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->int64Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->int64Value[((InterfacesTest_TestAllTypesArray*)data)->int64Value_count++], sizeof(int64_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->int64Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->int64Value[((InterfacesTest_TestAllTypesArray*)data)->int64Value_count++], sizeof(int64_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_int32Value(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   int32_t values[5];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (int32_t)convertToInt32(arrayData[i], F_0_9, INT32_MIN, INT32_MAX);
   }
   encode_InterfacesTest_TestAllTypesArray_Raw_int32Value(stream, values, arraySize);
}

static bool decode_InterfacesTest_TestAllTypesArray_int32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->int32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         int32_t value;
         result = qpb_decode_varint(stream, (void*)&value, sizeof(int32_t));
         ((InterfacesTest_TestAllTypesArray*)data)->int32Value[((InterfacesTest_TestAllTypesArray*)data)->int32Value_count++] = value * F_0_9;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->int32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      int32_t value;
      result = qpb_decode_varint(stream, (void*)&value, sizeof(int32_t));
      ((InterfacesTest_TestAllTypesArray*)data)->int32Value[((InterfacesTest_TestAllTypesArray*)data)->int32Value_count++] = value * F_0_9;
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_int32Value16(qpb_ostream_t *const stream, const int16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 58;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_int32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->int32Value16_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->int32Value16[((InterfacesTest_TestAllTypesArray*)data)->int32Value16_count++], sizeof(int16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->int32Value16_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->int32Value16[((InterfacesTest_TestAllTypesArray*)data)->int32Value16_count++], sizeof(int16_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_int32Value8(qpb_ostream_t *const stream, const int8_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 66;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_int32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->int32Value8_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->int32Value8[((InterfacesTest_TestAllTypesArray*)data)->int32Value8_count++], sizeof(int8_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->int32Value8_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->int32Value8[((InterfacesTest_TestAllTypesArray*)data)->int32Value8_count++], sizeof(int8_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_uint64Value(qpb_ostream_t *const stream, const uint64_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 74;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_uint64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->uint64Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->uint64Value[((InterfacesTest_TestAllTypesArray*)data)->uint64Value_count++], sizeof(uint64_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->uint64Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->uint64Value[((InterfacesTest_TestAllTypesArray*)data)->uint64Value_count++], sizeof(uint64_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_uint32Value(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   uint32_t values[5];
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      values[i] = (uint32_t)convertToUint32(arrayData[i], F_0_3, 0, UINT32_MAX);
   }
   encode_InterfacesTest_TestAllTypesArray_Raw_uint32Value(stream, values, arraySize);
}

static bool decode_InterfacesTest_TestAllTypesArray_uint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->uint32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         uint32_t value;
         result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint32_t));
         ((InterfacesTest_TestAllTypesArray*)data)->uint32Value[((InterfacesTest_TestAllTypesArray*)data)->uint32Value_count++] = value * F_0_3;
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->uint32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      uint32_t value;
      result = qpb_decode_uvarint(stream, (void*)&value, sizeof(uint32_t));
      ((InterfacesTest_TestAllTypesArray*)data)->uint32Value[((InterfacesTest_TestAllTypesArray*)data)->uint32Value_count++] = value * F_0_3;
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_uint32Value16(qpb_ostream_t *const stream, const uint16_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 90;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_uint32Value16(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->uint32Value16_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->uint32Value16[((InterfacesTest_TestAllTypesArray*)data)->uint32Value16_count++], sizeof(uint16_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->uint32Value16_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->uint32Value16[((InterfacesTest_TestAllTypesArray*)data)->uint32Value16_count++], sizeof(uint16_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_uint32Value8(qpb_ostream_t *const stream, const uint8_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 98;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_uvarint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_uint32Value8(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->uint32Value8_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->uint32Value8[((InterfacesTest_TestAllTypesArray*)data)->uint32Value8_count++], sizeof(uint8_t));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->uint32Value8_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_uvarint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->uint32Value8[((InterfacesTest_TestAllTypesArray*)data)->uint32Value8_count++], sizeof(uint8_t));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_boolValue(qpb_ostream_t *const stream, const bool arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 106;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_boolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->boolValue_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->boolValue[((InterfacesTest_TestAllTypesArray*)data)->boolValue_count++], sizeof(bool));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->boolValue_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->boolValue[((InterfacesTest_TestAllTypesArray*)data)->boolValue_count++], sizeof(bool));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_floatValue(qpb_ostream_t *const stream, const float arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 114;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed32(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_floatValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->floatValue_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->floatValue[((InterfacesTest_TestAllTypesArray*)data)->floatValue_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->floatValue_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->floatValue[((InterfacesTest_TestAllTypesArray*)data)->floatValue_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_doubleValue(qpb_ostream_t *const stream, const double arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      *stream->buffer = 122;
      ++stream->buffer;
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed64(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_doubleValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->doubleValue_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->doubleValue[((InterfacesTest_TestAllTypesArray*)data)->doubleValue_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->doubleValue_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->doubleValue[((InterfacesTest_TestAllTypesArray*)data)->doubleValue_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_stringValue(qpb_ostream_t *const stream, const char arrayData[10][10],const qpb_size_t arraySize)
{
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      qpb_encode_varint(stream, 130);
      const char *const data = &arrayData[i][0];
      qpb_encode_bytes(stream, (qpb_byte_t*)data, strlen(data));
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_stringValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((InterfacesTest_TestAllTypesArray*)data)->stringValue_count + 1) > 5)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   return qpb_decode_string_static(stream, ((InterfacesTest_TestAllTypesArray*)data)->stringValue[((InterfacesTest_TestAllTypesArray*)data)->stringValue_count++], 9);
}

static inline void encode_InterfacesTest_TestAllTypesArray_bytesValue(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypesArray_bytesValue_t arrayData[], const qpb_size_t arraySize)
{
   for (qpb_size_t i = 0; i < arraySize; ++i)
   {
      qpb_encode_varint(stream, 138);
      const InterfacesTest_TestAllTypesArray_bytesValue_t *const data = &arrayData[i];
      qpb_encode_bytes(stream, data->bytes, data->size);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_bytesValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((InterfacesTest_TestAllTypesArray*)data)->bytesValue_count + 1) > 5)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   return qpb_decode_bytes_static(stream, (qpb_bytes_array_t*)&((InterfacesTest_TestAllTypesArray*)data)->bytesValue[((InterfacesTest_TestAllTypesArray*)data)->bytesValue_count++], 10);
}

static inline void encode_InterfacesTest_TestAllTypesArray_fixed64Value(qpb_ostream_t *const stream, const uint64_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 146);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed64(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_fixed64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->fixed64Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->fixed64Value[((InterfacesTest_TestAllTypesArray*)data)->fixed64Value_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->fixed64Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->fixed64Value[((InterfacesTest_TestAllTypesArray*)data)->fixed64Value_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_fixed32Value(qpb_ostream_t *const stream, const uint32_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 154);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed32(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_fixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->fixed32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->fixed32Value[((InterfacesTest_TestAllTypesArray*)data)->fixed32Value_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->fixed32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->fixed32Value[((InterfacesTest_TestAllTypesArray*)data)->fixed32Value_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_sfixed64Value(qpb_ostream_t *const stream, const int64_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 162);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed64(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_sfixed64Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->sfixed64Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->sfixed64Value[((InterfacesTest_TestAllTypesArray*)data)->sfixed64Value_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->sfixed64Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed64(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->sfixed64Value[((InterfacesTest_TestAllTypesArray*)data)->sfixed64Value_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_sfixed32Value(qpb_ostream_t *const stream, const int32_t arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 170);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_fixed32(stream, &arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_sfixed32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->sfixed32Value_count + 1 > 5)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->sfixed32Value[((InterfacesTest_TestAllTypesArray*)data)->sfixed32Value_count++]);
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->sfixed32Value_count + 1) > 5)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_fixed32(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->sfixed32Value[((InterfacesTest_TestAllTypesArray*)data)->sfixed32Value_count++]);
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_enumValue(qpb_ostream_t *const stream, const InterfacesTest_TestEnum arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 178);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_enumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->enumValue_count + 1 > 3)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->enumValue[((InterfacesTest_TestAllTypesArray*)data)->enumValue_count++], qpb_membersize(InterfacesTest_TestAllTypesArray, enumValue[0]));
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->enumValue_count + 1) > 3)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      result = qpb_decode_varint(stream, (void*)&((InterfacesTest_TestAllTypesArray*)data)->enumValue[((InterfacesTest_TestAllTypesArray*)data)->enumValue_count++], qpb_membersize(InterfacesTest_TestAllTypesArray, enumValue[0]));
   }
   return result;
}

static inline void encode_InterfacesTest_TestAllTypesArray_negEnumValue(qpb_ostream_t *const stream, const InterfacesTest_TestNegEnum arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      qpb_encode_varint(stream, 186);
      sizePtr = stream->buffer;
      stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
      dataPtr = stream->buffer;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         qpb_encode_varint(stream, arrayData[i]);
      }
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = sizePtr;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
}

static bool decode_InterfacesTest_TestAllTypesArray_negEnumValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   bool result = false;
   /* Reading packed */
   if (wiretype == QPB_WT_STRING)
   {
      qpb_size_t size;
      qpb_byte_t* endPtr;
      result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      endPtr = stream->buffer + size;
      while (stream->buffer < endPtr && result)
      {
         if (((InterfacesTest_TestAllTypesArray*)data)->negEnumValue_count + 1 > 3)
         {
            QPB_RETURN_ERROR(stream, "array overflow");
         }
         qpb_int64_t value;
         result = qpb_decode_varint(stream, &value, sizeof(qpb_int64_t));
         if (result)
         {
#ifndef QPB_WITHOUT_64BIT
            /* Protobuf only supports int32 values for enums */
            result = INT32_MIN <= value && value <= INT32_MAX;
            if (result)
            {
               ((InterfacesTest_TestAllTypesArray*)data)->negEnumValue[((InterfacesTest_TestAllTypesArray*)data)->negEnumValue_count++] = (InterfacesTest_TestNegEnum)value;
            }
#else
            ((InterfacesTest_TestAllTypesArray*)data)->negEnumValue[((InterfacesTest_TestAllTypesArray*)data)->negEnumValue_count++] = (InterfacesTest_TestNegEnum)value;
#endif
         }
      }
   }
   /* Reading non-packed */
   else
   {
      if ((((InterfacesTest_TestAllTypesArray*)data)->negEnumValue_count + 1) > 3)
      {
         QPB_RETURN_ERROR(stream, "array overflow");
      }
      qpb_int64_t value;
      result = qpb_decode_varint(stream, &value, sizeof(qpb_int64_t));
      if (result)
      {
#ifndef QPB_WITHOUT_64BIT
         /* Protobuf only supports int32 values for enums */
         result = INT32_MIN <= value && value <= INT32_MAX;
         if (result)
         {
            ((InterfacesTest_TestAllTypesArray*)data)->negEnumValue[((InterfacesTest_TestAllTypesArray*)data)->negEnumValue_count++] = (InterfacesTest_TestNegEnum)value;
         }
#else
         ((InterfacesTest_TestAllTypesArray*)data)->negEnumValue[((InterfacesTest_TestAllTypesArray*)data)->negEnumValue_count++] = (InterfacesTest_TestNegEnum)value;
#endif
      }
   }
   return result;
}

static inline void encode_InterfacesTest_ArrayOfProcessedTypes_Raw_processedTypesArray(qpb_ostream_t *const stream, const InterfacesTest_ProcessedTypes_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 10;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_InterfacesTest_ProcessedTypes_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_InterfacesTest_ArrayOfProcessedTypes_Raw_processedTypesArray(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((InterfacesTest_ArrayOfProcessedTypes_Raw*)data)->processedTypesArray_count + 1) > 5)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_InterfacesTest_ProcessedTypes_Raw(&substream, &((InterfacesTest_ArrayOfProcessedTypes_Raw*)data)->processedTypesArray[((InterfacesTest_ArrayOfProcessedTypes_Raw*)data)->processedTypesArray_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_InterfacesTest_ArrayOfProcessedTypes_processedTypesArray(qpb_ostream_t *const stream, const InterfacesTest_ProcessedTypes arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 10;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_InterfacesTest_ProcessedTypes(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_InterfacesTest_ArrayOfProcessedTypes_processedTypesArray(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((InterfacesTest_ArrayOfProcessedTypes*)data)->processedTypesArray_count + 1) > 5)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_InterfacesTest_ProcessedTypes(&substream, &((InterfacesTest_ArrayOfProcessedTypes*)data)->processedTypesArray[((InterfacesTest_ArrayOfProcessedTypes*)data)->processedTypesArray_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw_messageInMessageSint32(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw_messageInMessageSint32(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw*)data)->messageInMessageSint32, sizeof(int32_t));
}

static inline void encode_InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw_subMessageInMessageInMessage(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw_subMessageInMessageInMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw(&substream, &((InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw*)data)->subMessageInMessageInMessage);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_InterfacesTest_SubMessage_Raw_subString(qpb_ostream_t *const stream, const char *const data)
{
   qpb_size_t strSize = strlen(data);
   if (strSize != 0)
   {
      *stream->buffer = 10;
      ++stream->buffer;
      qpb_encode_bytes(stream, (qpb_byte_t*)data, strSize);
   }
}

static bool decode_InterfacesTest_SubMessage_Raw_subString(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_string_static(stream, ((InterfacesTest_SubMessage_Raw*)data)->subString, 19);
}

static inline void encode_InterfacesTest_SubMessage_Raw_subSubMessage(qpb_ostream_t *const stream, const InterfacesTest_SubSubMessage_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_InterfacesTest_SubSubMessage_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_InterfacesTest_SubMessage_Raw_subSubMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_InterfacesTest_SubSubMessage_Raw(&substream, &((InterfacesTest_SubMessage_Raw*)data)->subSubMessage);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_InterfacesTest_DeepSubMessage_Raw_subSint32Value(qpb_ostream_t *const stream, const int32_t *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 8;
      ++stream->buffer;
      qpb_encode_svarint(stream, *data);
   }
}

static bool decode_InterfacesTest_DeepSubMessage_Raw_subSint32Value(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_svarint(stream, (void*)&((InterfacesTest_DeepSubMessage_Raw*)data)->subSint32Value, sizeof(int32_t));
}

static inline void encode_InterfacesTest_DeepSubMessage_Raw_subBoolValue(qpb_ostream_t *const stream, const bool *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 16;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_DeepSubMessage_Raw_subBoolValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_DeepSubMessage_Raw*)data)->subBoolValue, sizeof(bool));
}

static inline void encode_InterfacesTest_DeepSubMessage_Raw_subMessage(qpb_ostream_t *const stream, const InterfacesTest_SubMessage_Raw arrayData[], const qpb_size_t arraySize)
{
   if (arraySize > 0)
   {
      qpb_byte_t* sizePtr;
      qpb_byte_t* dataPtr;
      qpb_size_t size;
      qpb_byte_t dataToClear;
      for (qpb_size_t i = 0; i < arraySize; ++i)
      {
         *stream->buffer = 42;
         ++stream->buffer;
         sizePtr = stream->buffer;
         stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
         dataPtr = stream->buffer;
         encode_InterfacesTest_SubMessage_Raw(stream, &arrayData[i]);
         /* Check size of encoded message and write size at the appropriate offset */
         size = (stream->buffer - dataPtr);
         stream->buffer = sizePtr;
         qpb_encode_varint(stream, (qpb_uint64_t)size);
         dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - sizePtr);
         /* Shift buffer back to end of varint */
         memmove(stream->buffer, dataPtr, size);
         stream->buffer += size;
         memset(stream->buffer, 0, dataToClear);
      }
   }
}

static bool decode_InterfacesTest_DeepSubMessage_Raw_subMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   if ((((InterfacesTest_DeepSubMessage_Raw*)data)->subMessage_count + 1) > 8)
   {
      QPB_RETURN_ERROR(stream, "array overflow");
   }
   {
      qpb_size_t size;
      qpb_istream_t substream;
      bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
      if (!result)
      {
         return false;
      }
      substream = qpb_istream_from_buffer(stream->buffer, size);
      result = decode_InterfacesTest_SubMessage_Raw(&substream, &((InterfacesTest_DeepSubMessage_Raw*)data)->subMessage[((InterfacesTest_DeepSubMessage_Raw*)data)->subMessage_count++]);
      if (!result)
      {
         QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
      }
      stream->buffer += size;
   }
   return true;
}

static inline void encode_InterfacesTest_DeepSubMessage_Raw_internalSubMessage(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 50;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_InterfacesTest_DeepSubMessage_Raw_internalSubMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw(&substream, &((InterfacesTest_DeepSubMessage_Raw*)data)->internalSubMessage);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_InterfacesTest_DeepSubMessage_Raw_enumInMessageValue(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage_EnumInMessage *const data)
{
   if (*data != 0)
   {
      *stream->buffer = 56;
      ++stream->buffer;
      qpb_encode_varint(stream, *data);
   }
}

static bool decode_InterfacesTest_DeepSubMessage_Raw_enumInMessageValue(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   return qpb_decode_varint(stream, (void*)&((InterfacesTest_DeepSubMessage_Raw*)data)->enumInMessageValue, qpb_membersize(InterfacesTest_DeepSubMessage_Raw, enumInMessageValue));
}

static inline void encode_InterfacesTest_MainMessage_Raw_subMessage(qpb_ostream_t *const stream, const InterfacesTest_SubMessage_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 10;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_InterfacesTest_SubMessage_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_InterfacesTest_MainMessage_Raw_subMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_InterfacesTest_SubMessage_Raw(&substream, &((InterfacesTest_MainMessage_Raw*)data)->subMessage);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

static inline void encode_InterfacesTest_MainMessage_Raw_deepSubMessage(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage_Raw *const data)
{
   qpb_byte_t* start;
   qpb_byte_t* dataPtr;
   qpb_size_t size;
   qpb_byte_t dataToClear;
   *stream->buffer = 18;
   ++stream->buffer;
   start = stream->buffer;
   stream->buffer += QPB_VARINT_MAX_ENCODED_SIZE;
   dataPtr = stream->buffer;
   encode_InterfacesTest_DeepSubMessage_Raw(stream, data);
   if (stream->buffer > dataPtr)
   {
      /* Check size of encoded message and write size at the appropriate offset */
      size = (stream->buffer - dataPtr);
      stream->buffer = start;
      qpb_encode_varint(stream, (qpb_uint64_t)size);
      dataToClear = QPB_VARINT_MAX_ENCODED_SIZE - (stream->buffer - start);
      /* Shift buffer back to end of varint */
      memmove(stream->buffer, dataPtr, size);
      stream->buffer += size;
      memset(stream->buffer, 0, dataToClear);
   }
   else /* No data written shift buffer back */
   {
      stream->buffer = start - 1;
      memset(stream->buffer, 0, 1);
   }
}

static bool decode_InterfacesTest_MainMessage_Raw_deepSubMessage(qpb_istream_t *const stream, void *const data, const qpb_wire_type_t wiretype)
{
   QPB_UNUSED(wiretype);
   qpb_size_t size;
   qpb_istream_t substream;
   bool result = qpb_decode_uvarint(stream, &size, sizeof(qpb_size_t));
   if (!result)
   {
      return false;
   }
   substream = qpb_istream_from_buffer(stream->buffer, size);
   result = decode_InterfacesTest_DeepSubMessage_Raw(&substream, &((InterfacesTest_MainMessage_Raw*)data)->deepSubMessage);
   if (!result)
   {
      QPB_RETURN_ERROR(stream, QPB_GET_ERROR(&substream));
   }
   stream->buffer += size;
   return result;
}

/* Encoding / decoding functions */
bool encode_InterfacesTest_TestAllTypesPointers_Raw(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypesPointers_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < (InterfacesTest_TestAllTypesPointers_static_size + (data->stringPointerValue != 0 ? strlen(data->stringPointerValue) + qpb_varint_max(strlen(data->stringPointerValue)) : 0) + (data->bytesPointerValue.size + qpb_varint_max(data->bytesPointerValue.size)) + (data->stringPointerValueArray[0] != 0 ? strlen(data->stringPointerValueArray[0]) + qpb_varint_max(strlen(data->stringPointerValueArray[0])) : 0) + (data->stringPointerValueArray[1] != 0 ? strlen(data->stringPointerValueArray[1]) + qpb_varint_max(strlen(data->stringPointerValueArray[1])) : 0) + (data->stringPointerValueArray[2] != 0 ? strlen(data->stringPointerValueArray[2]) + qpb_varint_max(strlen(data->stringPointerValueArray[2])) : 0) + (data->stringPointerValueArray[3] != 0 ? strlen(data->stringPointerValueArray[3]) + qpb_varint_max(strlen(data->stringPointerValueArray[3])) : 0) + (data->stringPointerValueArray[4] != 0 ? strlen(data->stringPointerValueArray[4]) + qpb_varint_max(strlen(data->stringPointerValueArray[4])) : 0) + (data->bytesPointerValueArray[0].size + qpb_varint_max(data->bytesPointerValueArray[0].size)) + (data->bytesPointerValueArray[1].size + qpb_varint_max(data->bytesPointerValueArray[1].size)) + (data->bytesPointerValueArray[2].size + qpb_varint_max(data->bytesPointerValueArray[2].size)) + (data->bytesPointerValueArray[3].size + qpb_varint_max(data->bytesPointerValueArray[3].size)) + (data->bytesPointerValueArray[4].size + qpb_varint_max(data->bytesPointerValueArray[4].size))))
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_TestAllTypesPointers_Raw_stringPointerValue(stream, data->stringPointerValue);
   encode_InterfacesTest_TestAllTypesPointers_Raw_bytesPointerValue(stream, &data->bytesPointerValue);
   encode_InterfacesTest_TestAllTypesPointers_Raw_stringPointerValueArray(stream, data->stringPointerValueArray, data->stringPointerValueArray_count);
   encode_InterfacesTest_TestAllTypesPointers_Raw_bytesPointerValueArray(stream, data->bytesPointerValueArray, data->bytesPointerValueArray_count);
   return true;
}

bool decode_InterfacesTest_TestAllTypesPointers_Raw(qpb_istream_t *const stream, InterfacesTest_TestAllTypesPointers_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_TestAllTypesPointers_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_TestAllTypesPointers_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw_subMessageInSubMessageBool(stream, &data->subMessageInSubMessageBool);
   return true;
}

bool decode_InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw(qpb_istream_t *const stream, InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_DeepSubMessage_MessageInSubMessage_SubMessageInSubMessage_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_ProcessedTypes_Raw(qpb_ostream_t *const stream, const InterfacesTest_ProcessedTypes_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_ProcessedTypes_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_ProcessedTypes_Raw_sint64ScaledValue(stream, &data->sint64ScaledValue);
   encode_InterfacesTest_ProcessedTypes_Raw_int64ScaledValue(stream, &data->int64ScaledValue);
   encode_InterfacesTest_ProcessedTypes_Raw_uint64ScaledValue(stream, &data->uint64ScaledValue);
   encode_InterfacesTest_ProcessedTypes_Raw_sint64ArrayScaledValue(stream, data->sint64ArrayScaledValue, data->sint64ArrayScaledValue_count);
   encode_InterfacesTest_ProcessedTypes_Raw_int64ArrayScaledValue(stream, data->int64ArrayScaledValue, data->int64ArrayScaledValue_count);
   encode_InterfacesTest_ProcessedTypes_Raw_uint64ArrayScaledValue(stream, data->uint64ArrayScaledValue, data->uint64ArrayScaledValue_count);
   return true;
}

bool decode_InterfacesTest_ProcessedTypes_Raw(qpb_istream_t *const stream, InterfacesTest_ProcessedTypes_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_ProcessedTypes_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_ProcessedTypes_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_ProcessedTypes(qpb_ostream_t *const stream, const InterfacesTest_ProcessedTypes *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_ProcessedTypes_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_ProcessedTypes_sint64ScaledValue(stream, &data->sint64ScaledValue);
   encode_InterfacesTest_ProcessedTypes_int64ScaledValue(stream, &data->int64ScaledValue);
   encode_InterfacesTest_ProcessedTypes_uint64ScaledValue(stream, &data->uint64ScaledValue);
   encode_InterfacesTest_ProcessedTypes_sint64ArrayScaledValue(stream, data->sint64ArrayScaledValue, data->sint64ArrayScaledValue_count);
   encode_InterfacesTest_ProcessedTypes_int64ArrayScaledValue(stream, data->int64ArrayScaledValue, data->int64ArrayScaledValue_count);
   encode_InterfacesTest_ProcessedTypes_uint64ArrayScaledValue(stream, data->uint64ArrayScaledValue, data->uint64ArrayScaledValue_count);
   return true;
}

bool decode_InterfacesTest_ProcessedTypes(qpb_istream_t *const stream, InterfacesTest_ProcessedTypes *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_ProcessedTypes_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_ProcessedTypes_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_SubSubMessage_Raw(qpb_ostream_t *const stream, const InterfacesTest_SubSubMessage_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_SubSubMessage_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_SubSubMessage_Raw_subSubUint32(stream, &data->subSubUint32);
   return true;
}

bool decode_InterfacesTest_SubSubMessage_Raw(qpb_istream_t *const stream, InterfacesTest_SubSubMessage_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_SubSubMessage_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_SubSubMessage_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_TestAllTypes_Raw(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypes_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_TestAllTypes_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_TestAllTypes_Raw_sint64Value(stream, &data->sint64Value);
   encode_InterfacesTest_TestAllTypes_Raw_sint32Value(stream, &data->sint32Value);
   encode_InterfacesTest_TestAllTypes_Raw_sint32Value16(stream, &data->sint32Value16);
   encode_InterfacesTest_TestAllTypes_Raw_sint32Value8(stream, &data->sint32Value8);
   encode_InterfacesTest_TestAllTypes_Raw_int64Value(stream, &data->int64Value);
   encode_InterfacesTest_TestAllTypes_Raw_int32Value(stream, &data->int32Value);
   encode_InterfacesTest_TestAllTypes_Raw_int32Value16(stream, &data->int32Value16);
   encode_InterfacesTest_TestAllTypes_Raw_int32Value8(stream, &data->int32Value8);
   encode_InterfacesTest_TestAllTypes_Raw_uint64Value(stream, &data->uint64Value);
   encode_InterfacesTest_TestAllTypes_Raw_uint32Value(stream, &data->uint32Value);
   encode_InterfacesTest_TestAllTypes_Raw_uint32Value16(stream, &data->uint32Value16);
   encode_InterfacesTest_TestAllTypes_Raw_uint32Value8(stream, &data->uint32Value8);
   encode_InterfacesTest_TestAllTypes_Raw_boolValue(stream, &data->boolValue);
   encode_InterfacesTest_TestAllTypes_Raw_floatValue(stream, &data->floatValue);
   encode_InterfacesTest_TestAllTypes_Raw_doubleValue(stream, &data->doubleValue);
   encode_InterfacesTest_TestAllTypes_Raw_stringValue(stream, data->stringValue);
   encode_InterfacesTest_TestAllTypes_Raw_bytesValue(stream, &data->bytesValue);
   encode_InterfacesTest_TestAllTypes_Raw_fixed64Value(stream, &data->fixed64Value);
   encode_InterfacesTest_TestAllTypes_Raw_fixed32Value(stream, &data->fixed32Value);
   encode_InterfacesTest_TestAllTypes_Raw_sfixed64Value(stream, &data->sfixed64Value);
   encode_InterfacesTest_TestAllTypes_Raw_sfixed32Value(stream, &data->sfixed32Value);
   encode_InterfacesTest_TestAllTypes_Raw_enumValue(stream, &data->enumValue);
   encode_InterfacesTest_TestAllTypes_Raw_negEnumValue(stream, &data->negEnumValue);
   return true;
}

bool decode_InterfacesTest_TestAllTypes_Raw(qpb_istream_t *const stream, InterfacesTest_TestAllTypes_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_TestAllTypes_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_TestAllTypes_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_TestAllTypes(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypes *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_TestAllTypes_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_TestAllTypes_Raw_sint64Value(stream, &data->sint64Value);
   encode_InterfacesTest_TestAllTypes_sint32Value(stream, &data->sint32Value);
   encode_InterfacesTest_TestAllTypes_Raw_sint32Value16(stream, &data->sint32Value16);
   encode_InterfacesTest_TestAllTypes_sint32Value8(stream, &data->sint32Value8);
   encode_InterfacesTest_TestAllTypes_Raw_int64Value(stream, &data->int64Value);
   encode_InterfacesTest_TestAllTypes_Raw_int32Value(stream, &data->int32Value);
   encode_InterfacesTest_TestAllTypes_int32Value16(stream, &data->int32Value16);
   encode_InterfacesTest_TestAllTypes_Raw_int32Value8(stream, &data->int32Value8);
   encode_InterfacesTest_TestAllTypes_Raw_uint64Value(stream, &data->uint64Value);
   encode_InterfacesTest_TestAllTypes_Raw_uint32Value(stream, &data->uint32Value);
   encode_InterfacesTest_TestAllTypes_uint32Value16(stream, &data->uint32Value16);
   encode_InterfacesTest_TestAllTypes_Raw_uint32Value8(stream, &data->uint32Value8);
   encode_InterfacesTest_TestAllTypes_Raw_boolValue(stream, &data->boolValue);
   encode_InterfacesTest_TestAllTypes_Raw_floatValue(stream, &data->floatValue);
   encode_InterfacesTest_TestAllTypes_Raw_doubleValue(stream, &data->doubleValue);
   encode_InterfacesTest_TestAllTypes_Raw_stringValue(stream, data->stringValue);
   encode_InterfacesTest_TestAllTypes_Raw_bytesValue(stream, &data->bytesValue);
   encode_InterfacesTest_TestAllTypes_Raw_fixed64Value(stream, &data->fixed64Value);
   encode_InterfacesTest_TestAllTypes_Raw_fixed32Value(stream, &data->fixed32Value);
   encode_InterfacesTest_TestAllTypes_Raw_sfixed64Value(stream, &data->sfixed64Value);
   encode_InterfacesTest_TestAllTypes_Raw_sfixed32Value(stream, &data->sfixed32Value);
   encode_InterfacesTest_TestAllTypes_Raw_enumValue(stream, &data->enumValue);
   encode_InterfacesTest_TestAllTypes_Raw_negEnumValue(stream, &data->negEnumValue);
   return true;
}

bool decode_InterfacesTest_TestAllTypes(qpb_istream_t *const stream, InterfacesTest_TestAllTypes *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_TestAllTypes_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_TestAllTypes_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_TestAllTypesArray_Raw(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypesArray_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_TestAllTypesArray_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_TestAllTypesArray_Raw_sint64Value(stream, data->sint64Value, data->sint64Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_sint32Value(stream, data->sint32Value, data->sint32Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_sint32Value16(stream, data->sint32Value16, data->sint32Value16_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_sint32Value8(stream, data->sint32Value8, data->sint32Value8_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_int64Value(stream, data->int64Value, data->int64Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_int32Value(stream, data->int32Value, data->int32Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_int32Value16(stream, data->int32Value16, data->int32Value16_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_int32Value8(stream, data->int32Value8, data->int32Value8_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_uint64Value(stream, data->uint64Value, data->uint64Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_uint32Value(stream, data->uint32Value, data->uint32Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_uint32Value16(stream, data->uint32Value16, data->uint32Value16_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_uint32Value8(stream, data->uint32Value8, data->uint32Value8_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_boolValue(stream, data->boolValue, data->boolValue_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_floatValue(stream, data->floatValue, data->floatValue_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_doubleValue(stream, data->doubleValue, data->doubleValue_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_stringValue(stream, data->stringValue, data->stringValue_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_bytesValue(stream, data->bytesValue, data->bytesValue_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_fixed64Value(stream, data->fixed64Value, data->fixed64Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_fixed32Value(stream, data->fixed32Value, data->fixed32Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_sfixed64Value(stream, data->sfixed64Value, data->sfixed64Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_sfixed32Value(stream, data->sfixed32Value, data->sfixed32Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_enumValue(stream, data->enumValue, data->enumValue_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_negEnumValue(stream, data->negEnumValue, data->negEnumValue_count);
   return true;
}

bool decode_InterfacesTest_TestAllTypesArray_Raw(qpb_istream_t *const stream, InterfacesTest_TestAllTypesArray_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_TestAllTypesArray_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_TestAllTypesArray_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_TestAllTypesArray(qpb_ostream_t *const stream, const InterfacesTest_TestAllTypesArray *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_TestAllTypesArray_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_TestAllTypesArray_sint64Value(stream, data->sint64Value, data->sint64Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_sint32Value(stream, data->sint32Value, data->sint32Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_sint32Value16(stream, data->sint32Value16, data->sint32Value16_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_sint32Value8(stream, data->sint32Value8, data->sint32Value8_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_int64Value(stream, data->int64Value, data->int64Value_count);
   encode_InterfacesTest_TestAllTypesArray_int32Value(stream, data->int32Value, data->int32Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_int32Value16(stream, data->int32Value16, data->int32Value16_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_int32Value8(stream, data->int32Value8, data->int32Value8_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_uint64Value(stream, data->uint64Value, data->uint64Value_count);
   encode_InterfacesTest_TestAllTypesArray_uint32Value(stream, data->uint32Value, data->uint32Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_uint32Value16(stream, data->uint32Value16, data->uint32Value16_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_uint32Value8(stream, data->uint32Value8, data->uint32Value8_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_boolValue(stream, data->boolValue, data->boolValue_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_floatValue(stream, data->floatValue, data->floatValue_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_doubleValue(stream, data->doubleValue, data->doubleValue_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_stringValue(stream, data->stringValue, data->stringValue_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_bytesValue(stream, data->bytesValue, data->bytesValue_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_fixed64Value(stream, data->fixed64Value, data->fixed64Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_fixed32Value(stream, data->fixed32Value, data->fixed32Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_sfixed64Value(stream, data->sfixed64Value, data->sfixed64Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_sfixed32Value(stream, data->sfixed32Value, data->sfixed32Value_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_enumValue(stream, data->enumValue, data->enumValue_count);
   encode_InterfacesTest_TestAllTypesArray_Raw_negEnumValue(stream, data->negEnumValue, data->negEnumValue_count);
   return true;
}

bool decode_InterfacesTest_TestAllTypesArray(qpb_istream_t *const stream, InterfacesTest_TestAllTypesArray *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_TestAllTypesArray_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_TestAllTypesArray_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_ArrayOfProcessedTypes_Raw(qpb_ostream_t *const stream, const InterfacesTest_ArrayOfProcessedTypes_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_ArrayOfProcessedTypes_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_ArrayOfProcessedTypes_Raw_processedTypesArray(stream, data->processedTypesArray, data->processedTypesArray_count);
   return true;
}

bool decode_InterfacesTest_ArrayOfProcessedTypes_Raw(qpb_istream_t *const stream, InterfacesTest_ArrayOfProcessedTypes_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_ArrayOfProcessedTypes_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_ArrayOfProcessedTypes_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_ArrayOfProcessedTypes(qpb_ostream_t *const stream, const InterfacesTest_ArrayOfProcessedTypes *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_ArrayOfProcessedTypes_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_ArrayOfProcessedTypes_processedTypesArray(stream, data->processedTypesArray, data->processedTypesArray_count);
   return true;
}

bool decode_InterfacesTest_ArrayOfProcessedTypes(qpb_istream_t *const stream, InterfacesTest_ArrayOfProcessedTypes *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_ArrayOfProcessedTypes_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_ArrayOfProcessedTypes_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_DeepSubMessage_MessageInSubMessage_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw_messageInMessageSint32(stream, &data->messageInMessageSint32);
   encode_InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw_subMessageInMessageInMessage(stream, &data->subMessageInMessageInMessage);
   return true;
}

bool decode_InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw(qpb_istream_t *const stream, InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_DeepSubMessage_MessageInSubMessage_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_SubMessage_Raw(qpb_ostream_t *const stream, const InterfacesTest_SubMessage_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_SubMessage_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_SubMessage_Raw_subString(stream, data->subString);
   encode_InterfacesTest_SubMessage_Raw_subSubMessage(stream, &data->subSubMessage);
   return true;
}

bool decode_InterfacesTest_SubMessage_Raw(qpb_istream_t *const stream, InterfacesTest_SubMessage_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_SubMessage_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_SubMessage_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_DeepSubMessage_Raw(qpb_ostream_t *const stream, const InterfacesTest_DeepSubMessage_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_DeepSubMessage_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_DeepSubMessage_Raw_subSint32Value(stream, &data->subSint32Value);
   encode_InterfacesTest_DeepSubMessage_Raw_subBoolValue(stream, &data->subBoolValue);
   encode_InterfacesTest_DeepSubMessage_Raw_subMessage(stream, data->subMessage, data->subMessage_count);
   encode_InterfacesTest_DeepSubMessage_Raw_internalSubMessage(stream, &data->internalSubMessage);
   encode_InterfacesTest_DeepSubMessage_Raw_enumInMessageValue(stream, &data->enumInMessageValue);
   return true;
}

bool decode_InterfacesTest_DeepSubMessage_Raw(qpb_istream_t *const stream, InterfacesTest_DeepSubMessage_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_DeepSubMessage_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_DeepSubMessage_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

bool encode_InterfacesTest_MainMessage_Raw(qpb_ostream_t *const stream, const InterfacesTest_MainMessage_Raw *const data)
{
   /* Optimize by checking that size is enough on top level? */
   if ((qpb_size_t)(stream->end - stream->buffer) < InterfacesTest_MainMessage_size)
   {
      QPB_RETURN_ERROR(stream, "Buffer to small");
   }
   encode_InterfacesTest_MainMessage_Raw_subMessage(stream, &data->subMessage);
   encode_InterfacesTest_MainMessage_Raw_deepSubMessage(stream, &data->deepSubMessage);
   return true;
}

bool decode_InterfacesTest_MainMessage_Raw(qpb_istream_t *const stream, InterfacesTest_MainMessage_Raw *const data)
{
   qpb_uint64_t tag;
   qpb_uint64_t id;
   qpb_wire_type_t wireType;
   bool result = true;
   while (stream->end != stream->buffer)
   {
      result = qpb_decode_uvarint(stream, &tag, sizeof(qpb_uint64_t));
      if (!result)
      {
         return false;
      }
      /* Extended support for NULL termination */
      if (tag == 0)
      {
         return true;
      }
      id = qpb_id(tag);
      wireType = (qpb_wire_type_t)qpb_wireType(tag);
      if (id < InterfacesTest_MainMessage_Raw_DECODERS_COUNT)
      {
         qpb_decoder_t decoder = InterfacesTest_MainMessage_Raw_decoders[id].func;
         result = decoder(stream, data, wireType);
      }
      else
      {
         result = qpb_skip_field(stream, NULL, wireType);
      }
      if (!result)
      {
         return false;
      }
   }
   return result;
}

/* On some platforms (such as AVR), double is really float.
 * These are not directly supported by qpb.
 * To get rid of this error, remove any double fields from your .proto.
 */
QPB_STATIC_ASSERT(sizeof(double) == 8, DOUBLE_MUST_BE_8_BYTES)
